--- linux/sound/core/misc.c	2003-07-01 11:41:35.000000000 +0200
+++ linux/sound/core/misc.c	2003-07-01 12:26:39.000000000 +0200
@@ -80,3 +80,104 @@
 
 }
 #endif
+
+#if defined(CONFIG_DEVFS_FS)
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 29)
+
+void snd_compat_devfs_remove(const char *fmt, ...)
+{
+	char buf[64];
+	va_list args;
+	int n;
+
+	va_start(args, fmt);
+	n = vsnprintf(buf, 64, fmt, args);
+	if (n < 64 && buf[0]) {
+		devfs_handle_t de = devfs_get_handle(NULL, buf, 0, 0, 0, 0);
+		devfs_unregister(de);
+		devfs_put(de);
+	}
+	va_end(args);
+}
+
+#endif /* 2.5.29 */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 67)
+
+int snd_compat_devfs_mk_dir(const char *dir, ...)
+{
+	char buf[64];
+	va_list args;
+	int n;
+
+	va_start(args, dir);
+	n = vsnprintf(buf, 64, dir, args);
+	va_end(args);
+	if (n < 64 && buf[0]) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,3,0)
+		return devfs_mk_dir(NULL, buf, strlen(dir), NULL) ? -EIO : 0;
+#else
+		return devfs_mk_dir(NULL, buf, NULL) ? -EIO : 0;
+#endif
+	}
+	return 0;
+}
+
+extern struct file_operations snd_fops;
+int snd_compat_devfs_mk_cdev(dev_t dev, umode_t mode, const char *fmt, ...)
+{
+	char buf[64];
+	va_list args;
+	int n;
+
+	va_start(args, fmt);
+	n = vsnprintf(buf, 64, fmt, args);
+	va_end(args);
+	if (n < 64 && buf[0]) {
+		devfs_register(NULL, buf, DEVFS_FL_DEFAULT,
+			       major(dev), minor(dev), mode,
+			       &snd_fops, NULL);
+	}
+	return 0;
+}
+
+#endif /* 2.5.67 */
+
+#endif /* CONFIG_DEVFS_FS */
+
+/* workqueue-alike; 2.5.45 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 45)
+
+#include <linux/smp_lock.h>
+
+static int work_caller(void *data)
+{
+	struct work_struct *works = data;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	lock_kernel();
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 2, 18)
+	daemonize();
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0) && LINUX_VERSION_CODE >= KERNEL_VERSION(2, 4, 8)
+	reparent_to_init();
+#endif
+	strcpy(current->comm, "snd"); /* FIXME: different names? */
+
+	works->func(works->data);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+	unlock_kernel();
+#endif
+
+	return 0;
+}
+
+int snd_compat_schedule_work(struct work_struct *works)
+{
+	return kernel_thread(work_caller, works, 0) >= 0;
+}
+
+#endif
--- linux/include/sound/driver.h	2003-07-01 12:37:03.000000000 +0200
+++ linux/include/sound/driver.h	2003-07-01 12:37:24.000000000 +0200
@@ -63,4 +63,6 @@
 
 #include "sndmagic.h"
 
+#include "wrappers.h"
+
 #endif /* __SOUND_DRIVER_H */
--- /dev/null	2003-07-01 12:37:32.000000000 +0200
+++ linux/include/sound/wrappers.h	2003-07-01 12:53:17.000000000 +0200
@@ -0,0 +1,221 @@
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+#include <linux/kmod.h>
+#undef request_module
+void snd_compat_request_module(const char *name, ...);
+#define request_module(name, args...) snd_compat_request_module(name, ##args)
+#endif
+
+#include <linux/compiler.h>
+#ifndef __user
+#define __user
+#endif
+
+/* wrappers for 2.4 */
+#include <linux/kdev_t.h>
+#ifndef major
+#define major(x) MAJOR(x)
+#endif
+#ifndef minor
+#define minor(x) MINOR(x)
+#endif
+#ifndef mk_kdev
+#define mk_kdev(maj, min) MKDEV(maj, min)
+#endif
+#ifndef DECLARE_BITMAP
+#define DECLARE_BITMAP(name,bits) \
+	unsigned long name[((bits)+BITS_PER_LONG-1)/BITS_PER_LONG]
+#endif
+
+#if 0 /* O(1) patch already includes the backport of need_resched().
+	 if your kernel don't include O(1) patch, enable the following */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 3)
+#define need_resched() (current->need_resched)
+#endif
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 4)
+#include <linux/fs.h>
+static inline struct proc_dir_entry *PDE(const struct inode *inode)
+{
+	return (struct proc_dir_entry *) inode->u.generic_ip;
+}
+#endif
+#include <asm/io.h>
+#if !defined(isa_virt_to_bus)
+#if defined(virt_to_bus) || defined(__alpha__)
+#define isa_virt_to_bus virt_to_bus
+#endif
+#endif
+
+#ifndef CONFIG_HAVE_STRLCPY
+size_t snd_compat_strlcpy(char *dest, const char *src, size_t size);
+#define strlcpy(dest, src, size) snd_compat_strlcpy(dest, src, size)
+size_t snd_compat_strlcat(char *dest, const char *src, size_t size);
+#define strlcat(dest, src, size) snd_compat_strlcat(dest, src, size)
+#endif
+
+/* no vsnprintf yet? */
+/* FIXME: the version number is not sure.. at least it exists already on 2.4.10 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 10)
+#define vsnprintf(buf,size,fmt,args) vsprintf(buf,fmt,args)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 28)
+#include <linux/threads.h>
+#include <linux/interrupt.h>
+static inline void synchronize_irq_wrapper(unsigned int irq) { synchronize_irq(); }
+#undef synchronize_irq
+#define synchronize_irq(irq)	synchronize_irq_wrapper(irq)
+#endif /* LINUX_VERSION_CODE < 2.5.28 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 68)
+#define IRQ_NONE	/*void*/
+#define IRQ_HANDLED	/*void*/
+#define IRQ_RETVAL(x)	/*void*/
+typedef void irqreturn_t;
+#endif /* LINUX_VERSION_CODE < 2.5.68 */
+
+#include <linux/devfs_fs_kernel.h>
+#ifdef CONFIG_DEVFS_FS
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 29)
+#include <linux/fs.h>
+#undef register_chrdev
+#define register_chrdev devfs_register_chrdev
+#undef unregister_chrdev
+#define unregister_chrdev devfs_unregister_chrdev
+#undef devfs_remove
+#define devfs_remove snd_compat_devfs_remove
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 67)
+#undef devfs_mk_dir
+int snd_compat_devfs_mk_dir(const char *dir, ...);
+#define devfs_mk_dir snd_compat_devfs_mk_dir
+#undef devfs_mk_cdev
+int snd_compat_devfs_mk_cdev(dev_t dev, umode_t mode, const char *fmt, ...);
+#define devfs_mk_cdev snd_compat_devfs_mk_cdev
+#endif
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 3, 0)
+static inline void devfs_find_and_unregister (devfs_handle_t dir, const char *name,
+					      unsigned int major, unsigned int minor,
+                                              char type, int traverse_symlinks)
+{
+	devfs_handle_t master;
+	master = devfs_find_handle(dir, name, strlen(name), major, minor, type, traverse_symlinks);
+	devfs_unregister(master);
+}
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+static inline void devfs_find_and_unregister (devfs_handle_t dir, const char *name,
+					      unsigned int major, unsigned int minor,
+                                              char type, int traverse_symlinks)
+{
+	devfs_handle_t master;
+	master = devfs_find_handle(dir, name, major, minor, type, traverse_symlinks);
+	devfs_unregister(master);
+}
+#endif
+#else
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 29)
+static inline void devfs_remove(const char *fmt, ...) { }
+#undef devfs_mk_dir
+#define devfs_mk_dir(dir, args...) do { (void)(dir); } while (0)
+#undef devfs_mk_cdev
+#define devfs_mk_cdev(dev, mode, fmt, args...) do { (void)(dev); } while (0)
+#endif
+#endif /* CONFIG_DEVFS_FS */
+
+/* workarounds for USB API */
+#if defined(SND_NEED_USB_WRAPPER) && (defined(CONFIG_USB) || defined(CONFIG_USB_MODULE))
+
+#include <linux/usb.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 4, 20)
+inline static int usb_make_path(struct usb_device *dev, char *buf, size_t size)
+{
+	int actual;
+	actual = snprintf(buf, size, "%03d/%03d", dev->bus->busnum, dev->devnum);
+	return (actual >= (int)size) ? -1 : actual;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+inline static struct urb *usb_alloc_urb_wrapper(int iso_packets, int flags)
+{
+	return usb_alloc_urb(iso_packets);
+}
+inline static int usb_submit_urb_wrapper(struct urb *urb, int flags)
+{
+	return usb_submit_urb(urb);
+}
+#undef usb_alloc_urb
+#undef usb_submit_urb
+#define usb_alloc_urb(n,flags) usb_alloc_urb_wrapper(n,flags)
+#define usb_submit_urb(p,flags) usb_submit_urb_wrapper(p,flags)
+#define OLD_USB
+#endif /* LINUX_VERSION_CODE < 2.5.0 */
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 24)
+int snd_hack_usb_set_interface(struct usb_device *dev, int interface, int alternate);
+#undef usb_set_interface
+#define usb_set_interface(dev,iface,alt) snd_hack_usb_set_interface(dev,iface,alt)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 45)
+#define URB_ISO_ASAP		USB_ISO_ASAP
+#define URB_ASYNC_UNLINK	USB_ASYNC_UNLINK
+#define usb_fill_int_urb	FILL_INT_URB
+#define usb_fill_bulk_urb	FILL_BULK_URB
+#define usb_host_config		usb_config_descriptor
+#define usb_host_interface	usb_interface_descriptor
+#define usb_host_endpoint	usb_endpoint_descriptor
+#define get_iface(cfg, num)	(&(cfg)->interface[num])
+#define get_iface_desc(iface)	(iface)
+#define get_endpoint(alt,ep)	(&(alt)->endpoint[ep])
+#define get_ep_desc(ep)		(ep)
+#define get_cfg_desc(cfg)	(cfg)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 45)
+#define usb_pipe_needs_resubmit(pipe) (!usb_pipeint(pipe))
+#endif
+
+#endif /* SND_NEED_USB_WRAPPER && CONFIG_USB */
+
+/* workqueue-alike; 2.5.45 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 45)
+struct work_struct {
+	void (*func)(void *);
+	void *data;
+};
+#define INIT_WORK(_work, _func, _data)			\
+	do {						\
+		(_work)->func = _func;			\
+		(_work)->data = _data;			\
+	} while (0)
+#define __WORK_INITIALIZER(n, f, d) {			\
+	.func = (f),					\
+	.data = (d),					\
+	}
+#define DECLARE_WORK(n, f, d)				\
+	struct work_struct n = __WORK_INITIALIZER(n, f, d)
+int snd_compat_schedule_work(struct work_struct *work);
+#define schedule_work(w) snd_compat_schedule_work(w)
+#endif /* 2.5.45 */
+
+/* 2.5 new modules */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+#define try_module_get(x) try_inc_mod_count(x)
+static inline void module_put(struct module *module)
+{
+	if (module)
+		__MOD_DEC_USE_COUNT(module);
+}
+#endif /* 2.5.0 */
+
+/* gameport - 2.4 has different defines */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 5, 0)
+#ifdef CONFIG_INPUT_GAMEPORT
+#define CONFIG_GAMEPORT
+#endif
+#ifdef CONFIG_INPUT_GAMEPORT_MODULE
+#define CONFIG_GAMEPORT_MODULE
+#endif
+#endif /* 2.5.0 */
--- linux/sound/core/sound.c	2003-07-23 15:56:26.000000000 +0200
+++ linux/sound/core/sound.c	2003-07-23 15:54:53.000000000 +0200
@@ -518,3 +518,6 @@
 EXPORT_SYMBOL(snd_wrapper_vmalloc);
 EXPORT_SYMBOL(snd_wrapper_vfree);
 #endif
+EXPORT_SYMBOL(snd_compat_strlcpy);
+EXPORT_SYMBOL(snd_compat_strlcat);
+EXPORT_SYMBOL(snd_compat_request_module);
--- linux/sound/core/wrappers.c	2003-04-08 14:21:27.000000000 +0200
+++ linux/sound/core/wrappers.c	2003-07-23 17:26:33.000000000 +0200
@@ -48,3 +48,48 @@
 }
 #endif
 
+#ifndef BUG_ON
+#define BUG_ON(x) /* nothing */
+#endif
+size_t snd_compat_strlcpy(char *dest, const char *src, size_t size)
+{
+	size_t ret = strlen(src);
+
+	if (size) {
+		size_t len = (ret >= size) ? size-1 : ret;
+		memcpy(dest, src, len);
+		dest[len] = '\0';
+	}
+	return ret;
+}
+
+size_t snd_compat_strlcat(char *dest, const char *src, size_t count)
+{
+	size_t dsize = strlen(dest);
+	size_t len = strlen(src);
+	size_t res = dsize + len;
+
+	/* This would be a bug */
+	BUG_ON(dsize >= count);
+
+	dest += dsize;
+	count -= dsize;
+	if (len >= count)
+		len = count-1;
+	memcpy(dest, src, len);
+	dest[len] = 0;
+	return res;
+}
+
+void snd_compat_request_module(const char *fmt, ...)
+{
+	char buf[64];
+	va_list args;
+	int n;
+
+	va_start(args, fmt);
+	n = vsnprintf(buf, 64, fmt, args);
+	if (n < 64 && buf[0])
+		request_module(buf);
+	va_end(args);
+}
