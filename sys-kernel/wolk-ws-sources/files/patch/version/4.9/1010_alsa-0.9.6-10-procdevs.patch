--- linux/sound/core/info.c	18 Jul 2003 16:06:50 -0000	1.35
+++ linux/sound/core/info.c	18 Jul 2003 16:47:03 -0000
@@ -52,6 +52,7 @@
 		"synth",
 		"pcm",
 		"seq",
+		"dev",
 		NULL
 	};
 	char **xstr = reserved;
@@ -116,6 +117,7 @@
  */
 
 static struct proc_dir_entry *snd_proc_root = NULL;
+static struct proc_dir_entry *snd_proc_dev = NULL;
 snd_info_entry_t *snd_seq_root = NULL;
 #ifdef CONFIG_SND_OSSEMUL
 snd_info_entry_t *snd_oss_root = NULL;
@@ -527,6 +529,10 @@
 	if (p == NULL)
 		return -ENOMEM;
 	snd_proc_root = p;
+	p = snd_create_proc_entry("dev", S_IFDIR | S_IRUGO | S_IXUGO, snd_proc_root);
+	if (p == NULL)
+		return -ENOMEM;
+	snd_proc_dev = p;
 #ifdef CONFIG_SND_OSSEMUL
 	{
 		snd_info_entry_t *entry;
@@ -577,6 +583,7 @@
 		if (snd_oss_root)
 			snd_info_unregister(snd_oss_root);
 #endif
+		snd_remove_proc_entry(snd_proc_root, snd_proc_dev);
 		snd_remove_proc_entry(&proc_root, snd_proc_root);
 	}
 	return 0;
@@ -585,6 +592,32 @@
 /*
 
  */
+
+struct proc_dir_entry *snd_info_create_device(const char *name, unsigned short major, unsigned short minor, unsigned int mode, int gid, int uid)
+{
+	struct proc_dir_entry *p = NULL;
+
+	down(&info_mutex);
+	p = create_proc_entry(name, mode, snd_proc_dev);
+	if (p) {
+		p->rdev = mk_kdev(major, minor);
+		p->owner = THIS_MODULE;
+	} else {
+		up(&info_mutex);
+		return NULL;
+	}
+	p->gid = gid;
+	p->uid = uid;
+	up(&info_mutex);
+	return p;
+}
+
+void snd_info_free_device(struct proc_dir_entry *p)
+{
+	down(&info_mutex);
+	snd_remove_proc_entry(snd_proc_dev, p);
+	up(&info_mutex);
+}
 
 
 /*
--- linux/sound/core/sound.c	2 Jun 2003 10:04:44 -0000	1.39
+++ linux/sound/core/sound.c	18 Jul 2003 16:10:12 -0000
@@ -38,9 +38,9 @@
 static int major = CONFIG_SND_MAJOR;
 int snd_major;
 static int cards_limit = SNDRV_CARDS;
-#ifdef CONFIG_DEVFS_FS
 static int device_mode = S_IFCHR | S_IRUGO | S_IWUGO;
-#endif
+static int device_gid = 0;
+static int device_uid = 0;
 
 MODULE_AUTHOR("Jaroslav Kysela <perex@suse.cz>");
 MODULE_DESCRIPTION("Advanced Linux Sound Architecture driver for soundcards.");
@@ -53,11 +53,15 @@
 MODULE_PARM(cards_limit, "i");
 MODULE_PARM_DESC(cards_limit, "Count of soundcards installed in the system.");
 MODULE_PARM_SYNTAX(cards_limit, "default:8,skill:advanced");
-#ifdef CONFIG_DEVFS_FS
 MODULE_PARM(device_mode, "i");
 MODULE_PARM_DESC(device_mode, "Device file permission mask for devfs.");
 MODULE_PARM_SYNTAX(device_mode, "default:0666,base:8");
-#endif
+MODULE_PARM(device_gid, "i");
+MODULE_PARM_DESC(device_gid, "Device file GID for sound dynamic device filesystem.");
+MODULE_PARM_SYNTAX(device_gid, "default:0");
+MODULE_PARM(device_uid, "i");
+MODULE_PARM_DESC(device_uid, "Device file UID for sound dynamic device filesystem.");
+MODULE_PARM_SYNTAX(device_uid, "default:0");
 
 int snd_ecards_limit;
 
@@ -219,6 +223,10 @@
 		kfree(preg);
 		return -EBUSY;
 	}
+	if (name)
+		preg->dev = snd_info_create_device(name, major, minor,
+						   S_IFCHR | device_mode,
+						   device_gid, device_uid);
 	list_add_tail(&preg->list, &snd_minors_hash[SNDRV_MINOR_CARD(minor)]);
 #ifdef CONFIG_DEVFS_FS
 	if (strncmp(name, "controlC", 8))     /* created in sound.c */
@@ -251,6 +259,8 @@
 		up(&sound_mutex);
 		return -EINVAL;
 	}
+	if (mptr->dev)
+		snd_info_free_device(mptr->dev);
 #ifdef CONFIG_DEVFS_FS
 	if (strncmp(mptr->name, "controlC", 8))	/* created in sound.c */
 		devfs_remove("snd/%s", mptr->name);
--- linux/include/sound/core.h	18 Jul 2003 16:06:40 -0000	1.40
+++ linux/include/sound/core.h	18 Jul 2003 16:08:39 -0000
@@ -214,6 +214,7 @@
 	int device;			/* device number */
 	const char *comment;		/* for /proc/asound/devices */
 	struct file_operations *f_ops;	/* file operations */
+	struct proc_dir_entry *dev;
 	char name[0];			/* device name (keep at the end of structure) */
 };
 
--- linux/include/sound/info.h	18 Jul 2003 16:06:40 -0000	1.12
+++ linux/include/sound/info.h	18 Jul 2003 16:09:43 -0000
@@ -117,6 +117,12 @@
 					     const char *name,
 					     snd_info_entry_t * parent);
 void snd_info_free_entry(snd_info_entry_t * entry);
+struct proc_dir_entry *snd_info_create_device(const char *name,
+					      unsigned short major,
+					      unsigned short minor,
+					      unsigned int mode,
+					      int gid, int uid);
+void snd_info_free_device(struct proc_dir_entry * entry);
 int snd_info_store_text(snd_info_entry_t * entry);
 int snd_info_restore_text(snd_info_entry_t * entry);
 
