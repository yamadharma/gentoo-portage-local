--- linux/include/sound/sndmagic.h	2003-06-18 12:24:51.000000000 +0200
+++ linux/include/sound/sndmagic.h	2003-07-01 16:17:33.000000000 +0200
@@ -197,6 +197,8 @@
 #define vx_core_t_magic				0xa15a4110
 #define vx_pipe_t_magic				0xa15a4112
 #define azf3328_t_magic				0xa15a4200
+#define snd_msndpinnacle_pcm_t_magic		0xa15a3e01
+#define msndmidi_t_magic			0xa15a3e02
 
 #else
 
--- linux/sound/isa/Config.in	2002-07-15 17:21:51.000000000 +0200
+++ linux/sound/isa/Config.in	2002-07-15 17:22:46.000000000 +0200
@@ -33,5 +33,8 @@
 dep_tristate 'Yamaha OPL3-SA2/SA3' CONFIG_SND_OPL3SA2 $CONFIG_SND
 dep_tristate 'Aztech Sound Galaxy' CONFIG_SND_SGALAXY $CONFIG_SND
 dep_tristate 'Ensoniq SoundScape PnP' CONFIG_SND_SSCAPE $CONFIG_SND
+if [ "$CONFIG_X86" = "y" ]; then
+  dep_tristate 'Turtle Beach Fiji,Pinnacle' CONFIG_SND_MSND_PINNACLE $CONFIG_SND
+fi
 
 endmenu
--- linux/sound/isa/Makefile	2002-07-15 17:23:48.000000000 +0200
+++ linux/sound/isa/Makefile	2002-07-15 17:23:49.000000000 +0200
@@ -5,7 +5,7 @@
 
 O_TARGET     := _isa.o
 
-mod-subdirs  := ad1816a ad1848 cs423x es1688 gus opti9xx sb wavefront
+mod-subdirs  := ad1816a ad1848 cs423x es1688 gus opti9xx sb wavefront msnd
 
 list-multi   := snd-als100.o snd-azt2320.o snd-cmi8330.o snd-dt019x.o \
 		snd-es18xx.o snd-opl3sa2.o snd-sgalaxy.o snd-sscape.o
@@ -29,7 +29,7 @@
 obj-$(CONFIG_SND_SGALAXY) += snd-sgalaxy.o
 obj-$(CONFIG_SND_SSCAPE) += snd-sscape.o
 
-subdir-$(CONFIG_SND) += ad1816a ad1848 cs423x es1688 gus opti9xx sb wavefront
+subdir-$(CONFIG_SND) += ad1816a ad1848 cs423x es1688 gus opti9xx sb wavefront msnd
 ifeq ($(CONFIG_SND),y)
   obj-y += ad1816a/_ad1816a.o \
 	   ad1848/_ad1848.o \
@@ -38,7 +38,8 @@
 	   gus/_gus.o \
 	   opti9xx/_opti9xx.o \
 	   sb/_sb.o \
-	   wavefront/_wavefront.o
+	   wavefront/_wavefront.o \
+	   msnd/_msnd.o
 endif
 
 include $(TOPDIR)/Rules.make
--- /dev/null	2002-06-21 03:44:19.000000000 +0200
+++ linux/sound/isa/msnd/Makefile	2002-07-15 17:25:37.000000000 +0200
@@ -0,0 +1,21 @@
+#
+# Makefile for ALSA
+# Copyright (c) 2001 by Jaroslav Kysela <perex@suse.cz>
+#
+
+O_TARGET     := _msnd.o
+
+list-multi   := snd-msnd-pinnacle.o
+
+snd-msnd-pinnacle-objs := msnd.o msnd_pinnacle.o msnd_pinnacle_mixer.o msnd_midi.o
+# snd-msnd-classic-objs := msnd.o msnd_classic.o msnd_midi.o
+
+# Toplevel Module Dependency
+obj-$(CONFIG_SND_MSND_PINNACLE) += snd-msnd-pinnacle.o
+# obj-$(CONFIG_SND_MSND_CLASSIC) += snd-msnd-classic.o
+
+include $(TOPDIR)/Rules.make
+
+snd-msnd-pinnacle.o: $(snd-msnd-pinnacle-objs)
+	$(LD) $(LD_RFLAG) -r -o $@ $(snd-msnd-pinnacle-objs)
+
--- /dev/null	2002-06-21 03:44:19.000000000 +0200
+++ linux/sound/isa/msnd/msnd.c	2002-07-08 11:56:47.000000000 +0200
@@ -0,0 +1,307 @@
+/*********************************************************************
+ *
+ * 2002/06/30 Karsten Wiese:
+ *	removed kernel-version dependencies.
+ *	ripped from linux kernel 2.4.18 (OSS Implementation) by me.
+ *	In the OSS Version, this file is compiled to a separate MODULE, that is used
+ *	by the pinnacle and the classic driver.
+ *	since there is no classic driver for alsa yet (i dont have a classic & writing one blindfold is difficult)
+ *	this file's object is statically linked into the pinnacle-driver-module for now.
+ *	look for the string
+ *		"uncomment this to make this a module again"
+ *	to do guess what.
+ *
+ * the following is a copy of the 2.4.18 OSS FREE file-heading comment:
+ *
+ * msnd.c - Driver Base
+ *
+ * Turtle Beach MultiSound Sound Card Driver for Linux
+ *
+ * Copyright (C) 1998 Andrew Veliath
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * $Id: msnd.c,v 1.17 1999/03/21 16:50:09 andrewtv Exp $
+ *
+ ********************************************************************/
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <asm/irq.h>
+#include "msnd.h"
+
+#define LOGNAME			"msnd"
+
+#define MSND_MAX_DEVS		4
+
+static multisound_dev_t		*devs[MSND_MAX_DEVS];
+static int			num_devs;
+
+
+int __init snd_msnd_register(multisound_dev_t *dev)
+{
+/* this is not really needed since alsa does the real (un)registration.
+ * remove this later.
+ */
+	int i;
+
+	for (i = 0; i < MSND_MAX_DEVS; ++i)
+		if (devs[i] == NULL)
+			break;
+
+	snd_printd( "snd_msnd_register(): %i\n", i);
+
+
+	if (i == MSND_MAX_DEVS)
+		return -ENOMEM;
+
+	devs[i] = dev;
+	++num_devs;
+
+//	MOD_INC_USE_COUNT;        uncomment this to make this a module again
+
+	return 0;
+}
+
+void snd_msnd_unregister(multisound_dev_t *dev)
+{
+/* this is not really needed since alsa does the real (un)registration.
+ * remove this later.
+ */
+	int i;
+
+	for (i = 0; i < MSND_MAX_DEVS; ++i)
+		if (devs[i] == dev)
+			break;
+
+	if (i == MSND_MAX_DEVS) {
+		printk(KERN_WARNING LOGNAME ": Unregistering unknown device\n");
+		return;
+	}
+
+	devs[i] = NULL;
+	--num_devs;
+
+//	MOD_DEC_USE_COUNT;         uncomment this to make this a module again
+}
+
+int snd_msnd_get_num_devs(void)
+{
+	return num_devs;
+}
+
+multisound_dev_t *snd_msnd_get_dev(int j)
+{
+	int i;
+
+	for (i = 0; i < MSND_MAX_DEVS && j; ++i)
+		if (devs[i] != NULL)
+			--j;
+
+	if (i == MSND_MAX_DEVS || j != 0)
+		return NULL;
+
+	return devs[i];
+}
+
+void snd_msnd_init_queue(unsigned long base, int start, int size)
+{
+	isa_writew(PCTODSP_BASED(start), base + JQS_wStart);
+	isa_writew(PCTODSP_OFFSET(size) - 1, base + JQS_wSize);
+	isa_writew(0, base + JQS_wHead);
+	isa_writew(0, base + JQS_wTail);
+}
+
+
+int snd_msnd_wait_TXDE(multisound_dev_t *dev)
+{
+	register unsigned int io = dev->io;
+	register int timeout = 1000;
+    
+	while(timeout-- > 0)
+		if (inb(io + HP_ISR) & HPISR_TXDE)
+			return 0;
+
+	return -EIO;
+}
+
+int snd_msnd_wait_HC0(multisound_dev_t *dev)
+{
+	register unsigned int io = dev->io;
+	register int timeout = 1000;
+
+	while(timeout-- > 0)
+		if (!(inb(io + HP_CVR) & HPCVR_HC))
+			return 0;
+
+	return -EIO;
+}
+
+int snd_msnd_send_dsp_cmd(multisound_dev_t *dev, BYTE cmd)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (snd_msnd_wait_HC0(dev) == 0) {
+		outb(cmd, dev->io + HP_CVR);
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return 0;
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	printk(KERN_DEBUG LOGNAME ": Send DSP command timeout\n");
+
+	return -EIO;
+}
+
+int snd_msnd_send_word(multisound_dev_t *dev, unsigned char high,
+		   unsigned char mid, unsigned char low)
+{
+	register unsigned int io = dev->io;
+
+	if (snd_msnd_wait_TXDE(dev) == 0) {
+		outb(high, io + HP_TXH);
+		outb(mid, io + HP_TXM);
+		outb(low, io + HP_TXL);
+		return 0;
+	}
+
+	printk(KERN_DEBUG LOGNAME ": Send host word timeout\n");
+
+	return -EIO;
+}
+
+int snd_msnd_upload_host(multisound_dev_t *dev, char *bin, int len)
+{
+	int i;
+
+	if (len % 3 != 0) {
+		printk(KERN_WARNING LOGNAME ": Upload host data not multiple of 3!\n");		
+		return -EINVAL;
+	}
+
+	for (i = 0; i < len; i += 3)
+		if (snd_msnd_send_word(dev, bin[i], bin[i + 1], bin[i + 2]) != 0)
+			return -EIO;
+
+	inb(dev->io + HP_RXL);
+	inb(dev->io + HP_CVR);
+
+	return 0;
+}
+
+int snd_msnd_enable_irq(multisound_dev_t *dev)
+{
+	unsigned long flags;
+
+	if (dev->irq_ref++)
+		return 0;
+
+	printk(KERN_DEBUG LOGNAME ": Enabling IRQ\n");
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (snd_msnd_wait_TXDE(dev) == 0) {
+		outb(inb(dev->io + HP_ICR) | HPICR_TREQ, dev->io + HP_ICR);
+		if (dev->type == msndClassic)
+			outb(dev->irqid, dev->io + HP_IRQM);
+		outb(inb(dev->io + HP_ICR) & ~HPICR_TREQ, dev->io + HP_ICR);
+		outb(inb(dev->io + HP_ICR) | HPICR_RREQ, dev->io + HP_ICR);
+		enable_irq(dev->irq);
+		snd_msnd_init_queue(dev->DSPQ, dev->dspq_data_buff, dev->dspq_buff_size);
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return 0;
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	printk(KERN_DEBUG LOGNAME ": Enable IRQ failed\n");
+
+	return -EIO;
+}
+
+int snd_msnd_disable_irq(multisound_dev_t *dev)
+{
+	unsigned long flags;
+
+	if (--dev->irq_ref > 0)
+		return 0;
+
+	if (dev->irq_ref < 0)
+		printk(KERN_DEBUG LOGNAME ": IRQ ref count is %d\n", dev->irq_ref);
+
+	printk(KERN_DEBUG LOGNAME ": Disabling IRQ\n");
+
+	spin_lock_irqsave(&dev->lock, flags);
+	if (snd_msnd_wait_TXDE(dev) == 0) {
+		outb(inb(dev->io + HP_ICR) & ~HPICR_RREQ, dev->io + HP_ICR);
+		if (dev->type == msndClassic)
+			outb(HPIRQ_NONE, dev->io + HP_IRQM);
+		disable_irq(dev->irq);
+		spin_unlock_irqrestore(&dev->lock, flags);
+		return 0;
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	printk(KERN_DEBUG LOGNAME ": Disable IRQ failed\n");
+
+	return -EIO;
+}
+
+/* uncomment this to make this a module again
+EXPORT_SYMBOL(snd_msnd_register);
+EXPORT_SYMBOL(snd_msnd_unregister);
+EXPORT_SYMBOL(snd_msnd_get_num_devs);
+EXPORT_SYMBOL(snd_msnd_get_dev);
+
+EXPORT_SYMBOL(snd_msnd_init_queue);
+
+EXPORT_SYMBOL(snd_msnd_fifo_init);
+EXPORT_SYMBOL(snd_msnd_fifo_free);
+EXPORT_SYMBOL(snd_msnd_fifo_alloc);
+EXPORT_SYMBOL(snd_msnd_fifo_make_empty);
+EXPORT_SYMBOL(snd_msnd_fifo_write);
+EXPORT_SYMBOL(snd_msnd_fifo_read);
+
+EXPORT_SYMBOL(snd_msnd_wait_TXDE);
+EXPORT_SYMBOL(snd_msnd_wait_HC0);
+EXPORT_SYMBOL(snd_msnd_send_dsp_cmd);
+EXPORT_SYMBOL(snd_msnd_send_word);
+EXPORT_SYMBOL(snd_msnd_upload_host);
+
+EXPORT_SYMBOL(snd_msnd_enable_irq);
+EXPORT_SYMBOL(snd_msnd_disable_irq);
+#endif*/
+
+/*#ifdef MODULE uncomment this to make this a module again
+MODULE_AUTHOR				("Andrew Veliath <andrewtv@usa.net>");
+MODULE_DESCRIPTION			("Turtle Beach MultiSound Driver Base");
+MODULE_LICENSE("GPL");
+
+
+int init_module(void)
+{
+	return 0;
+}
+
+void cleanup_module(void)
+{
+}
+#endif
+*/
\ No newline at end of file
--- /dev/null	2002-06-21 03:44:19.000000000 +0200
+++ linux/sound/isa/msnd/msnd.h	2002-07-08 12:14:26.000000000 +0200
@@ -0,0 +1,283 @@
+/*********************************************************************
+ *
+ * msnd.h
+ *
+ * Turtle Beach MultiSound Sound Card Driver for Linux
+ *
+ * Some parts of this header file were derived from the Turtle Beach
+ * MultiSound Driver Development Kit.
+ *
+ * Copyright (C) 1998 Andrew Veliath
+ * Copyright (C) 1993 Turtle Beach Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * $Id: msnd.h,v 1.36 1999/03/21 17:05:42 andrewtv Exp $
+ *
+ ********************************************************************/
+#ifndef __MSND_H
+#define __MSND_H
+
+#define VERSION			"0.1.3.0"
+
+#define DEFSAMPLERATE		44100
+#define DEFSAMPLESIZE		SNDRV_PCM_FORMAT_S16
+#define DEFCHANNELS		1
+
+#define SNDCARD_MSND		38
+
+#define SRAM_BANK_SIZE		0x8000
+#define SRAM_CNTL_START		0x7F00
+
+#define DSP_BASE_ADDR		0x4000
+#define DSP_BANK_BASE		0x4000
+
+#define	HP_ICR			0x00
+#define	HP_CVR			0x01
+#define	HP_ISR			0x02
+#define	HP_IVR			0x03
+#define HP_NU			0x04
+#define HP_INFO			0x04
+#define	HP_TXH			0x05
+#define	HP_RXH			0x05
+#define	HP_TXM			0x06
+#define	HP_RXM			0x06
+#define	HP_TXL			0x07
+#define	HP_RXL			0x07
+
+#define HP_ICR_DEF		0x00
+#define HP_CVR_DEF		0x12
+#define HP_ISR_DEF		0x06
+#define HP_IVR_DEF		0x0f
+#define HP_NU_DEF		0x00
+
+#define	HP_IRQM			0x09
+
+#define	HPR_BLRC		0x08
+#define	HPR_SPR1		0x09
+#define	HPR_SPR2		0x0A
+#define	HPR_TCL0		0x0B
+#define	HPR_TCL1		0x0C
+#define	HPR_TCL2		0x0D
+#define	HPR_TCL3		0x0E
+#define	HPR_TCL4		0x0F
+
+#define	HPICR_INIT		0x80
+#define HPICR_HM1		0x40
+#define HPICR_HM0		0x20
+#define HPICR_HF1		0x10
+#define HPICR_HF0		0x08
+#define	HPICR_TREQ		0x02
+#define	HPICR_RREQ		0x01
+
+#define HPCVR_HC		0x80
+
+#define	HPISR_HREQ		0x80
+#define HPISR_DMA		0x40
+#define HPISR_HF3		0x10
+#define HPISR_HF2		0x08
+#define	HPISR_TRDY		0x04
+#define	HPISR_TXDE		0x02
+#define	HPISR_RXDF		0x01
+
+#define	HPIO_290		0
+#define	HPIO_260		1
+#define	HPIO_250		2
+#define	HPIO_240		3
+#define	HPIO_230		4
+#define	HPIO_220		5
+#define	HPIO_210		6
+#define	HPIO_3E0		7
+
+#define	HPMEM_NONE		0
+#define	HPMEM_B000		1
+#define	HPMEM_C800		2
+#define	HPMEM_D000		3
+#define	HPMEM_D400		4
+#define	HPMEM_D800		5
+#define	HPMEM_E000		6
+#define	HPMEM_E800		7
+
+#define	HPIRQ_NONE		0
+#define HPIRQ_5			1
+#define HPIRQ_7			2
+#define HPIRQ_9			3
+#define HPIRQ_10		4
+#define HPIRQ_11		5
+#define HPIRQ_12		6
+#define HPIRQ_15		7
+
+#define	HIMT_PLAY_DONE		0x00
+#define	HIMT_RECORD_DONE	0x01
+#define	HIMT_MIDI_EOS		0x02
+#define	HIMT_MIDI_OUT		0x03
+
+#define	HIMT_MIDI_IN_UCHAR	0x0E
+#define	HIMT_DSP		0x0F
+
+#define	HDEX_BASE	       	0x92
+#define	HDEX_PLAY_START		(0 + HDEX_BASE)
+#define	HDEX_PLAY_STOP		(1 + HDEX_BASE)
+#define	HDEX_PLAY_PAUSE		(2 + HDEX_BASE)
+#define	HDEX_PLAY_RESUME	(3 + HDEX_BASE)
+#define	HDEX_RECORD_START	(4 + HDEX_BASE)
+#define	HDEX_RECORD_STOP	(5 + HDEX_BASE)
+#define	HDEX_MIDI_IN_START 	(6 + HDEX_BASE)
+#define	HDEX_MIDI_IN_STOP	(7 + HDEX_BASE)
+#define	HDEX_MIDI_OUT_START	(8 + HDEX_BASE)
+#define	HDEX_MIDI_OUT_STOP	(9 + HDEX_BASE)
+#define	HDEX_AUX_REQ		(10 + HDEX_BASE)
+
+#define HIWORD(l)		((WORD)((((DWORD)(l)) >> 16) & 0xFFFF))
+#define LOWORD(l)		((WORD)(DWORD)(l))
+#define HIBYTE(w)		((BYTE)(((WORD)(w) >> 8) & 0xFF))
+#define LOBYTE(w)		((BYTE)(w))
+#define MAKELONG(low,hi)	((long)(((WORD)(low))|(((DWORD)((WORD)(hi)))<<16)))
+#define MAKEWORD(low,hi)	((WORD)(((BYTE)(low))|(((WORD)((BYTE)(hi)))<<8)))
+
+#define PCTODSP_OFFSET(w)	(USHORT)((w)/2)
+#define PCTODSP_BASED(w)	(USHORT)(((w)/2) + DSP_BASE_ADDR)
+#define DSPTOPC_BASED(w)	(((w) - DSP_BASE_ADDR) * 2)
+
+#ifdef SLOWIO
+#  undef outb
+#  undef inb
+#  define outb			outb_p
+#  define inb			inb_p
+#endif
+
+/* JobQueueStruct */
+#define JQS_wStart		0x00
+#define JQS_wSize		0x02
+#define JQS_wHead		0x04
+#define JQS_wTail		0x06
+#define JQS__size		0x08
+
+/* DAQueueDataStruct */
+#define DAQDS_wStart		0x00
+#define DAQDS_wSize		0x02
+#define DAQDS_wFormat		0x04
+#define DAQDS_wSampleSize	0x06
+#define DAQDS_wChannels		0x08
+#define DAQDS_wSampleRate	0x0A
+#define DAQDS_wIntMsg		0x0C
+#define DAQDS_wFlags		0x0E
+#define DAQDS__size		0x10
+
+typedef u8			BYTE;
+typedef u16			USHORT;
+typedef u16			WORD;
+typedef u32			DWORD;
+typedef unsigned long		LPDAQD;
+
+/* Generic FIFO * /
+typedef struct {
+	size_t n, len;
+	char *data;
+	int head, tail;
+} msnd_fifo;  */
+
+
+
+typedef struct multisound_dev {
+	void*			mappedbase;
+	int			play_period_bytes;
+	int			playLimit;
+	int			playPeriods;
+	int 			playDMAPos;
+	int 			captureDMAPos;
+	int			capturePeriodBytes;
+	int			captureLimit;
+	int			capturePeriods;
+	snd_pcm_substream_t*	captureSubstream;
+	snd_card_t*		card;
+	snd_pcm_t*		pcm;
+	void*			msndmidi_mpu;
+
+	/* Linux device info */
+	char*			name;
+
+	/* Hardware resources */
+	int io, numio;
+	int memid, irqid;
+	int irq, irq_ref;
+	unsigned char info;
+	unsigned long base;
+
+	/* Motorola 56k DSP SMA */
+	unsigned long SMA;
+	unsigned long DAPQ, DARQ, MODQ, MIDQ, DSPQ;
+	unsigned long pwDSPQData, pwMIDQData, pwMODQData;
+	int dspq_data_buff, dspq_buff_size;
+
+	/* State variables */
+	enum { msndClassic, msndPinnacle } type;
+	mode_t mode;
+	unsigned long flags;
+#define F_RESETTING			0
+#define F_HAVEDIGITAL			1
+#define F_AUDIO_WRITE_INUSE		2
+#define F_WRITING			3
+#define F_WRITEBLOCK			4
+#define F_WRITEFLUSH			5
+#define F_AUDIO_READ_INUSE		6
+#define F_READING			7
+#define F_READBLOCK			8
+#define F_EXT_MIDI_INUSE		9
+#define F_HDR_MIDI_INUSE		10
+#define F_DISABLE_WRITE_NDELAY		11
+	spinlock_t lock;
+	int nresets;
+	unsigned recsrc;
+#define LEVEL_ENTRIES 32
+	int left_levels[ LEVEL_ENTRIES];
+	int right_levels[ LEVEL_ENTRIES];
+	int mixer_mod_count;
+	int calibrate_signal;
+	int play_sample_size, play_sample_rate, play_channels;
+	int play_ndelay;
+	int capture_sample_size, capture_sample_rate, capture_channels;
+	int capture_ndelay;
+	BYTE bCurrentMidiPatch;
+
+	int last_playbank, last_recbank;
+
+} multisound_dev_t;
+
+#ifndef mdelay
+#  define mdelay(a)	udelay((a) * 1000)
+#endif
+
+int			snd_msnd_register(multisound_dev_t *dev);
+void			snd_msnd_unregister(multisound_dev_t *dev);
+int			snd_msnd_get_num_devs(void);
+multisound_dev_t *	snd_msnd_get_dev(int i);
+
+void			snd_msnd_init_queue(unsigned long, int start, int size);
+
+int			snd_msnd_wait_TXDE(multisound_dev_t *dev);
+int			snd_msnd_wait_HC0(multisound_dev_t *dev);
+int			snd_msnd_send_dsp_cmd(multisound_dev_t *dev, BYTE cmd);
+int			snd_msnd_send_word(multisound_dev_t *dev, unsigned char high,
+				       unsigned char mid, unsigned char low);
+int			snd_msnd_upload_host(multisound_dev_t *dev, char *bin, int len);
+int			snd_msnd_enable_irq(multisound_dev_t *dev);
+int			snd_msnd_disable_irq(multisound_dev_t *dev);
+
+
+int snd_msndmidi_new(snd_card_t * card, int device, multisound_dev_t *dev);
+void snd_msndmidi_input_read( void * mpu);
+
+#endif /* __MSND_H */
--- /dev/null	2002-06-21 03:44:19.000000000 +0200
+++ linux/sound/isa/msnd/msnd_classic.c	2002-07-08 12:14:26.000000000 +0200
@@ -0,0 +1,3 @@
+/* The work is in msnd_pinnacle.c, just define MSND_CLASSIC before it. */
+#define MSND_CLASSIC
+#include "msnd_pinnacle.c"
--- /dev/null	2002-06-21 03:44:19.000000000 +0200
+++ linux/sound/isa/msnd/msnd_classic.h	2002-07-08 12:14:26.000000000 +0200
@@ -0,0 +1,188 @@
+/*********************************************************************
+ *
+ * msnd_classic.h
+ *
+ * Turtle Beach MultiSound Sound Card Driver for Linux
+ *
+ * Some parts of this header file were derived from the Turtle Beach
+ * MultiSound Driver Development Kit.
+ *
+ * Copyright (C) 1998 Andrew Veliath
+ * Copyright (C) 1993 Turtle Beach Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ * 
+ * $Id: msnd_classic.h,v 1.10 1999/03/21 17:36:09 andrewtv Exp $
+ *
+ ********************************************************************/
+#ifndef __MSND_CLASSIC_H
+#define __MSND_CLASSIC_H
+
+#include <linux/config.h>
+
+#define DSP_NUMIO				0x10
+
+#define	HP_MEMM					0x08
+
+#define	HP_BITM					0x0E
+#define	HP_WAIT					0x0D
+#define	HP_DSPR					0x0A
+#define	HP_PROR					0x0B
+#define	HP_BLKS					0x0C
+
+#define	HPPRORESET_OFF				0
+#define HPPRORESET_ON				1
+
+#define HPDSPRESET_OFF				0
+#define HPDSPRESET_ON				1
+
+#define HPBLKSEL_0				0
+#define HPBLKSEL_1				1
+
+#define HPWAITSTATE_0				0
+#define HPWAITSTATE_1				1
+
+#define HPBITMODE_16				0
+#define HPBITMODE_8				1
+
+#define	HIDSP_INT_PLAY_UNDER			0x00
+#define	HIDSP_INT_RECORD_OVER			0x01
+#define	HIDSP_INPUT_CLIPPING			0x02
+#define	HIDSP_MIDI_IN_OVER			0x10
+#define	HIDSP_MIDI_OVERRUN_ERR  0x13
+
+#define	HDEXAR_CLEAR_PEAKS			1
+#define	HDEXAR_IN_SET_POTS			2
+#define	HDEXAR_AUX_SET_POTS			3
+#define	HDEXAR_CAL_A_TO_D			4
+#define	HDEXAR_RD_EXT_DSP_BITS			5
+
+#define TIME_PRO_RESET_DONE			0x028A
+#define TIME_PRO_SYSEX				0x0040
+#define TIME_PRO_RESET				0x0032
+
+#define AGND					0x01
+#define SIGNAL					0x02
+
+#define EXT_DSP_BIT_DCAL			0x0001
+#define EXT_DSP_BIT_MIDI_CON			0x0002
+
+#define BUFFSIZE				0x8000
+#define HOSTQ_SIZE				0x40
+
+#define SRAM_CNTL_START				0x7F00
+#define SMA_STRUCT_START			0x7F40
+
+#define DAP_BUFF_SIZE				0x2400
+#define DAR_BUFF_SIZE				0x2000
+
+#define DAPQ_STRUCT_SIZE			0x10
+#define DARQ_STRUCT_SIZE			0x10
+#define DAPQ_BUFF_SIZE				(3 * 0x10)
+#define DARQ_BUFF_SIZE				(3 * 0x10)
+#define MODQ_BUFF_SIZE				0x400
+#define MIDQ_BUFF_SIZE				0x200
+#define DSPQ_BUFF_SIZE				0x40
+
+#define DAPQ_DATA_BUFF				0x6C00
+#define DARQ_DATA_BUFF				0x6C30
+#define MODQ_DATA_BUFF				0x6C60
+#define MIDQ_DATA_BUFF				0x7060
+#define DSPQ_DATA_BUFF				0x7260
+
+#define DAPQ_OFFSET				SRAM_CNTL_START
+#define DARQ_OFFSET				(SRAM_CNTL_START + 0x08)
+#define MODQ_OFFSET				(SRAM_CNTL_START + 0x10)
+#define MIDQ_OFFSET				(SRAM_CNTL_START + 0x18)
+#define DSPQ_OFFSET				(SRAM_CNTL_START + 0x20)
+
+#define MOP_SYNTH				0x10
+#define MOP_EXTOUT				0x32
+#define MOP_EXTTHRU				0x02
+#define MOP_OUTMASK				0x01
+
+#define MIP_EXTIN				0x01
+#define MIP_SYNTH				0x00
+#define MIP_INMASK				0x32
+
+/* Classic SMA Common Data */
+#define SMA_wCurrPlayBytes			0x0000
+#define SMA_wCurrRecordBytes			0x0002
+#define SMA_wCurrPlayVolLeft			0x0004
+#define SMA_wCurrPlayVolRight			0x0006
+#define SMA_wCurrInVolLeft			0x0008
+#define SMA_wCurrInVolRight			0x000a
+#define SMA_wUser_3				0x000c
+#define SMA_wUser_4				0x000e
+#define SMA_dwUser_5				0x0010
+#define SMA_dwUser_6				0x0014
+#define SMA_wUser_7				0x0018
+#define SMA_wReserved_A				0x001a
+#define SMA_wReserved_B				0x001c
+#define SMA_wReserved_C				0x001e
+#define SMA_wReserved_D				0x0020
+#define SMA_wReserved_E				0x0022
+#define SMA_wReserved_F				0x0024
+#define SMA_wReserved_G				0x0026
+#define SMA_wReserved_H				0x0028
+#define SMA_wCurrDSPStatusFlags			0x002a
+#define SMA_wCurrHostStatusFlags		0x002c
+#define SMA_wCurrInputTagBits			0x002e
+#define SMA_wCurrLeftPeak			0x0030
+#define SMA_wCurrRightPeak			0x0032
+#define SMA_wExtDSPbits				0x0034
+#define SMA_bExtHostbits			0x0036
+#define SMA_bBoardLevel				0x0037
+#define SMA_bInPotPosRight			0x0038
+#define SMA_bInPotPosLeft			0x0039
+#define SMA_bAuxPotPosRight			0x003a
+#define SMA_bAuxPotPosLeft			0x003b
+#define SMA_wCurrMastVolLeft			0x003c
+#define SMA_wCurrMastVolRight			0x003e
+#define SMA_bUser_12				0x0040
+#define SMA_bUser_13				0x0041
+#define SMA_wUser_14				0x0042
+#define SMA_wUser_15				0x0044
+#define SMA_wCalFreqAtoD			0x0046
+#define SMA_wUser_16				0x0048
+#define SMA_wUser_17				0x004a
+#define SMA__size				0x004c
+
+#ifdef HAVE_DSPCODEH
+#  include "msndperm.c"
+#  include "msndinit.c"
+#  define PERMCODE		msndperm
+#  define INITCODE		msndinit
+#  define PERMCODESIZE		sizeof(msndperm)
+#  define INITCODESIZE		sizeof(msndinit)
+#else
+#  ifndef CONFIG_MSNDCLAS_INIT_FILE
+#    define CONFIG_MSNDCLAS_INIT_FILE				\
+				"/etc/sound/msndinit.bin"
+#  endif
+#  ifndef CONFIG_MSNDCLAS_PERM_FILE
+#    define CONFIG_MSNDCLAS_PERM_FILE				\
+				"/etc/sound/msndperm.bin"
+#  endif
+#  define PERMCODEFILE		CONFIG_MSNDCLAS_PERM_FILE
+#  define INITCODEFILE		CONFIG_MSNDCLAS_INIT_FILE
+#  define PERMCODE		dspini
+#  define INITCODE		permini
+#  define PERMCODESIZE		sizeof_dspini
+#  define INITCODESIZE		sizeof_permini
+#endif
+#define LONGNAME		"MultiSound (Classic/Monterey/Tahiti)"
+
+#endif /* __MSND_CLASSIC_H */
--- /dev/null	2002-06-21 03:44:19.000000000 +0200
+++ linux/sound/isa/msnd/msnd_midi.c	2002-07-08 12:14:26.000000000 +0200
@@ -0,0 +1,500 @@
+/*
+ *  Copyright (c) by Jaroslav Kysela <perex@suse.cz>
+ *  Routines for control of MPU-401 in UART mode
+ *
+ *  MPU-401 supports UART mode which is not capable generate transmit
+ *  interrupts thus output is done via polling. Also, if irq < 0, then
+ *  input is done also via polling. Do not expect good performance.
+ *
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation; either version 2 of the License, or
+ *   (at your option) any later version.
+ *
+ *   This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *   GNU General Public License for more details.
+ *
+ *   You should have received a copy of the GNU General Public License
+ *   along with this program; if not, write to the Free Software
+ *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ */
+
+#include <sound/driver.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <sound/core.h>
+#include <sound/rawmidi.h>
+
+#include "msnd.h"
+#ifdef MSND_CLASSIC
+#  ifdef CONFIG_MSNDCLAS_HAVE_BOOT
+#    define HAVE_DSPCODEH
+#  endif
+#  include "msnd_classic.h"
+#  define LOGNAME			"msnd_classic"
+#else
+#  ifdef CONFIG_MSNDPIN_HAVE_BOOT
+#    define HAVE_DSPCODEH
+#  endif
+#  include "msnd_pinnacle.h"
+#  define LOGNAME			"snd_msnd_pinnacle"
+#endif
+
+
+#define MSNDMIDI_MODE_BIT_INPUT		0
+#define MSNDMIDI_MODE_BIT_OUTPUT		1
+#define MSNDMIDI_MODE_BIT_INPUT_TRIGGER	2
+#define MSNDMIDI_MODE_BIT_OUTPUT_TRIGGER	3
+#define MSNDMIDI_MODE_BIT_RX_LOOP		4
+#define MSNDMIDI_MODE_BIT_TX_LOOP		5
+
+#define MSNDMIDI_MODE_INPUT		(1<<MSNDMIDI_MODE_BIT_INPUT)
+#define MSNDMIDI_MODE_OUTPUT		(1<<MSNDMIDI_MODE_BIT_OUTPUT)
+#define MSNDMIDI_MODE_INPUT_TRIGGER	(1<<MSNDMIDI_MODE_BIT_INPUT_TRIGGER)
+#define MSNDMIDI_MODE_OUTPUT_TRIGGER	(1<<MSNDMIDI_MODE_BIT_OUTPUT_TRIGGER)
+
+#define MSNDMIDI_MODE_INPUT_TIMER		(1<<0)
+#define MSNDMIDI_MODE_OUTPUT_TIMER	(1<<1)
+
+
+#ifdef SND_MSNDMIDI_OUTPUT
+static void snd_msndmidi_output_write(msndmidi_t * mpu);
+#endif
+/*
+
+ */
+
+#define snd_msndmidi_input_avail(mpu)	(!(inb(MPU401C(mpu)) & 0x80))
+#define snd_msndmidi_output_ready(mpu)	(!(inb(MPU401C(mpu)) & 0x40))
+
+#define MPU401_RESET		0xff
+#define MPU401_ENTER_UART	0x3f
+#define MPU401_ACK		0xfe
+
+
+typedef struct _snd_msndmidi msndmidi_t;
+
+struct _snd_msndmidi {
+	snd_rawmidi_t *rmidi;
+	multisound_dev_t *dev;
+
+	unsigned long mode;		/* MSNDMIDI_MODE_XXXX */
+	int timer_invoked;
+
+	void *private_data;
+
+	snd_rawmidi_substream_t *substream_input;
+	snd_rawmidi_substream_t *substream_output;
+
+	spinlock_t input_lock;
+	spinlock_t output_lock;
+	spinlock_t timer_lock;
+
+	struct timer_list timer;
+};
+
+
+/* not used static void snd_msnd_midi_clear_rx(msndmidi_t *mpu)
+{/ *	int timeout = 100000;
+	for (; timeout > 0 && snd_msndmidi_input_avail(mpu); timeout--)
+		inb(MPU401D(mpu));
+#ifdef CONFIG_SND_DEBUG
+	if (timeout <= 0)
+		snd_printk("cmd: clear rx timeout (status = 0x%x)\n", inb(MPU401C(mpu)));
+#endif
+* /
+}           */
+
+/*
+static void _snd_msndmidi_interrupt(msndmidi_t *mpu)
+{
+	if (test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))
+		snd_msndmidi_input_read(mpu);
+	else
+		snd_msndmidi_clear_rx(mpu);
+	/ * ok. for better Tx performance try do some output when input is done * /
+	if (test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode))
+		snd_msndmidi_output_write(mpu);
+}
+
+void snd_msndmidi_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	msndmidi_t *mpu = snd_magic_cast(msndmidi_t, dev_id, return);
+	
+	if (mpu == NULL)
+		return;
+	_snd_msndmidi_interrupt(mpu);
+}*/
+/*
+static void snd_msndmidi_timer(unsigned long data)
+{
+	unsigned long flags;
+	msndmidi_t *mpu = snd_magic_cast(msndmidi_t, (void *)data, return);
+
+	spin_lock_irqsave(&mpu->timer_lock, flags);
+	/ * mpu->mode |= MPU401_MODE_TIMER;* /
+	mpu->timer.expires = 1 + jiffies;
+	add_timer(&mpu->timer);
+	spin_unlock_irqrestore(&mpu->timer_lock, flags);
+	if (mpu->rmidi)
+		_snd_msndmidi_interrupt(mpu);
+}
+
+static void snd_msndmidi_add_timer (msndmidi_t *mpu, int input)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave (&mpu->timer_lock, flags);
+	if (mpu->timer_invoked == 0) {
+		mpu->timer.data = (unsigned long)mpu;
+		mpu->timer.function = snd_msndmidi_timer;
+		mpu->timer.expires = 1 + jiffies;
+		add_timer(&mpu->timer);
+	}
+	mpu->timer_invoked |= input ? MPU401_MODE_INPUT_TIMER : MPU401_MODE_OUTPUT_TIMER;
+	spin_unlock_irqrestore (&mpu->timer_lock, flags);
+}
+
+static void snd_msndmidi_remove_timer (msndmidi_t *mpu, int input)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave (&mpu->timer_lock, flags);
+	if (mpu->timer_invoked) {
+		mpu->timer_invoked &= input ? ~MPU401_MODE_INPUT_TIMER : ~MPU401_MODE_OUTPUT_TIMER;
+		if (! mpu->timer_invoked)
+			del_timer(&mpu->timer);
+	}
+	spin_unlock_irqrestore (&mpu->timer_lock, flags);
+} */
+
+/*
+
+ */
+
+/* not used so far .... ?
+static void snd_msndmidi_cmd(msndmidi_t * mpu, unsigned char cmd, int ack)
+{
+	unsigned long flags;
+	int timeout, ok;
+
+	spin_lock_irqsave(&mpu->input_lock, flags);
+/ *	if (mpu->hardware != MPU401_HW_TRID4DWAVE) {
+		outb(0x00, MPU401D(mpu));
+		/ *snd_msndmidi_clear_rx(mpu);* /
+	}
+	/ * ok. standard MPU-401 initialization * /
+	if (mpu->hardware != MPU401_HW_SB) {
+		for (timeout = 1000; timeout > 0 && !snd_msndmidi_output_ready(mpu); timeout--)
+			udelay(10);
+#ifdef CONFIG_SND_DEBUG
+		if (!timeout)
+			snd_printk("cmd: tx timeout (status = 0x%x)\n", inb(MPU401C(mpu)));
+#endif
+	}
+	outb(cmd, MPU401C(mpu));
+	if (ack) {
+		ok = 0;
+		timeout = 10000;
+		while (!ok && timeout-- > 0) {
+			if (snd_msndmidi_input_avail(mpu)) {
+				if (inb(MPU401D(mpu)) == MPU401_ACK)
+					ok = 1;
+			}
+		}
+		if (!ok && inb(MPU401D(mpu)) == MPU401_ACK)
+			ok = 1;
+	} else {
+		ok = 1;
+	}* /
+	spin_unlock_irqrestore(&mpu->input_lock, flags);
+//	if (! ok)
+//		snd_printk("cmd: 0x%x failed at 0x%lx (status = 0x%x, data = 0x%x)\n", cmd, mpu->port, inb(MPU401C(mpu)), inb(MPU401D(mpu)));
+	// snd_printk("cmd: 0x%x at 0x%lx (status = 0x%x, data = 0x%x)\n", cmd, mpu->port, inb(MPU401C(mpu)), inb(MPU401D(mpu)));
+}          */
+
+/*
+ * input/output open/close - protected by open_mutex in rawmidi.c
+ */
+static int snd_msndmidi_input_open(snd_rawmidi_substream_t * substream)
+{
+	msndmidi_t *mpu;
+//	int err;
+#ifdef CONFIG_SND_DEBUG0
+	printk( "snd_msndmidi_input_open(snd_rawmidi_substream_t * substream)\n");
+#endif
+
+	mpu = snd_magic_cast(msndmidi_t, substream->rmidi->private_data, return -ENXIO);
+/*	if (mpu->open_input && (err = mpu->open_input(mpu)) < 0)
+		return err;
+	if (! test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode)) {
+		snd_msndmidi_cmd(mpu, MPU401_RESET, 1);
+		snd_msndmidi_cmd(mpu, MPU401_ENTER_UART, 1);
+	}*/
+
+	mpu->substream_input = substream;
+
+	//  SetMidiInPort( EXTIN_MIP);
+	snd_msnd_enable_irq( mpu->dev);
+
+	snd_msnd_send_dsp_cmd( mpu->dev, HDEX_MIDI_IN_START);
+	set_bit(MSNDMIDI_MODE_BIT_INPUT, &mpu->mode);
+	return 0;
+}
+
+#ifdef SND_MSNDMIDI_OUTPUT
+static int snd_msndmidi_output_open(snd_rawmidi_substream_t * substream)
+{
+	msndmidi_t *mpu;
+	int err;
+
+	mpu = snd_magic_cast(msndmidi_t, substream->rmidi->private_data, return -ENXIO);
+/*	if (mpu->open_output && (err = mpu->open_output(mpu)) < 0)
+		return err;
+	if (! test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode)) {
+		snd_msndmidi_cmd(mpu, MPU401_RESET, 1);
+		snd_msndmidi_cmd(mpu, MPU401_ENTER_UART, 1);
+	}*/
+	mpu->substream_output = substream;
+	set_bit(MSNDMIDI_MODE_BIT_OUTPUT, &mpu->mode);
+	return 0;
+}
+#endif
+
+static int snd_msndmidi_input_close(snd_rawmidi_substream_t * substream)
+{
+	msndmidi_t *mpu;
+
+#ifdef CONFIG_SND_DEBUG0
+	printk( "snd_msndmidi_input_close(snd_rawmidi_substream_t * substream)\n");
+#endif
+
+	mpu = snd_magic_cast(msndmidi_t, substream->rmidi->private_data, return -ENXIO);
+	snd_msnd_send_dsp_cmd( mpu->dev, HDEX_MIDI_IN_STOP);
+	clear_bit(MSNDMIDI_MODE_BIT_INPUT, &mpu->mode);
+	mpu->substream_input = NULL;
+	snd_msnd_disable_irq( mpu->dev);
+/*	if (! test_bit(MPU401_MODE_BIT_OUTPUT, &mpu->mode))
+		snd_msndmidi_cmd(mpu, MPU401_RESET, 0);
+	if (mpu->close_input)
+		mpu->close_input(mpu);*/
+	return 0;
+}
+
+#ifdef SND_MSNDMIDI_OUTPUT
+static int snd_msndmidi_output_close(snd_rawmidi_substream_t * substream)
+{
+	msndmidi_t *mpu;
+
+	mpu = snd_magic_cast(msndmidi_t, substream->rmidi->private_data, return -ENXIO);
+	clear_bit(MSNDMIDI_MODE_BIT_OUTPUT, &mpu->mode);
+	mpu->substream_output = NULL;
+/*	if (! test_bit(MPU401_MODE_BIT_INPUT, &mpu->mode))
+		snd_msndmidi_cmd(mpu, MPU401_RESET, 0);
+	if (mpu->close_output)
+		mpu->close_output(mpu);*/
+	return 0;
+}
+#endif
+
+/*
+ * trigger input
+ */
+static void snd_msndmidi_input_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	msndmidi_t *mpu;
+//	int max = 64;
+#ifdef CONFIG_SND_DEBUG0
+	printk( "snd_msndmidi_input_trigger(, %i)\n", up);
+#endif
+
+	mpu = snd_magic_cast(msndmidi_t, substream->rmidi->private_data, return);
+	spin_lock_irqsave(&mpu->input_lock, flags);
+	if (up) {
+		if (! test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER, &mpu->mode))
+			snd_msndmidi_input_read(mpu);
+		set_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER, &mpu->mode);
+	} else {
+		clear_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER, &mpu->mode);
+	}
+	spin_unlock_irqrestore(&mpu->input_lock, flags);
+	if (up)
+		snd_msndmidi_input_read(mpu);
+}
+
+void snd_msndmidi_input_read( void* mpuv)
+{
+//unsigned char byte;
+msndmidi_t * mpu = mpuv;
+
+	/* prevent double enter via event callback */
+	if (test_and_set_bit(MSNDMIDI_MODE_BIT_RX_LOOP, &mpu->mode))
+		return;
+	spin_lock(&mpu->input_lock);
+	while (isa_readw( mpu->dev->MIDQ + JQS_wTail) != isa_readw( mpu->dev->MIDQ + JQS_wHead)) {
+	WORD wTmp, val;
+		val = isa_readw( mpu->dev->pwMIDQData + 2*isa_readw( mpu->dev->MIDQ + JQS_wHead));
+
+			if (test_bit( MSNDMIDI_MODE_BIT_INPUT_TRIGGER, &mpu->mode)) {
+				spin_unlock(&mpu->input_lock);
+//		printk( "MID: 0x%04X\n", (unsigned)val);
+				snd_rawmidi_receive(mpu->substream_input, (unsigned char*)&val, 1);
+				spin_lock(&mpu->input_lock);
+			}
+
+		if ((wTmp = isa_readw( mpu->dev->MIDQ + JQS_wHead) + 1) > isa_readw( mpu->dev->MIDQ + JQS_wSize))
+			isa_writew(0,  mpu->dev->MIDQ + JQS_wHead);
+		else
+			isa_writew(wTmp,  mpu->dev->MIDQ + JQS_wHead);
+	}
+	spin_unlock(&mpu->input_lock);
+	clear_bit(MSNDMIDI_MODE_BIT_RX_LOOP, &mpu->mode);
+}
+
+/*
+ *  Tx FIFO sizes:
+ *    CS4237B			- 16 bytes
+ *    AudioDrive ES1688         - 12 bytes
+ *    S3 SonicVibes             -  8 bytes
+ *    SoundBlaster AWE 64       -  2 bytes (ugly hardware)
+ */
+#ifdef SND_MSNDMIDI_OUTPUT
+static void snd_msndmidi_output_write(msndmidi_t * mpu)
+{
+	unsigned char byte;
+	int max = 256, timeout;
+
+	if (!test_bit(MSNDMIDI_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode))
+		return;
+	/* prevent double enter */
+	if (test_and_set_bit(MSNDMIDI_MODE_BIT_TX_LOOP, &mpu->mode))
+		return;
+	do {
+		spin_lock(&mpu->output_lock);
+		if (snd_rawmidi_transmit_peek(mpu->substream_output, &byte, 1) == 1) {
+			for (timeout = 100; timeout > 0; timeout--) {
+				if (snd_msndmidi_output_ready(mpu)) {
+//					outb(byte, MPU401D(mpu));
+					snd_rawmidi_transmit_ack(mpu->substream_output, 1);
+					break;
+				}
+			}
+		} else {
+			snd_msndmidi_remove_timer (mpu, 0);
+			max = 1; /* no other data - leave the tx loop */
+		}
+		spin_unlock(&mpu->output_lock);
+	} while (--max > 0);
+	clear_bit(MSNDMIDI_MODE_BIT_TX_LOOP, &mpu->mode);
+}
+
+static void snd_msndmidi_output_trigger(snd_rawmidi_substream_t * substream, int up)
+{
+	unsigned long flags;
+	msndmidi_t *mpu;
+
+	mpu = snd_magic_cast(msndmidi_t, substream->rmidi->private_data, return);
+	spin_lock_irqsave(&mpu->output_lock, flags);
+	if (up) {
+		set_bit(MSNDMIDI_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode);
+		snd_msndmidi_add_timer(mpu, 0);
+	} else {
+		snd_msndmidi_remove_timer(mpu, 0);
+		clear_bit(MSNDMIDI_MODE_BIT_OUTPUT_TRIGGER, &mpu->mode);
+	}
+	spin_unlock_irqrestore(&mpu->output_lock, flags);
+	if (up)
+		snd_msndmidi_output_write(mpu);
+}
+
+/*
+
+ */
+
+static snd_rawmidi_ops_t snd_msndmidi_output =
+{
+	open:		snd_msndmidi_output_open,
+	close:		snd_msndmidi_output_close,
+	trigger:	snd_msndmidi_output_trigger,
+};
+#endif
+
+static snd_rawmidi_ops_t snd_msndmidi_input =
+{
+	open:		snd_msndmidi_input_open,
+	close:		snd_msndmidi_input_close,
+	trigger:	snd_msndmidi_input_trigger,
+};
+
+static void snd_msndmidi_free(snd_rawmidi_t *rmidi)
+{
+	msndmidi_t *mpu = snd_magic_cast(msndmidi_t, rmidi->private_data, return);
+/*	if (mpu->irq_flags && mpu->irq >= 0)
+		free_irq(mpu->irq, (void *) mpu);
+	if (mpu->res) {
+		release_resource(mpu->res);
+		kfree_nocheck(mpu->res);
+	}*/
+	snd_magic_kfree(mpu);
+}
+
+int snd_msndmidi_new(snd_card_t * card, int device, multisound_dev_t *dev)
+{
+	msndmidi_t *mpu;
+	snd_rawmidi_t *rmidi;
+	int err;
+
+	if ((err = snd_rawmidi_new(card, "MSND-MIDI", device, 1, 1, &rmidi)) < 0)
+		return err;
+	mpu = snd_magic_kcalloc(msndmidi_t, 0, GFP_KERNEL);
+	if (mpu == NULL) {
+		snd_device_free(card, rmidi);
+		return -ENOMEM;
+	}
+	mpu->dev = dev;
+	dev->msndmidi_mpu = mpu;
+	rmidi->private_data = mpu;
+	rmidi->private_free = snd_msndmidi_free;
+	spin_lock_init(&mpu->input_lock);
+	spin_lock_init(&mpu->output_lock);
+	spin_lock_init(&mpu->timer_lock);
+/*	if (!integrated) {
+		if ((mpu->res = request_region(port, 2, "MPU401 UART")) == NULL) {
+			snd_device_free(card, rmidi);
+			return -EBUSY;
+		}
+	}
+	mpu->port = port;
+	if (irq >= 0 && irq_flags) {
+		if (request_irq(irq, snd_msndmidi_interrupt, irq_flags, "MPU401 UART", (void *) mpu)) {
+			snd_printk("unable to grab IRQ %d\n", irq);
+			snd_device_free(card, rmidi);
+			return -EBUSY;
+		}
+		mpu->irq = irq;
+		mpu->irq_flags = irq_flags;
+	}*/
+	strcpy(rmidi->name, "MSND MIDI");
+#ifdef SND_MSNDMIDI_OUTPUT
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_OUTPUT, &snd_msndmidi_output);
+#endif
+	snd_rawmidi_set_ops(rmidi, SNDRV_RAWMIDI_STREAM_INPUT, &snd_msndmidi_input);
+	rmidi->info_flags |=
+#ifdef SND_MSNDMIDI_OUTPUT
+				SNDRV_RAWMIDI_INFO_OUTPUT |
+	                     SNDRV_RAWMIDI_INFO_DUPLEX |
+#endif
+	                     SNDRV_RAWMIDI_INFO_INPUT ;
+	mpu->rmidi = rmidi;
+	return 0;
+}
--- /dev/null	2002-06-21 03:44:19.000000000 +0200
+++ linux/sound/isa/msnd/msnd_pinnacle.c	2002-07-22 15:44:58.000000000 +0200
@@ -0,0 +1,1834 @@
+/*********************************************************************
+ *
+ * Linux multisound pinnacle/fiji driver for alsa 0.9rc2CVS
+ *
+ * 2002/06/30 Karsten Wiese:
+ *	for now this is only used to build a pinnacle / fiji driver.
+ *	the OSS parent of this code is designed to also support the multisound classic
+ *	via the file msnd_classic.c.
+ *	to make it easier for some brave heart to implemt classic support in alsa, i left
+ *	all the MSND_CLASSIC tokens in this file. but for now this untested & undone.
+ *
+ *
+ * ripped from linux kernel 2.4.18 by Karsten Wiese.
+ *
+ * the following is a copy of the 2.4.18 OSS FREE file-heading comment:
+ *
+ * Turtle Beach MultiSound Sound Card Driver for Linux
+ * msnd_pinnacle.c / msnd_classic.c
+ *
+ * -- If MSND_CLASSIC is defined:
+ *
+ *     -> driver for Turtle Beach Classic/Monterey/Tahiti
+ *
+ * -- Else
+ *
+ *     -> driver for Turtle Beach Pinnacle/Fiji
+ *
+ * Copyright (C) 1998 Andrew Veliath
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * $Id: msnd_pinnacle.c,v 1.8 2000/12/30 00:33:21 sycamore Exp $
+ *
+ * 12-3-2000  Modified IO port validation  Steve Sycamore
+ *
+ *
+ * $$$: msnd_pinnacle.c,v 1.75 1999/03/21 16:50:09 andrewtv $$$ $
+ *
+ ********************************************************************/
+
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/initval.h>
+#include <sound/asound.h>
+#include <sound/pcm.h>
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/smp_lock.h>
+#include <linux/vmalloc.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+
+#ifdef MSND_CLASSIC
+# ifndef __alpha__
+#  define SLOWIO
+# endif
+#endif
+#include "msnd.h"
+#ifdef MSND_CLASSIC
+#  ifdef CONFIG_MSNDCLAS_HAVE_BOOT
+#    define HAVE_DSPCODEH
+#  endif
+#  include "msnd_classic.h"
+#  define LOGNAME			"msnd_classic"
+#else
+#  ifdef CONFIG_MSNDPIN_HAVE_BOOT
+#    define HAVE_DSPCODEH
+#  endif
+#  include "msnd_pinnacle.h"
+#  define LOGNAME			"snd_msnd_pinnacle"
+#endif
+
+extern int mod_firmware_load(const char *fn, char **fp);
+
+
+#define chip_t snd_msndpinnacle_pcm_t
+
+typedef struct snd_msndpinnacle_pcm {
+	snd_card_t*		card;
+	spinlock_t lock;
+	struct timer_list timer;
+	unsigned int pcm_size;
+	unsigned int pcm_count;
+	unsigned int pcm_periods;
+	unsigned int pcm_bps;		/* bytes per second */
+	unsigned int pcm_jiffie;	/* bytes per one jiffie */
+	unsigned int pcm_irq_pos;	/* IRQ position */
+	unsigned int pcm_buf_pos;	/* position in buffer */
+	snd_pcm_substream_t *substream;
+} snd_msndpinnacle_pcm_t;
+
+
+static int snd_index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
+static char *snd_id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
+
+MODULE_PARM(snd_index, "1-" __MODULE_STRING(SNDRV_CARDS) "i");
+MODULE_PARM_DESC(snd_index, "Index value for msnd_pinnacle soundcard.");
+MODULE_PARM_SYNTAX(snd_index, SNDRV_INDEX_DESC);
+MODULE_PARM(snd_id, "1-" __MODULE_STRING(SNDRV_CARDS) "s");
+MODULE_PARM_DESC(snd_id, "ID string for msnd_pinnacle soundcard.");
+MODULE_PARM_SYNTAX(snd_id, SNDRV_ID_DESC);
+
+#ifndef CONFIG_MSND_WRITE_NDELAY
+#  define CONFIG_MSND_WRITE_NDELAY	1
+#endif
+
+#define get_play_delay_jiffies(size)	((size) * HZ *			\
+					 dev.play_sample_size / 8 /	\
+					 dev.play_sample_rate /		\
+					 dev.play_channels)
+
+#define get_rec_delay_jiffies(size)	((size) * HZ *			\
+					 dev.rec_sample_size / 8 /	\
+					 dev.rec_sample_rate /		\
+					 dev.rec_channels)
+
+static multisound_dev_t			dev;
+
+snd_msndpinnacle_pcm_t*			Dpcm;
+
+
+#ifndef HAVE_DSPCODEH
+static char				*dspini, *permini;
+static int				sizeof_dspini, sizeof_permini;
+#endif
+
+static int				snd_msnd_dsp_full_reset(void);
+static void				dsp_write_flush(void);
+
+
+int snd_msnd_send_dsp_cmd_chk(multisound_dev_t *dev, register BYTE cmd)
+{
+	if (snd_msnd_send_dsp_cmd(dev, cmd) == 0)
+		return 0;
+	snd_msnd_dsp_full_reset();
+	return snd_msnd_send_dsp_cmd(dev, cmd);
+}
+
+static void snd_msnd_play_reset_queue( snd_msndpinnacle_pcm_t* dpcm)
+{
+	int	n;
+	LPDAQD	lpDAQ;
+
+	dev.last_playbank = -1;
+	dev.playLimit = dpcm->pcm_count * ( dpcm->pcm_periods - 1);
+	dev.playPeriods = dpcm->pcm_periods;
+	isa_writew(PCTODSP_OFFSET(0 * DAQDS__size), dev.DAPQ + JQS_wHead);
+	isa_writew(PCTODSP_OFFSET(0 * DAQDS__size), dev.DAPQ + JQS_wTail);
+
+	dev.play_period_bytes = dpcm->pcm_count;
+
+	for (n = 0, lpDAQ = dev.base + DAPQ_DATA_BUFF; n < 3; ++n, lpDAQ += DAQDS__size) {
+		isa_writew(PCTODSP_BASED((DWORD)( dpcm->pcm_count * (n % dpcm->pcm_periods))), lpDAQ + DAQDS_wStart);
+		isa_writew(0, lpDAQ + DAQDS_wSize);
+		isa_writew(1, lpDAQ + DAQDS_wFormat);
+		isa_writew(dev.play_sample_size, lpDAQ + DAQDS_wSampleSize);
+		isa_writew(dev.play_channels, lpDAQ + DAQDS_wChannels);
+		isa_writew(dev.play_sample_rate, lpDAQ + DAQDS_wSampleRate);
+		isa_writew(HIMT_PLAY_DONE * 0x100 + n, lpDAQ + DAQDS_wIntMsg);
+		isa_writew(n, lpDAQ + DAQDS_wFlags);
+	}
+}
+
+static void snd_msnd_capture_reset_queue( snd_msndpinnacle_pcm_t* dpcm)
+{
+	int		n;
+	LPDAQD		lpDAQ;
+	//unsigned long	flags;
+
+//	snd_msnd_init_queue(dev.DARQ, DARQ_DATA_BUFF, DARQ_BUFF_SIZE);
+
+	dev.last_recbank = 2;
+	dev.captureLimit = dpcm->pcm_count * ( dpcm->pcm_periods - 1);
+	dev.capturePeriods = dpcm->pcm_periods;
+	isa_writew(PCTODSP_OFFSET(0 * DAQDS__size), dev.DARQ + JQS_wHead);
+	isa_writew(PCTODSP_OFFSET(dev.last_recbank * DAQDS__size), dev.DARQ + JQS_wTail);
+
+	/* Critical section: bank 1 access. this is how the OSS driver does it:
+	spin_lock_irqsave(&dev.lock, flags);
+	outb(HPBLKSEL_1, dev.io + HP_BLKS);
+	isa_memset_io(dev.base, 0, DAR_BUFF_SIZE * 3);
+	outb(HPBLKSEL_0, dev.io + HP_BLKS);
+	spin_unlock_irqrestore(&dev.lock, flags);*/
+
+	dev.capturePeriodBytes = dpcm->pcm_count;
+	//snd_printd( "snd_msnd_capture_reset_queue() %i\n", dpcm->pcm_count);
+
+	for (n = 0, lpDAQ = dev.base + DARQ_DATA_BUFF; n < 3/*dpcm->pcm_periods*/; ++n, lpDAQ += DAQDS__size) {
+		isa_writew(PCTODSP_BASED((DWORD)(dpcm->pcm_count * (n % dpcm->pcm_periods)) + 0x3000), lpDAQ + DAQDS_wStart);
+		isa_writew(dpcm->pcm_count, lpDAQ + DAQDS_wSize);
+		isa_writew(1, lpDAQ + DAQDS_wFormat);
+		isa_writew(dev.capture_sample_size, lpDAQ + DAQDS_wSampleSize);
+		isa_writew(dev.capture_channels, lpDAQ + DAQDS_wChannels);
+		isa_writew(dev.capture_sample_rate, lpDAQ + DAQDS_wSampleRate);
+		isa_writew(HIMT_RECORD_DONE * 0x100 + n, lpDAQ + DAQDS_wIntMsg);
+		isa_writew(n, lpDAQ + DAQDS_wFlags);
+	}
+}
+
+#ifdef NO0
+static void reset_queues(void)
+{
+	if (dev.mode & FMODE_WRITE) {
+		msnd_fifo_make_empty(&dev.DAPF);
+		snd_msnd_reset_play_queue();
+	}
+	if (dev.mode & FMODE_READ) {
+		msnd_fifo_make_empty(&dev.DARF);
+		snd_msnd_reset_capture_queue();
+	}
+}
+#endif
+
+
+static void dsp_write_flush(void)
+{
+	if (!(dev.mode & FMODE_WRITE) || !test_bit(F_WRITING, &dev.flags))
+		return;
+	set_bit(F_WRITEFLUSH, &dev.flags);
+/*	interruptible_sleep_on_timeout(
+		&dev.writeflush,
+		get_play_delay_jiffies(dev.DAPF.len));*/
+	clear_bit(F_WRITEFLUSH, &dev.flags);
+	if (!signal_pending(current)) {
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(get_play_delay_jiffies( dev.play_period_bytes));
+	}
+	clear_bit(F_WRITING, &dev.flags);
+}
+
+static void dsp_halt(struct file *file)
+{
+	if ((file ? file->f_mode : dev.mode) & FMODE_READ) {
+		clear_bit(F_READING, &dev.flags);
+		snd_msnd_send_dsp_cmd_chk(&dev, HDEX_RECORD_STOP);
+		snd_msnd_disable_irq(&dev);
+		if (file) {
+			printk(KERN_DEBUG LOGNAME ": Stopping read for %p\n", file);
+			dev.mode &= ~FMODE_READ;
+		}
+		clear_bit(F_AUDIO_READ_INUSE, &dev.flags);
+	}
+	if ((file ? file->f_mode : dev.mode) & FMODE_WRITE) {
+		if (test_bit(F_WRITING, &dev.flags)) {
+			dsp_write_flush();
+			snd_msnd_send_dsp_cmd_chk(&dev, HDEX_PLAY_STOP);
+		}
+		snd_msnd_disable_irq(&dev);
+		if (file) {
+			printk(KERN_DEBUG LOGNAME ": Stopping write for %p\n", file);
+			dev.mode &= ~FMODE_WRITE;
+		}
+		clear_bit(F_AUDIO_WRITE_INUSE, &dev.flags);
+	}
+}
+
+#ifdef NO0
+static int dsp_release(struct file *file)
+{
+	dsp_halt(file);
+	return 0;
+}
+#endif
+
+
+static void set_default_play_audio_parameters(void)
+{
+	dev.play_sample_size = DEFSAMPLESIZE;
+	dev.play_sample_rate = DEFSAMPLERATE;
+	dev.play_channels = DEFCHANNELS;
+}
+
+static void set_default_rec_audio_parameters(void)
+{
+	dev.capture_sample_size = DEFSAMPLESIZE;
+	dev.capture_sample_rate = DEFSAMPLERATE;
+	dev.capture_channels = DEFCHANNELS;
+}
+
+static void set_default_audio_parameters(void)
+{
+	set_default_play_audio_parameters();
+	set_default_rec_audio_parameters();
+}
+
+
+static __inline__ int snd_msnd_DARQ( register int bank)
+{
+	register int /*size, n,*/ timeout = 3;
+	register WORD wTmp;
+	//LPDAQD DAQD;
+
+	/* Increment the tail and check for queue wrap */
+	wTmp = isa_readw(dev.DARQ + JQS_wTail) + PCTODSP_OFFSET(DAQDS__size);
+	//printk( "%iR wTmp = %i", bank, (int)wTmp);
+	if (wTmp > isa_readw(dev.DARQ + JQS_wSize))
+		wTmp = 0;
+	//printk( " %i\n", (int)wTmp);
+	while (wTmp == isa_readw(dev.DARQ + JQS_wHead) && timeout--)
+		udelay(1);
+
+	if( dev.capturePeriods == 2){
+		LPDAQD	lpDAQ = dev.base + DARQ_DATA_BUFF + bank * DAQDS__size + DAQDS_wStart;
+		unsigned short offset = isa_readw( lpDAQ);
+		isa_writew( offset == PCTODSP_BASED( 0x3000) ? PCTODSP_BASED( 0x3000 + dev.capturePeriodBytes): PCTODSP_BASED( 0x3000), lpDAQ);
+	}
+
+	isa_writew(wTmp, dev.DARQ + JQS_wTail);
+
+	/* Get our digital audio queue struct
+	DAQD = bank * DAQDS__size + dev.base + DARQ_DATA_BUFF;*/
+
+	/* Get length of data */
+	//size = isa_readw(DAQD + DAQDS_wSize);
+
+	/* Read data from the head (unprotected bank 1 access okay
+           since this is only called inside an interrupt) */
+//	outb(HPBLKSEL_1, dev.io + HP_BLKS);
+/*	if ((n = msnd_fifo_write(
+		&dev.DARF,
+		(char *)(dev.base + bank * DAR_BUFF_SIZE),
+		size, 0)) <= 0) {
+		outb(HPBLKSEL_0, dev.io + HP_BLKS);
+		return n;
+	}*/
+//	outb(HPBLKSEL_0, dev.io + HP_BLKS);
+
+	return 1;
+}
+
+static __inline__ int  snd_msnd_DAPQ( register int start)
+{
+	register WORD	DAPQ_tail;
+	register int	protect = start, nbanks = 0;
+	LPDAQD		DAQD;
+	static int play_banks_submitted;
+	//unsigned long flags;
+	//spin_lock_irqsave( &dev.lock, flags); not necessary
+
+	DAPQ_tail = isa_readw(dev.DAPQ + JQS_wTail);
+	while (DAPQ_tail != isa_readw(dev.DAPQ + JQS_wHead) || start) {
+		register int bank_num = DAPQ_tail / PCTODSP_OFFSET(DAQDS__size);
+
+		if (start){
+			start = 0;
+			play_banks_submitted = 0;
+		}
+
+		/* Get our digital audio queue struct */
+		DAQD = bank_num * DAQDS__size + dev.base + DAPQ_DATA_BUFF;
+
+		/* Write size of this bank */
+		isa_writew( dev.play_period_bytes, DAQD + DAQDS_wSize);
+		if( play_banks_submitted < 3)
+			++play_banks_submitted;
+		else{
+			if( dev.playPeriods == 2){
+				unsigned short offset = isa_readw( DAQD + DAQDS_wStart);
+				isa_writew( offset == PCTODSP_BASED( 0x0) ? PCTODSP_BASED( 0x0 + dev.play_period_bytes): PCTODSP_BASED( 0x0), DAQD + DAQDS_wStart);
+			}
+		}
+		++nbanks;
+
+		/* Then advance the tail */
+		/*
+		if( protect)
+			snd_printd(  "B %X %lX\n", bank_num, xtime.tv_usec);
+		*/
+
+		DAPQ_tail = (++bank_num % 3) * PCTODSP_OFFSET(DAQDS__size);
+		isa_writew(DAPQ_tail, dev.DAPQ + JQS_wTail);
+		/* Tell the DSP to play the bank */
+		snd_msnd_send_dsp_cmd(&dev, HDEX_PLAY_START);
+		if( protect)
+			if( 2 == bank_num)
+	break;
+	}
+	/*
+	if( protect)
+		snd_printd(  "%lX\n", xtime.tv_usec);
+	*/
+	//spin_unlock_irqrestore( &dev.lock, flags); not necessary
+	return nbanks;
+}
+
+
+static int InTrigger = 0;               // interrupt diagnostic, comment this out later
+static int banksPlayed = 0;
+//static int playPosQueriesSinceInt = 0;
+//static int play_bytes_remaining_last;
+//static int play_bytes_jiffies_last;
+
+static __inline__ void snd_msnd_eval_dsp_msg(register WORD wMessage)
+{
+	switch (HIBYTE(wMessage)) {
+	case HIMT_PLAY_DONE: {
+        	snd_msndpinnacle_pcm_t *dpcm = Dpcm;//snd_magic_cast( snd_msndpinnacle_pcm_t, (void*)data, return);
+		//snd_printd( "snd_msnd_eval_dsp_msg( %i)\n", wMessage);
+		#ifdef CONFIG_SND_DEBUG0	
+		if(banksPlayed < 3)
+			printk(  "%08X: HIMT_PLAY_DONE: %i\n",  (unsigned)jiffies, LOBYTE( wMessage));
+		#endif
+		#ifdef CONFIG_SND_DEBUG0
+		{
+			int xx = *(short int*)(__ISA_IO_base + 0x7F40 + dev.base);
+			printk(  "%08X: P %X\n", (unsigned)jiffies, xx);
+		}
+		#endif
+
+		if (dev.last_playbank == LOBYTE(wMessage)){
+			snd_printd(  "dev.last_playbank == LOBYTE(wMessage)\n");
+			break;
+		}
+		banksPlayed++;
+
+		if( test_bit( F_WRITING, &dev.flags))
+			snd_msnd_DAPQ( 0);
+
+		dev.last_playbank = LOBYTE(wMessage);
+                if( ( dev.playDMAPos += dev.play_period_bytes) > dev.playLimit)
+			dev.playDMAPos = 0;
+		//playPosQueriesSinceInt = 0;
+		snd_pcm_period_elapsed( dpcm->substream);
+		//play_bytes_remaining_last += dev.play_period_bytes;
+
+		break;
+	}
+	case HIMT_RECORD_DONE:
+		if (dev.last_recbank == LOBYTE(wMessage))
+			break;
+		dev.last_recbank = LOBYTE(wMessage);
+                if( ( dev.captureDMAPos += dev.capturePeriodBytes) > (dev.captureLimit))
+			dev.captureDMAPos = 0;
+
+		if( test_bit( F_READING, &dev.flags))
+			snd_msnd_DARQ(dev.last_recbank);
+
+		snd_pcm_period_elapsed( dev.captureSubstream);
+		break;
+
+	case HIMT_DSP:
+		switch (LOBYTE(wMessage)) {
+#ifndef MSND_CLASSIC
+		case HIDSP_PLAY_UNDER:
+#endif
+		case HIDSP_INT_PLAY_UNDER:
+			printk(KERN_DEBUG LOGNAME ": Play underflow %i %lX\n", banksPlayed, xtime.tv_usec);
+			if( banksPlayed > 2)
+				clear_bit(F_WRITING, &dev.flags);
+			break;
+
+		case HIDSP_INT_RECORD_OVER:
+			printk(KERN_DEBUG LOGNAME ": Record overflow\n");
+			clear_bit(F_READING, &dev.flags);
+			break;
+
+		default:
+			printk(KERN_DEBUG LOGNAME ": DSP message %d 0x%02x\n",
+			LOBYTE(wMessage), LOBYTE(wMessage));
+			break;
+		}
+		break;
+
+        case HIMT_MIDI_IN_UCHAR:
+//printk( "msnd midi int");
+		if( dev.msndmidi_mpu)
+			snd_msndmidi_input_read( dev.msndmidi_mpu);
+		break;
+
+	default:
+		printk(KERN_DEBUG LOGNAME ": HIMT message %d 0x%02x\n", HIBYTE(wMessage), HIBYTE(wMessage));
+		break;
+	}
+}
+
+//static int InInterrupt = 0;
+static void snd_msnd_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	/*if( InInterrupt){
+		printk(  "INTERRUPT in InInterrupt\n");
+		return;
+	}
+	InInterrupt = 1;*/
+#ifdef CONFIG_SND_DEBUG
+	// interrupt diagnostic, comment this out later
+	if(InTrigger)
+		printk(  "INTERRUPT in InTrigger %i\n", InTrigger);        // should never happen
+#endif
+	/* Send ack to DSP */
+//	inb(dev.io + HP_RXL);
+
+	/* Evaluate queued DSP messages */
+	while (isa_readw(dev.DSPQ + JQS_wTail) != isa_readw(dev.DSPQ + JQS_wHead)) {
+		register WORD wTmp;
+
+		snd_msnd_eval_dsp_msg(isa_readw(dev.pwDSPQData + 2*isa_readw(dev.DSPQ + JQS_wHead)));
+
+		if ((wTmp = isa_readw(dev.DSPQ + JQS_wHead) + 1) > isa_readw(dev.DSPQ + JQS_wSize))
+			isa_writew(0, dev.DSPQ + JQS_wHead);
+		else
+			isa_writew(wTmp, dev.DSPQ + JQS_wHead);
+	}
+	/* Send ack to DSP */
+	inb(dev.io + HP_RXL);
+	//InInterrupt = 0;
+}
+
+
+static int snd_msnd_reset_dsp(void)
+{
+	int timeout = 100;
+
+	outb(HPDSPRESET_ON, dev.io + HP_DSPR);
+	mdelay(1);
+#ifndef MSND_CLASSIC
+	dev.info = inb(dev.io + HP_INFO);
+#endif
+	outb(HPDSPRESET_OFF, dev.io + HP_DSPR);
+	mdelay(1);
+	while (timeout-- > 0) {
+		if (inb(dev.io + HP_CVR) == HP_CVR_DEF)
+			return 0;
+		mdelay(1);
+	}
+	printk(KERN_ERR LOGNAME ": Cannot reset DSP\n");
+
+	return -EIO;
+}
+
+static int __init snd_msnd_probe(void)
+{
+#ifndef MSND_CLASSIC
+	char *xv, *rev = NULL;
+	char *pin = "Pinnacle", *fiji = "Fiji";
+	char *pinfiji = "Pinnacle/Fiji";
+#endif
+
+	if (check_region(dev.io, dev.numio)) {
+		printk(KERN_ERR LOGNAME ": I/O port conflict\n");
+		return -ENODEV;
+	}
+	request_region(dev.io, dev.numio, "probing");
+
+	if ( snd_msnd_reset_dsp() < 0) {
+		release_region(dev.io, dev.numio);
+		return -ENODEV;
+	}
+
+#ifdef MSND_CLASSIC
+	dev.name = "Classic/Tahiti/Monterey";
+	printk(KERN_INFO LOGNAME ": %s, "
+#else
+	switch (dev.info >> 4) {
+	case 0xf: xv = "<= 1.15"; break;
+	case 0x1: xv = "1.18/1.2"; break;
+	case 0x2: xv = "1.3"; break;
+	case 0x3: xv = "1.4"; break;
+	default: xv = "unknown"; break;
+	}
+
+	switch (dev.info & 0x7) {
+	case 0x0: rev = "I"; dev.name = pin; break;
+	case 0x1: rev = "F"; dev.name = pin; break;
+	case 0x2: rev = "G"; dev.name = pin; break;
+	case 0x3: rev = "H"; dev.name = pin; break;
+	case 0x4: rev = "E"; dev.name = fiji; break;
+	case 0x5: rev = "C"; dev.name = fiji; break;
+	case 0x6: rev = "D"; dev.name = fiji; break;
+	case 0x7:
+		rev = "A-B (Fiji) or A-E (Pinnacle)";
+		dev.name = pinfiji;
+		break;
+	}
+	printk(KERN_INFO LOGNAME ": %s revision %s, Xilinx version %s, "
+#endif /* MSND_CLASSIC */
+	       "I/O 0x%x-0x%x, IRQ %d, memory mapped to 0x%lX-0x%lX\n",
+	       dev.name,
+#ifndef MSND_CLASSIC
+	       rev, xv,
+#endif
+	       dev.io, dev.io + dev.numio - 1,
+	       dev.irq,
+	       dev.base, dev.base + 0x7fff);
+
+	release_region(dev.io, dev.numio);
+	return 0;
+}
+
+static int snd_msnd_init_sma(void)
+{
+	static int initted;
+	WORD mastVolLeft, mastVolRight;
+	unsigned long flags;
+
+#ifdef MSND_CLASSIC
+	outb(dev.memid, dev.io + HP_MEMM);
+#endif
+	outb(HPBLKSEL_0, dev.io + HP_BLKS);
+	if (initted) {
+		mastVolLeft = isa_readw(dev.SMA + SMA_wCurrMastVolLeft);
+		mastVolRight = isa_readw(dev.SMA + SMA_wCurrMastVolRight);
+	} else
+		mastVolLeft = mastVolRight = 0;
+	isa_memset_io(dev.base, 0, 0x8000);
+
+	/* Critical section: bank 1 access */
+	spin_lock_irqsave(&dev.lock, flags);
+	outb(HPBLKSEL_1, dev.io + HP_BLKS);
+	isa_memset_io(dev.base, 0, 0x8000);
+	outb(HPBLKSEL_0, dev.io + HP_BLKS);
+	spin_unlock_irqrestore(&dev.lock, flags);
+
+	dev.pwDSPQData = (dev.base + DSPQ_DATA_BUFF);
+	dev.pwMODQData = (dev.base + MODQ_DATA_BUFF);
+	dev.pwMIDQData = (dev.base + MIDQ_DATA_BUFF);
+
+	/* Motorola 56k shared memory base */
+	dev.SMA = dev.base + SMA_STRUCT_START;
+
+	/* Digital audio play queue */
+	dev.DAPQ = dev.base + DAPQ_OFFSET;
+	snd_msnd_init_queue(dev.DAPQ, DAPQ_DATA_BUFF, DAPQ_BUFF_SIZE);
+
+	/* Digital audio record queue */
+	dev.DARQ = dev.base + DARQ_OFFSET;
+	snd_msnd_init_queue(dev.DARQ, DARQ_DATA_BUFF, DARQ_BUFF_SIZE);
+
+	/* MIDI out queue */
+	dev.MODQ = dev.base + MODQ_OFFSET;
+	snd_msnd_init_queue(dev.MODQ, MODQ_DATA_BUFF, MODQ_BUFF_SIZE);
+
+	/* MIDI in queue */
+	dev.MIDQ = dev.base + MIDQ_OFFSET;
+	snd_msnd_init_queue(dev.MIDQ, MIDQ_DATA_BUFF, MIDQ_BUFF_SIZE);
+
+	/* DSP -> host message queue */
+	dev.DSPQ = dev.base + DSPQ_OFFSET;
+	snd_msnd_init_queue(dev.DSPQ, DSPQ_DATA_BUFF, DSPQ_BUFF_SIZE);
+
+	/* Setup some DSP values */
+#ifndef MSND_CLASSIC
+	isa_writew(1, dev.SMA + SMA_wCurrPlayFormat);
+	isa_writew(dev.play_sample_size, dev.SMA + SMA_wCurrPlaySampleSize);
+	isa_writew(dev.play_channels, dev.SMA + SMA_wCurrPlayChannels);
+	isa_writew(dev.play_sample_rate, dev.SMA + SMA_wCurrPlaySampleRate);
+#endif
+	isa_writew(dev.play_sample_rate, dev.SMA + SMA_wCalFreqAtoD);
+	isa_writew(mastVolLeft, dev.SMA + SMA_wCurrMastVolLeft);
+	isa_writew(mastVolRight, dev.SMA + SMA_wCurrMastVolRight);
+#ifndef MSND_CLASSIC
+	isa_writel(0x00010000, dev.SMA + SMA_dwCurrPlayPitch);
+	isa_writel(0x00000001, dev.SMA + SMA_dwCurrPlayRate);
+#endif
+	isa_writew(0x303, dev.SMA + SMA_wCurrInputTagBits);
+
+	initted = 1;
+
+	return 0;
+}
+
+
+////////////////////////////////////////////////////////////////////////////////
+
+static int __init snd_msnd_calibrate_adc( WORD srate)
+{
+	snd_printd( "snd_msnd_calibrate_adc( %i)\n", srate);
+	isa_writew(srate, dev.SMA + SMA_wCalFreqAtoD);
+	if (dev.calibrate_signal == 0)
+		isa_writew(isa_readw(dev.SMA + SMA_wCurrHostStatusFlags)
+		       | 0x0001, dev.SMA + SMA_wCurrHostStatusFlags);
+	else
+		isa_writew(isa_readw(dev.SMA + SMA_wCurrHostStatusFlags)
+		       & ~0x0001, dev.SMA + SMA_wCurrHostStatusFlags);
+	if (snd_msnd_send_word(&dev, 0, 0, HDEXAR_CAL_A_TO_D) == 0 &&
+	    snd_msnd_send_dsp_cmd_chk(&dev, HDEX_AUX_REQ) == 0) {
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(HZ / 3);
+		return 0;
+	}
+	printk(KERN_WARNING LOGNAME ": ADC calibration failed\n");
+	return -EIO;
+}
+
+static int upload_dsp_code(void)
+{
+	outb(HPBLKSEL_0, dev.io + HP_BLKS);
+#ifndef HAVE_DSPCODEH
+	INITCODESIZE = mod_firmware_load(INITCODEFILE, &INITCODE);
+	if (!INITCODE) {
+		printk(KERN_ERR LOGNAME ": Error loading " INITCODEFILE);
+		return -EBUSY;
+	}
+
+	PERMCODESIZE = mod_firmware_load(PERMCODEFILE, &PERMCODE);
+	if (!PERMCODE) {
+		printk(KERN_ERR LOGNAME ": Error loading " PERMCODEFILE);
+		vfree_nocheck(INITCODE);
+		return -EBUSY;
+	}
+#endif
+	isa_memcpy_toio(dev.base, PERMCODE, PERMCODESIZE);
+	if (snd_msnd_upload_host(&dev, INITCODE, INITCODESIZE) < 0) {
+		printk(KERN_WARNING LOGNAME ": Error uploading to DSP\n");
+		return -ENODEV;
+	}
+#ifdef HAVE_DSPCODEH
+	printk(KERN_INFO LOGNAME ": DSP firmware uploaded (resident)\n");
+#else
+	printk(KERN_INFO LOGNAME ": DSP firmware uploaded\n");
+#endif
+
+#ifndef HAVE_DSPCODEH
+	vfree_nocheck(INITCODE);
+	vfree_nocheck(PERMCODE);
+#endif
+	return 0;
+}
+
+#ifdef MSND_CLASSIC
+static void reset_proteus(void)
+{
+	outb(HPPRORESET_ON, dev.io + HP_PROR);
+	mdelay(TIME_PRO_RESET);
+	outb(HPPRORESET_OFF, dev.io + HP_PROR);
+	mdelay(TIME_PRO_RESET_DONE);
+}
+#endif
+
+static int snd_msnd_initialize(void)
+{
+	int err, timeout;
+	//snd_printd( "snd_msnd_initialize( void)\n");
+
+#ifdef MSND_CLASSIC
+	outb(HPWAITSTATE_0, dev.io + HP_WAIT);
+	outb(HPBITMODE_16, dev.io + HP_BITM);
+
+	reset_proteus();
+#endif
+	if ((err = snd_msnd_init_sma()) < 0) {
+		printk(KERN_WARNING LOGNAME ": Cannot initialize SMA\n");
+		return err;
+	}
+
+	if ((err = snd_msnd_reset_dsp()) < 0)
+		return err;
+
+	if ((err = upload_dsp_code()) < 0) {
+		printk(KERN_WARNING LOGNAME ": Cannot upload DSP code\n");
+		return err;
+	}
+
+	timeout = 200;
+
+	//snd_printd( "%li\n", dev.base);
+	while (isa_readw(dev.base)) {
+		mdelay(1);
+		if (!timeout--) {
+			printk(KERN_DEBUG LOGNAME ": DSP reset timeout\n");
+			return -EIO;
+		}
+	}
+
+	snd_msndmix_setup( &dev);
+	return 0;
+}
+
+static int snd_msnd_dsp_full_reset(void)
+{
+	int rv;
+
+	if (test_bit(F_RESETTING, &dev.flags) || ++dev.nresets > 10)
+		return 0;
+
+	set_bit(F_RESETTING, &dev.flags);
+	printk(KERN_INFO LOGNAME ": DSP reset\n");
+	dsp_halt(NULL);			/* Unconditionally halt */
+	if ((rv = snd_msnd_initialize()))
+		printk(KERN_WARNING LOGNAME ": DSP reset failed\n");
+	snd_msndmix_force_recsrc( &dev, 0);
+	clear_bit( F_RESETTING, &dev.flags);
+	return rv;
+}
+
+static int snd_msnd_dev_free( snd_device_t *device){
+	snd_printd( "snd_msnd_dev_free()\n");
+	return 0;
+}
+
+static snd_pcm_hardware_t snd_msnd_playback =
+{
+	info:			( SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED | SNDRV_PCM_INFO_MMAP_VALID),
+	formats:		( SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE),
+	rates:			SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,
+	rate_min:		8000,
+	rate_max:		48000,
+	channels_min:		1,
+	channels_max:		2,
+	buffer_bytes_max:	0x3000,
+	period_bytes_min:	0x40,
+	period_bytes_max:	0x1800,
+	periods_min:		2,
+	periods_max:		3,
+	fifo_size:		0,
+};
+
+static snd_pcm_hardware_t snd_msnd_capture =
+{
+	info:			(SNDRV_PCM_INFO_MMAP | SNDRV_PCM_INFO_INTERLEAVED |
+				 SNDRV_PCM_INFO_MMAP_VALID),
+	formats:		( SNDRV_PCM_FMTBIT_U8 | SNDRV_PCM_FMTBIT_S16_LE),
+	rates:			SNDRV_PCM_RATE_KNOT | SNDRV_PCM_RATE_8000_48000,
+	rate_min:		8000,
+	rate_max:		48000,
+	channels_min:		1,
+	channels_max:		2,
+	buffer_bytes_max:	0x3000,
+	period_bytes_min:	0x40,
+	period_bytes_max:	0x1800,
+	periods_min:		2,
+	periods_max:		3,
+	fifo_size:		0,
+};
+
+
+static unsigned int rates[7] = {
+	8000, 11025, 16000, 22050,
+	32000, 44100, 48000
+};
+
+static snd_pcm_hw_constraint_list_t hw_constraints_rates = {
+	count: 7,
+	list: rates,
+	mask: 0,
+};
+
+
+
+static void snd_msnd_pcm_timer_function(unsigned long data)
+{
+//this is a dummy caused by lack of knowledge
+
+	snd_printd( "snd_msnd_pcm_timer_function()\n");
+
+/*	
+	dpcm->timer.expires = 1 + jiffies;
+	add_timer( &dpcm->timer);
+	spin_lock_irq( &dpcm->lock);
+	dpcm->pcm_irq_pos += dpcm->pcm_jiffie;
+	dpcm->pcm_buf_pos += dpcm->pcm_jiffie;
+	dpcm->pcm_buf_pos %= dpcm->pcm_size;
+	while (dpcm->pcm_irq_pos >= dpcm->pcm_count) {
+		dpcm->pcm_irq_pos -= dpcm->pcm_count;
+		snd_pcm_period_elapsed( dpcm->substream);
+	}
+	spin_unlock_irq( &dpcm->lock);	*/
+}
+
+static void snd_msnd_runtime_free( snd_pcm_runtime_t *runtime)
+{
+	snd_msndpinnacle_pcm_t* dpcm = snd_magic_cast( snd_msndpinnacle_pcm_t, runtime->private_data, return);
+	snd_magic_kfree( dpcm);
+}
+
+#ifdef SND_MSNDPI_GENSIN
+	// diagnostic code i used to make it work
+	static short int sinTable[ 0x480] = {
+		#include "sintable.h"
+		};
+
+static void snd_msnd_generate_sine(signed short *samples, int channels,
+			  snd_pcm_uframes_t offset,
+			  int count, double *_phase, int freq, int rate)
+{
+	double phase = *_phase;
+	double max_phase = 1.0 / freq;
+	double step = 1.0 / (double)rate;
+	double res;
+
+//	int steps[channels];
+	int chn, ires, sto = 0;
+
+	/* verify and prepare the contents of areas */
+	for (chn = 0; chn < channels; chn++) {
+	}
+	/* fill the channel areas */
+	while (count > 0) {
+		ires = sinTable[ sto];
+		if( (sto += freq) >= 0x480)
+			sto = 0;
+		for (chn = 0; chn < channels; chn++) {
+			*samples = ires;
+			samples ++;
+			count -= 2;
+		}
+		phase += step;
+		if (phase >= max_phase)
+			phase -= max_phase;
+	}
+	*_phase = phase;
+}
+#endif
+
+
+static int snd_msnd_playback_open( snd_pcm_substream_t *substream)
+{
+	snd_pcm_runtime_t*	runtime = substream->runtime;
+	snd_msndpinnacle_pcm_t*	dpcm;
+
+	//snd_printd( "snd_msnd_playback_open()\n");
+
+	Dpcm = dpcm = snd_magic_kcalloc( snd_msndpinnacle_pcm_t, 0, GFP_KERNEL);
+	if( dpcm == NULL)
+		return -ENOMEM;
+
+	//snd_printd( " dpcm = %X\n", (unsigned)dpcm);
+
+	set_bit( F_AUDIO_WRITE_INUSE, &dev.flags);
+	clear_bit( F_WRITING, &dev.flags);
+	snd_msnd_enable_irq( &dev);
+
+	runtime->dma_area =	dev.mappedbase;
+	//memset( __ISA_IO_base + dev.base, 0, 3*0x2400);
+	runtime->dma_bytes =	0x3000;
+
+	dpcm->timer.data =	(unsigned long) dpcm;
+	dpcm->timer.function =	snd_msnd_pcm_timer_function;
+	spin_lock_init( &dpcm->lock);
+	dpcm->substream =	substream;
+	runtime->private_data =	dpcm;
+	runtime->private_free =	snd_msnd_runtime_free;
+	runtime->hw =		snd_msnd_playback;
+	snd_pcm_hw_constraint_list( runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
+	return 0;
+}
+
+static int snd_msnd_playback_close( snd_pcm_substream_t *substream)
+{
+	//snd_printd( "snd_msnd_playback_close()\n");
+	snd_msnd_disable_irq( &dev);
+	clear_bit( F_AUDIO_WRITE_INUSE, &dev.flags);
+	return 0;
+}
+
+
+static int snd_msnd_playback_hw_params( snd_pcm_substream_t * substream, snd_pcm_hw_params_t * params)
+{
+	/*	snd_printd( " dpcm = %X M=%X\n", (unsigned)substream->runtime->private_data,
+			*((unsigned*)substream->runtime->private_data-1));
+	*/
+	//snd_msndpinnacle_pcm_t*	chip = snd_pcm_substream_chip( substream);
+	int 		i;
+	LPDAQD		lpDAQ =	dev.base + DAPQ_DATA_BUFF;
+
+	//this results in 8 with the 2 synts amsynth & bristol so for now i hardcode it:
+	//dev.play_sample_size =	snd_pcm_format_width( substream->runtime->format);
+	//printk( "dev.play_sample_size %i\n", dev.play_sample_size);
+	dev.play_sample_size =	16;
+	dev.play_channels =	params_channels( params);
+	dev.play_sample_rate =	params_rate( params);
+
+	//snd_printd( "snd_msnd_playback_hw_params()\n");
+	//snd_printd( "f: %i; c: %i; r: %i\n", dev.play_sample_size, dev.play_channels, dev.play_sample_rate);
+
+	for( i = 0; i < 3; ++i, lpDAQ += DAQDS__size) {
+		isa_writew( dev.play_sample_size,	lpDAQ + DAQDS_wSampleSize);
+		isa_writew( dev.play_channels,		lpDAQ + DAQDS_wChannels);
+		isa_writew( dev.play_sample_rate,	lpDAQ + DAQDS_wSampleRate);
+	}
+	// dont do this here:	snd_msnd_calibrate_adc( dev.play_sample_rate);
+
+	/* stuff i used to get it basically making noise:
+	{
+	double phase = 0.0;
+	generate_sine((short int*)(__ISA_IO_base + dev.base), dev.play_channels,
+				  0,
+				  0x2400, &phase, 4, dev.play_sample_rate) ;
+	generate_sine((short int*)(__ISA_IO_base + dev.base + 1*0x2400), dev.play_channels,
+				  0,
+				  0x2400, &phase, 4, dev.play_sample_rate);
+	generate_sine((short int*)(__ISA_IO_base + dev.base + 2*0x2400), dev.play_channels,
+				  0,
+				  0x2400, &phase, 4, dev.play_sample_rate);
+	}*/
+	return 0;
+}
+
+
+
+/*static int snd_msnd_playback_hw_free( snd_pcm_substream_t *substream)
+{
+	snd_printd( "snd_msnd_playback_hw_free()\n");
+	return 0;
+} */
+
+static int snd_msnd_playback_prepare( snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_msndpinnacle_pcm_t*	dpcm = snd_magic_cast( snd_msndpinnacle_pcm_t, runtime->private_data, return -ENXIO);
+	//snd_printd( "snd_msnd_playback_prepare()\n");
+
+	dpcm->pcm_size = snd_pcm_lib_buffer_bytes( substream);
+	dpcm->pcm_count = snd_pcm_lib_period_bytes( substream);
+	dpcm->pcm_periods = dpcm->pcm_size / dpcm->pcm_count;
+	//snd_printd( "buffer_bytes=%i; period_bytes=%i\n", dpcm->pcm_size, dpcm->pcm_count);
+	snd_msnd_play_reset_queue( dpcm);
+	dev.playDMAPos = 0;
+	return 0;
+}
+
+//static int played_bytes;
+static int snd_msnd_playback_trigger( snd_pcm_substream_t * substream, int cmd)
+{
+	int	result = 0;
+	//spin_lock(&chip->reg_lock);
+	if( cmd == SNDRV_PCM_TRIGGER_START) {
+		//snd_printd( "snd_msnd_playback_trigger( START)\n");
+		InTrigger = 1;           // interrupt diagnostic, comment this out later
+		//play_bytes_remaining_last = 0;
+		banksPlayed = 0;
+		//playPosQueriesSinceInt = 0;
+		//played_bytes = -1;
+		set_bit( F_WRITING, &dev.flags);
+		// this gives looong timeouts, so dont do it here: snd_msnd_calibrate_adc( dev.play_sample_rate);
+		snd_msnd_DAPQ( 1);
+	} else if( cmd == SNDRV_PCM_TRIGGER_STOP) {
+		//snd_printd( "snd_msnd_playback_trigger( STop)\n");
+		InTrigger = 2;            // interrupt diagnostic, comment this out later
+		clear_bit( F_WRITING, &dev.flags);
+		snd_msnd_send_dsp_cmd(&dev, HDEX_PLAY_STOP);
+	} else {
+		snd_printd( "snd_msnd_playback_trigger( \?\?\?\?\?)\n");
+		result = -EINVAL;
+	}
+	InTrigger = 0;             // interrupt diagnostic, comment this out later
+	//	spin_unlock(&chip->reg_lock);
+
+	//snd_printd( "snd_msnd_playback_trigger() ENDE\n");
+	return result;
+}
+
+static snd_pcm_uframes_t snd_msnd_playback_pointer( snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t*	runtime =	substream->runtime;
+	//snd_printd( "snd_msnd_playback_pointer()\n");
+	//snd_msndpinnacle_pcm_t*	dpcm =		snd_magic_cast( snd_msndpinnacle_pcm_t, runtime->private_data, return -ENXIO);
+
+	/*	with the following mess i tried to generate a more precise pointer position
+	 *	it generated errors with the alsa framework i could not resolve.....
+	//int pos = dev.playDMAPos;
+	unsigned	remaining = *(short int*)(__ISA_IO_base + 0x7F40 + dev.base),
+	 		ljiffies = (unsigned)jiffies;
+	int		diff;
+	if( -1 == played_bytes){
+		if( 0 == remaining)
+			played_bytes = 0;
+		else
+			played_bytes = dev.play_period_bytes - remaining;
+	//	played_bytes += 0x60;
+	}else{
+	int 	ref =		( ljiffies - play_bytes_jiffies_last)
+			*	( runtime->frame_bits / 16)
+			*	( runtime->rate /HZ);
+		diff = 	play_bytes_remaining_last - remaining;
+		//printk( "pb %i diff %i ref %i",  played_bytes, diff, ref);
+		if( diff < ref){
+			diff += dev.play_period_bytes;
+			//printk( " newdiff %i ",  diff);
+		}
+		played_bytes += diff;
+		//printk( "\n");
+	}
+
+	play_bytes_remaining_last =	remaining;
+	play_bytes_jiffies_last =	ljiffies;
+	played_bytes %=			snd_msnd_playback.buffer_bytes_max;
+
+	//	if( playPosQueriesSinceInt++)
+	//		pos += dev.play_period_bytes - remaining;
+
+	{
+		snd_printd( "%08X: remaining %04X\n", (unsigned)jiffies, remaining);
+		snd_printd(  "snd_msnd_playback_pointer() %X\n", played_bytes);
+	}
+
+	diff = dev.playDMAPos - played_bytes;
+	if( diff < 0)
+		diff += snd_msndpinnacle_playback.buffer_bytes_max;
+
+	return bytes_to_frames( runtime,
+				diff < ( snd_msndpinnacle_playback.buffer_bytes_max / 2)
+			?       dev.playDMAPos : played_bytes);
+	// end of mess
+	*/
+	return bytes_to_frames( runtime, dev.playDMAPos);
+}
+
+
+static snd_pcm_ops_t snd_msnd_playback_ops = {
+	open:		snd_msnd_playback_open,
+	close:		snd_msnd_playback_close,
+	ioctl:		snd_pcm_lib_ioctl,
+	hw_params:	snd_msnd_playback_hw_params,
+//	hw_free:	snd_msnd_playback_hw_free,
+	prepare:	snd_msnd_playback_prepare,
+	trigger:	snd_msnd_playback_trigger,
+	pointer:	snd_msnd_playback_pointer,
+};
+
+static int snd_msnd_capture_open(snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t*	runtime = substream->runtime;
+	snd_msndpinnacle_pcm_t*	dpcm;
+	//snd_printd( "snd_msnd_capture_open()\n");
+
+	dpcm = snd_magic_kcalloc( snd_msndpinnacle_pcm_t, 0, GFP_KERNEL);
+	if( dpcm == NULL)
+		return -ENOMEM;
+
+	dev.captureSubstream = substream;
+	set_bit( F_AUDIO_READ_INUSE, &dev.flags);
+	snd_msnd_enable_irq( &dev);
+	runtime->dma_area = dev.mappedbase + 0x3000;
+	runtime->dma_bytes = 0x3000;
+	memset( runtime->dma_area, 0, runtime->dma_bytes);
+	dpcm->timer.data = (unsigned long) dpcm;
+	dpcm->timer.function = snd_msnd_pcm_timer_function;
+	spin_lock_init(&dpcm->lock);
+	dpcm->substream = substream;
+	runtime->private_data = dpcm;
+	runtime->private_free = snd_msnd_runtime_free;
+	runtime->hw = snd_msnd_capture;
+	snd_pcm_hw_constraint_list( runtime, 0, SNDRV_PCM_HW_PARAM_RATE, &hw_constraints_rates);
+	return 0;
+}
+
+static int snd_msnd_capture_close( snd_pcm_substream_t * substream)
+{
+	//snd_printd( "snd_msnd_capture_close()\n");
+	snd_msnd_disable_irq( &dev);
+	clear_bit( F_AUDIO_READ_INUSE, &dev.flags);
+	return 0;
+}
+
+static int snd_msnd_capture_prepare( snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+	snd_msndpinnacle_pcm_t*	dpcm = snd_magic_cast( snd_msndpinnacle_pcm_t, runtime->private_data, return -ENXIO);
+	//snd_printd( "snd_msnd_capture_prepare()\n");
+
+	dpcm->pcm_size = snd_pcm_lib_buffer_bytes( substream);
+	dpcm->pcm_count = snd_pcm_lib_period_bytes( substream);
+	dpcm->pcm_periods = dpcm->pcm_size / dpcm->pcm_count;
+	//snd_printd( "buffer_bytes=%i; period_bytes=%i\n", dpcm->pcm_size, dpcm->pcm_count);
+	snd_msnd_capture_reset_queue( dpcm);
+	dev.captureDMAPos = 0;
+	return 0;
+}
+
+static int snd_msnd_capture_trigger( snd_pcm_substream_t * substream, int cmd)
+{
+	if( cmd == SNDRV_PCM_TRIGGER_START){
+		//snd_card_dummy_pcm_timer_start(substream);
+		dev.last_recbank = -1;
+		set_bit( F_READING, &dev.flags);
+		if (snd_msnd_send_dsp_cmd_chk(&dev, HDEX_RECORD_START) == 0)
+			return 0;
+
+		clear_bit( F_READING, &dev.flags);
+	}else if( cmd == SNDRV_PCM_TRIGGER_STOP){
+		//snd_card_dummy_pcm_timer_stop(substream);
+		clear_bit( F_READING, &dev.flags);
+		snd_msnd_send_dsp_cmd(&dev, HDEX_RECORD_STOP);
+		return 0;
+	}
+	return -EINVAL;
+}
+
+
+static snd_pcm_uframes_t snd_msnd_capture_pointer( snd_pcm_substream_t * substream)
+{
+	snd_pcm_runtime_t *runtime = substream->runtime;
+//	snd_card_dummy_pcm_t *dpcm = snd_magic_cast(snd_card_dummy_pcm_t, runtime->private_data, return -ENXIO);
+
+	return bytes_to_frames( runtime, dev.captureDMAPos);
+}
+
+
+static int snd_msnd_capture_hw_params( snd_pcm_substream_t * substream, snd_pcm_hw_params_t * params)
+{
+	int		i;
+	LPDAQD		lpDAQ =		dev.base + DARQ_DATA_BUFF;
+
+	//this results in 8 with the 2 synts amsynth & bristol so for now i hardcode it:
+	//dev.play_sample_size =	snd_pcm_format_width( substream->runtime->format);
+	//printk( "dev.play_sample_size %i\n", dev.play_sample_size);
+	dev.capture_sample_size =	16;
+	dev.capture_channels =		params_channels( params);
+	dev.capture_sample_rate =	params_rate( params);
+
+	//snd_printd( "snd_msnd_capture_hw_params()\n");
+	//snd_printd( "f: %i; c: %i; r: %i\n", dev.capture_sample_size, dev.capture_channels, dev.capture_sample_rate);
+
+	for( i = 0; i < 3; ++i, lpDAQ += DAQDS__size) {
+		isa_writew( dev.capture_sample_size,	lpDAQ + DAQDS_wSampleSize);
+		isa_writew( dev.capture_channels,	lpDAQ + DAQDS_wChannels);
+		isa_writew( dev.capture_sample_rate,	lpDAQ + DAQDS_wSampleRate);
+	}
+	return 0;
+}
+
+
+static snd_pcm_ops_t snd_msnd_capture_ops = {
+	open:		snd_msnd_capture_open,
+	close:		snd_msnd_capture_close,
+	ioctl:		snd_pcm_lib_ioctl,
+	hw_params:	snd_msnd_capture_hw_params,
+//	hw_free:	snd_msnd_capture_hw_free,
+	prepare:	snd_msnd_capture_prepare,
+	trigger:	snd_msnd_capture_trigger,
+	pointer:	snd_msnd_capture_pointer,
+};
+
+
+int snd_msnd_pcm( multisound_dev_t *chip, int device, snd_pcm_t **rpcm)
+{
+	snd_pcm_t*	pcm;
+	int		err;
+
+	if( ( err = snd_pcm_new( chip->card, "MSNDPINNACLE", 0/*device*/, 1, 1, &pcm)) < 0)
+		return err;
+
+	snd_pcm_set_ops( pcm, SNDRV_PCM_STREAM_PLAYBACK, &snd_msnd_playback_ops);
+	snd_pcm_set_ops( pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_msnd_capture_ops);
+
+	pcm->private_free = NULL;//snd_msnd_pcm_free;
+	pcm->private_data = chip;
+	pcm->info_flags = 0;//SNDRV_PCM_INFO_HALF_DUPLEX;
+	strcpy(pcm->name, "Hurricane");
+
+
+	chip->pcm = pcm;
+	if (rpcm)
+		*rpcm = pcm;
+	return 0;
+}
+
+static int __init snd_msnd_attach(void)
+{
+	int err;
+	snd_card_t *card;
+	static snd_device_ops_t ops = {
+		dev_free:       snd_msnd_dev_free,
+		};
+
+	//snd_printd(  "snd_msnd_attach(void)\n");
+	if ((err = request_irq(dev.irq, snd_msnd_interrupt, 0, dev.name, &dev)) < 0) {
+		printk(KERN_ERR LOGNAME ": Couldn't grab IRQ %d\n", dev.irq);
+		return err;
+	}
+	request_region(dev.io, dev.numio, dev.name);
+
+	dev.mappedbase = (void*)( __ISA_IO_base + dev.base);
+
+	/* geht nich!!!!!
+		useless, don't do this at home.
+		the multisound has shared isa memory that is by default already maped.
+
+	if( ( dev.mappedbase = request_mem_region( (unsigned)(__ISA_IO_base + dev.base), BUFFSIZE, "MSNDPINNACLE")) == NULL) {
+		printk( KERN_ERR LOGNAME ": unable to grab memory region 0x%lx-0x%lx\n",
+			   dev.base, dev.base + BUFFSIZE - 1);
+		release_region( dev.io, dev.numio);
+		free_irq( dev.irq, &dev);
+		return -EBUSY;
+	}
+	*/
+
+	//snd_printd(  "dev.mappedbase = 0x%08X\n", (unsigned)dev.mappedbase);
+
+	if( ( err = snd_msnd_dsp_full_reset()) < 0){
+		release_region( dev.io, dev.numio);
+		free_irq( dev.irq, &dev);
+		return err;
+	}
+
+	if ((err = snd_msnd_register(&dev)) < 0) {
+		printk(KERN_ERR LOGNAME ": Unable to register MultiSound\n");
+		release_region(dev.io, dev.numio);
+		free_irq(dev.irq, &dev);
+		return err;
+	}
+
+	card = snd_card_new(snd_index[ 0/*dev*/], snd_id[0/*dev*/], THIS_MODULE, 0);
+	if( card == NULL){
+		snd_msnd_unregister(&dev);
+		release_region(dev.io, dev.numio);
+		free_irq(dev.irq, &dev);
+		return -ENOMEM;
+	}
+
+	strcpy( card->shortname, "TB Pinnacle");
+	strcpy( card->longname, "Turtle Beach Multisound Pinnacle");
+	dev.card = card;
+
+	/* Register device */
+	if( ( err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, &dev, &ops)) < 0){
+		snd_card_free( card);
+		snd_msnd_unregister( &dev);
+		release_region( dev.io, dev.numio);
+		free_irq( dev.irq, &dev);
+		return err;
+	}
+
+	if( ( err = snd_msnd_pcm( &dev, 0, NULL)) < 0){
+		printk(KERN_ERR LOGNAME ": error creating new PCM device\n");
+		snd_card_free(card);
+		snd_msnd_unregister( &dev);
+		release_region( dev.io, dev.numio);
+		free_irq( dev.irq, &dev);
+		return err;
+	}
+
+	if( ( err = snd_msndmix_new( &dev)) < 0){
+		printk(KERN_ERR LOGNAME ": error creating new Mixer device\n");
+		snd_card_free(card);
+		snd_msnd_unregister( &dev);
+		release_region( dev.io, dev.numio);
+		free_irq( dev.irq, &dev);
+		return err;
+	}
+
+
+	if( ( err = snd_msndmidi_new( card, 0, &dev)) < 0){
+		printk(KERN_ERR LOGNAME ": error creating new Midi device\n");
+		snd_card_free(card);
+		snd_msnd_unregister( &dev);
+		release_region( dev.io, dev.numio);
+		free_irq( dev.irq, &dev);
+		return err;
+	}
+
+	disable_irq(dev.irq);
+	snd_msnd_calibrate_adc( dev.play_sample_rate);
+	snd_msndmix_force_recsrc( &dev, 0);
+
+	if( ( err = snd_card_register(card)) < 0) {
+		snd_card_free(card);
+		return err;
+	}
+
+	//snd_printd(  "attach_multisound(void) end\n");
+	return 0;
+}
+
+
+static void __exit snd_msnd_unload(void)
+{
+	//snd_printd(  "snd_msnd_unload(void)\n");
+	release_region(dev.io, dev.numio);
+	free_irq(dev.irq, &dev);
+	snd_msnd_unregister(&dev);
+	snd_card_free( dev.card);
+}
+
+#ifndef MSND_CLASSIC
+
+/* Pinnacle/Fiji Logical Device Configuration */
+
+static int __init snd_msnd_write_cfg(int cfg, int reg, int value)
+{
+	outb(reg, cfg);
+	outb(value, cfg + 1);
+	if (value != inb(cfg + 1)) {
+		printk(KERN_ERR LOGNAME ": snd_msnd_write_cfg: I/O error\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+static int __init snd_msnd_write_cfg_io0(int cfg, int num, WORD io)
+{
+	if (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))
+		return -EIO;
+	if (snd_msnd_write_cfg(cfg, IREG_IO0_BASEHI, HIBYTE(io)))
+		return -EIO;
+	if (snd_msnd_write_cfg(cfg, IREG_IO0_BASELO, LOBYTE(io)))
+		return -EIO;
+	return 0;
+}
+
+static int __init snd_msnd_write_cfg_io1(int cfg, int num, WORD io)
+{
+	if (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))
+		return -EIO;
+	if (snd_msnd_write_cfg(cfg, IREG_IO1_BASEHI, HIBYTE(io)))
+		return -EIO;
+	if (snd_msnd_write_cfg(cfg, IREG_IO1_BASELO, LOBYTE(io)))
+		return -EIO;
+	return 0;
+}
+
+static int __init snd_msnd_write_cfg_irq(int cfg, int num, WORD irq)
+{
+	if (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))
+		return -EIO;
+	if (snd_msnd_write_cfg(cfg, IREG_IRQ_NUMBER, LOBYTE(irq)))
+		return -EIO;
+	if (snd_msnd_write_cfg(cfg, IREG_IRQ_TYPE, IRQTYPE_EDGE))
+		return -EIO;
+	return 0;
+}
+
+static int __init snd_msnd_write_cfg_mem(int cfg, int num, int mem)
+{
+	WORD wmem;
+
+	mem >>= 8;
+	mem &= 0xfff;
+	wmem = (WORD)mem;
+	if (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))
+		return -EIO;
+	if (snd_msnd_write_cfg(cfg, IREG_MEMBASEHI, HIBYTE(wmem)))
+		return -EIO;
+	if (snd_msnd_write_cfg(cfg, IREG_MEMBASELO, LOBYTE(wmem)))
+		return -EIO;
+	if (wmem && snd_msnd_write_cfg(cfg, IREG_MEMCONTROL, (MEMTYPE_HIADDR | MEMTYPE_16BIT)))
+		return -EIO;
+	return 0;
+}
+
+static int __init snd_msnd_activate_logical(int cfg, int num)
+{
+	if (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))
+		return -EIO;
+	if (snd_msnd_write_cfg(cfg, IREG_ACTIVATE, LD_ACTIVATE))
+		return -EIO;
+	return 0;
+}
+
+static int __init snd_msnd_write_cfg_logical(int cfg, int num, WORD io0, WORD io1, WORD irq, int mem)
+{
+	if (snd_msnd_write_cfg(cfg, IREG_LOGDEVICE, num))
+		return -EIO;
+	if (snd_msnd_write_cfg_io0(cfg, num, io0))
+		return -EIO;
+	if (snd_msnd_write_cfg_io1(cfg, num, io1))
+		return -EIO;
+	if (snd_msnd_write_cfg_irq(cfg, num, irq))
+		return -EIO;
+	if (snd_msnd_write_cfg_mem(cfg, num, mem))
+		return -EIO;
+	if (snd_msnd_activate_logical(cfg, num))
+		return -EIO;
+	return 0;
+}
+
+typedef struct msnd_pinnacle_cfg_device {
+		WORD io0, io1, irq;
+		int mem;
+	} msnd_pinnacle_cfg_t[4];
+
+static int __init snd_msnd_pinnacle_cfg_devices(int cfg, int reset, msnd_pinnacle_cfg_t device)
+{
+	int i;
+
+	/* Reset devices if told to */
+	if (reset) {
+		printk(KERN_INFO LOGNAME ": Resetting all devices\n");
+		for (i = 0; i < 4; ++i)
+			if (snd_msnd_write_cfg_logical(cfg, i, 0, 0, 0, 0))
+				return -EIO;
+	}
+
+	/* Configure specified devices */
+	for (i = 0; i < 4; ++i) {
+
+		switch (i) {
+		case 0:		/* DSP */
+			if (!(device[i].io0 && device[i].irq && device[i].mem))
+				continue;
+			break;
+		case 1:		/* MPU */
+			if (!(device[i].io0 && device[i].irq))
+				continue;
+			printk(KERN_INFO LOGNAME
+			       ": Configuring MPU to I/O 0x%x IRQ %d\n",
+			       device[i].io0, device[i].irq);
+			break;
+		case 2:		/* IDE */
+			if (!(device[i].io0 && device[i].io1 && device[i].irq))
+				continue;
+			printk(KERN_INFO LOGNAME
+			       ": Configuring IDE to I/O 0x%x, 0x%x IRQ %d\n",
+			       device[i].io0, device[i].io1, device[i].irq);
+			break;
+		case 3:		/* Joystick */
+			if (!(device[i].io0))
+				continue;
+			printk(KERN_INFO LOGNAME
+			       ": Configuring joystick to I/O 0x%x\n",
+			       device[i].io0);
+			break;
+		}
+
+		/* Configure the device */
+		if (snd_msnd_write_cfg_logical(cfg, i, device[i].io0, device[i].io1, device[i].irq, device[i].mem))
+			return -EIO;
+	}
+
+	return 0;
+}
+#endif
+
+#ifdef MODULE
+MODULE_AUTHOR			("Karsten Wiese <annabellesgarden@yahoo.de>");
+MODULE_DESCRIPTION		("Turtle Beach " LONGNAME " Linux Driver");
+MODULE_LICENSE("GPL");
+
+
+MODULE_PARM			(snd_io, "i");
+MODULE_PARM			(snd_irq, "i");
+MODULE_PARM			(snd_mem, "i");
+MODULE_PARM			(snd_write_ndelay, "i");
+MODULE_PARM			(snd_calibrate_signal, "i");
+#ifndef MSND_CLASSIC
+MODULE_PARM			(snd_digital, "i");
+MODULE_PARM			(snd_cfg, "i");
+MODULE_PARM			(snd_reset, "i");
+MODULE_PARM			(snd_mpu_io, "i");
+MODULE_PARM			(snd_mpu_irq, "i");
+MODULE_PARM			(snd_ide_io0, "i");
+MODULE_PARM			(snd_ide_io1, "i");
+MODULE_PARM			(snd_ide_irq, "i");
+MODULE_PARM			(snd_joystick_io, "i");
+#endif
+
+static int snd_io __initdata =		-1;
+static int snd_irq __initdata =		-1;
+static int snd_mem __initdata =		-1;
+static int snd_write_ndelay __initdata =	-1;
+
+#ifndef MSND_CLASSIC
+//static int play_period_bytes __initdata =	DAP_BUFF_SIZE;
+
+/* Pinnacle/Fiji non-PnP Config Port */
+static int snd_cfg __initdata =		-1;
+
+/* Extra Peripheral Configuration */
+static int snd_reset __initdata = 0;
+static int snd_mpu_io __initdata = 0;
+static int snd_mpu_irq __initdata = 0;
+static int snd_ide_io0 __initdata = 0;
+static int snd_ide_io1 __initdata = 0;
+static int snd_ide_irq __initdata = 0;
+static int snd_joystick_io __initdata = 0;
+
+/* If we have the digital daugherboard... */
+static int snd_digital __initdata = 0;
+#endif
+
+static int snd_calibrate_signal __initdata = 0;
+
+#else /* not a module */
+
+static int snd_write_ndelay __initdata =	-1;
+
+#ifdef MSND_CLASSIC
+static int snd_io __initdata =		CONFIG_MSNDCLAS_IO;
+static int snd_irq __initdata =		CONFIG_MSNDCLAS_IRQ;
+static int snd_mem __initdata =		CONFIG_MSNDCLAS_MEM;
+#else /* Pinnacle/Fiji */
+
+static int snd_io __initdata =		CONFIG_MSNDPIN_IO;
+static int snd_irq __initdata =		CONFIG_MSNDPIN_IRQ;
+static int snd_mem __initdata =		CONFIG_MSNDPIN_MEM;
+
+/* Pinnacle/Fiji non-PnP Config Port */
+#ifdef CONFIG_MSNDPIN_NONPNP
+#  ifndef CONFIG_MSNDPIN_CFG
+#    define CONFIG_MSNDPIN_CFG		0x250
+#  endif
+#else
+#  ifdef CONFIG_MSNDPIN_CFG
+#    undef CONFIG_MSNDPIN_CFG
+#  endif
+#  define CONFIG_MSNDPIN_CFG		-1
+#endif
+static int snd_cfg __initdata =		CONFIG_MSNDPIN_CFG;
+/* If not a module, we don't need to bother with reset=1 */
+static int snd_reset;
+
+/* Extra Peripheral Configuration (Default: Disable) */
+#ifndef CONFIG_MSNDPIN_MPU_IO
+#  define CONFIG_MSNDPIN_MPU_IO		0
+#endif
+static int snd_mpu_io __initdata =		CONFIG_MSNDPIN_MPU_IO;
+
+#ifndef CONFIG_MSNDPIN_MPU_IRQ
+#  define CONFIG_MSNDPIN_MPU_IRQ	0
+#endif
+static int snd_mpu_irq __initdata =		CONFIG_MSNDPIN_MPU_IRQ;
+
+#ifndef CONFIG_MSNDPIN_IDE_IO0
+#  define CONFIG_MSNDPIN_IDE_IO0	0
+#endif
+static int snd_ide_io0 __initdata =		CONFIG_MSNDPIN_IDE_IO0;
+
+#ifndef CONFIG_MSNDPIN_IDE_IO1
+#  define CONFIG_MSNDPIN_IDE_IO1	0
+#endif
+static int snd_ide_io1 __initdata =		CONFIG_MSNDPIN_IDE_IO1;
+
+#ifndef CONFIG_MSNDPIN_IDE_IRQ
+#  define CONFIG_MSNDPIN_IDE_IRQ	0
+#endif
+static int snd_ide_irq __initdata =		CONFIG_MSNDPIN_IDE_IRQ;
+
+#ifndef CONFIG_MSNDPIN_JOYSTICK_IO
+#  define CONFIG_MSNDPIN_JOYSTICK_IO	0
+#endif
+static int snd_joystick_io __initdata =	CONFIG_MSNDPIN_JOYSTICK_IO;
+
+/* Have SPDIF (Digital) Daughterboard */
+#ifndef CONFIG_MSNDPIN_DIGITAL
+#  define CONFIG_MSNDPIN_DIGITAL	0
+#endif
+static int snd_digital __initdata =		CONFIG_MSNDPIN_DIGITAL;
+
+#endif /* MSND_CLASSIC */
+
+#ifndef CONFIG_MSND_CALSIGNAL
+#  define CONFIG_MSND_CALSIGNAL		0
+#endif
+static int
+snd_calibrate_signal __initdata =		CONFIG_MSND_CALSIGNAL;
+#endif /* MODULE */
+
+
+static int __init snd_msnd_init(void)
+{
+	int err;
+#ifndef MSND_CLASSIC
+	static msnd_pinnacle_cfg_t pinnacle_devs;
+#endif /* MSND_CLASSIC */
+
+	printk(KERN_INFO LOGNAME ": Turtle Beach " LONGNAME " Linux Driver Version "
+	       VERSION ", Copyright (C) 2002 Karsten Wiese 1998 Andrew Veliath\n");
+
+	if (snd_io == -1 || snd_irq == -1 || snd_mem == -1)
+		printk(KERN_WARNING LOGNAME ": snd_io, snd_irq and snd_mem must be set\n");
+
+#ifdef MSND_CLASSIC
+	if (snd_io == -1 ||
+	    !(snd_io == 0x290 ||
+	      snd_io == 0x260 ||
+	      snd_io == 0x250 ||
+	      snd_io == 0x240 ||
+	      snd_io == 0x230 ||
+	      snd_io == 0x220 ||
+	      snd_io == 0x210 ||
+	      snd_io == 0x3e0)) {
+		printk(KERN_ERR LOGNAME ": \"snd_io\" - DSP I/O base must be set to 0x210, 0x220, 0x230, 0x240, 0x250, 0x260, 0x290, or 0x3E0\n");
+		return -EINVAL;
+	}
+#else
+	if (snd_io == -1 ||
+		snd_io < 0x100 ||
+		snd_io > 0x3e0 ||
+		(snd_io % 0x10) != 0) {
+			printk(KERN_ERR LOGNAME ": \"snd_io\" - DSP I/O base must within the range 0x100 to 0x3E0 and must be evenly divisible by 0x10\n");
+			return -EINVAL;
+	}
+#endif /* MSND_CLASSIC */
+
+	if (snd_irq == -1 ||
+	    !(snd_irq == 5 ||
+	      snd_irq == 7 ||
+	      snd_irq == 9 ||
+	      snd_irq == 10 ||
+	      snd_irq == 11 ||
+	      snd_irq == 12)) {
+		printk(KERN_ERR LOGNAME ": \"snd_irq\" - must be set to 5, 7, 9, 10, 11 or 12\n");
+		return -EINVAL;
+	}
+
+	if (snd_mem == -1 ||
+	    !(snd_mem == 0xb0000 ||
+	      snd_mem == 0xc8000 ||
+	      snd_mem == 0xd0000 ||
+	      snd_mem == 0xd8000 ||
+	      snd_mem == 0xe0000 ||
+	      snd_mem == 0xe8000)) {
+		printk(KERN_ERR LOGNAME ": \"snd_mem\" - must be set to "
+		       "0xb0000, 0xc8000, 0xd0000, 0xd8000, 0xe0000 or 0xe8000\n");
+		return -EINVAL;
+	}
+
+#ifdef MSND_CLASSIC
+	switch (snd_irq) {
+	case 5: dev.irqid = HPIRQ_5; break;
+	case 7: dev.irqid = HPIRQ_7; break;
+	case 9: dev.irqid = HPIRQ_9; break;
+	case 10: dev.irqid = HPIRQ_10; break;
+	case 11: dev.irqid = HPIRQ_11; break;
+	case 12: dev.irqid = HPIRQ_12; break;
+	}
+
+	switch (snd_mem) {
+	case 0xb0000: dev.memid = HPMEM_B000; break;
+	case 0xc8000: dev.memid = HPMEM_C800; break;
+	case 0xd0000: dev.memid = HPMEM_D000; break;
+	case 0xd8000: dev.memid = HPMEM_D800; break;
+	case 0xe0000: dev.memid = HPMEM_E000; break;
+	case 0xe8000: dev.memid = HPMEM_E800; break;
+	}
+#else
+	if (snd_cfg == -1) {
+		printk(KERN_INFO LOGNAME ": Assuming PnP mode\n");
+	} else if (snd_cfg != 0x250 && snd_cfg != 0x260 && snd_cfg != 0x270) {
+		printk(KERN_INFO LOGNAME ": Config port must be 0x250, 0x260 or 0x270 (or unspecified for PnP mode)\n");
+		return -EINVAL;
+	} else {
+		printk(KERN_INFO LOGNAME ": Non-PnP mode: configuring at port 0x%x\n", snd_cfg);
+
+		/* DSP */
+		pinnacle_devs[0].io0 = snd_io;
+		pinnacle_devs[0].irq = snd_irq;
+		pinnacle_devs[0].mem = snd_mem;
+
+		/* The following are Pinnacle specific */
+
+		/* MPU */
+		pinnacle_devs[1].io0 = snd_mpu_io;
+		pinnacle_devs[1].irq = snd_mpu_irq;
+
+		/* IDE */
+		pinnacle_devs[2].io0 = snd_ide_io0;
+		pinnacle_devs[2].io1 = snd_ide_io1;
+		pinnacle_devs[2].irq = snd_ide_irq;
+
+		/* Joystick */
+		pinnacle_devs[3].io0 = snd_joystick_io;
+
+		if (check_region(snd_cfg, 2)) {
+			printk(KERN_ERR LOGNAME ": Config port 0x%x conflict\n", snd_cfg);
+			return -EIO;
+		}
+
+		request_region(snd_cfg, 2, "Pinnacle/Fiji Config");
+		if (snd_msnd_pinnacle_cfg_devices(snd_cfg, snd_reset, pinnacle_devs)) {
+			printk(KERN_ERR LOGNAME ": Device configuration error\n");
+			release_region(snd_cfg, 2);
+			return -EIO;
+		}
+		release_region(snd_cfg, 2);
+	}
+	
+#endif /* MSND_CLASSIC */
+
+	set_default_audio_parameters();
+#ifdef MSND_CLASSIC
+	dev.type = msndClassic;
+#else
+	dev.type = msndPinnacle;
+#endif
+/*	snd_msnd_playback.buffer_bytes_max = 3 * (
+		snd_msnd_playback.period_bytes_max =
+			snd_msnd_playback.period_bytes_min =
+				dev.play_period_bytes = play_period_bytes
+	);
+	printk(KERN_INFO LOGNAME ": play_period_bytes=0x%X\n", dev.play_period_bytes);
+*/
+	dev.io = snd_io;
+	dev.numio = DSP_NUMIO;
+	dev.irq = snd_irq;
+	dev.base = snd_mem;
+
+	dev.calibrate_signal = snd_calibrate_signal ? 1 : 0;
+	dev.recsrc = 0;
+	dev.dspq_data_buff = DSPQ_DATA_BUFF;
+	dev.dspq_buff_size = DSPQ_BUFF_SIZE;
+	if (snd_write_ndelay == -1)
+		snd_write_ndelay = CONFIG_MSND_WRITE_NDELAY;
+	if (snd_write_ndelay)
+		clear_bit(F_DISABLE_WRITE_NDELAY, &dev.flags);
+	else
+		set_bit(F_DISABLE_WRITE_NDELAY, &dev.flags);
+#ifndef MSND_CLASSIC
+	if (snd_digital)
+		set_bit(F_HAVEDIGITAL, &dev.flags);
+#endif
+	spin_lock_init(&dev.lock);
+	if ((err = snd_msnd_probe()) < 0) {
+		printk(KERN_ERR LOGNAME ": Probe failed\n");
+		return err;
+	}
+
+	if ((err = snd_msnd_attach()) < 0) {
+		printk(KERN_ERR LOGNAME ": Attach failed\n");
+		return err;
+	}
+
+	return 0;
+}
+
+static void __exit snd_msnd_cleanup(void)
+{
+	snd_msnd_unload();
+//	snd_free_pages( dev.mappedbase, 0x8000);
+}
+
+module_init(snd_msnd_init);
+module_exit(snd_msnd_cleanup);
+
+EXPORT_NO_SYMBOLS;
--- /dev/null	2002-06-21 03:44:19.000000000 +0200
+++ linux/sound/isa/msnd/msnd_pinnacle.h	2002-07-08 12:14:27.000000000 +0200
@@ -0,0 +1,255 @@
+/*********************************************************************
+ *
+ * msnd_pinnacle.h
+ *
+ * Turtle Beach MultiSound Sound Card Driver for Linux
+ *
+ * Some parts of this header file were derived from the Turtle Beach
+ * MultiSound Driver Development Kit.
+ *
+ * Copyright (C) 1998 Andrew Veliath
+ * Copyright (C) 1993 Turtle Beach Systems, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * $Id: msnd_pinnacle.h,v 1.11 1999/03/21 17:36:09 andrewtv Exp $
+ *
+ ********************************************************************/
+#ifndef __MSND_PINNACLE_H
+#define __MSND_PINNACLE_H
+
+#include <linux/config.h>
+
+#define DSP_NUMIO				0x08
+
+#define IREG_LOGDEVICE				0x07
+#define IREG_ACTIVATE				0x30
+#define LD_ACTIVATE				0x01
+#define LD_DISACTIVATE				0x00
+#define IREG_EECONTROL				0x3F
+#define IREG_MEMBASEHI				0x40
+#define IREG_MEMBASELO				0x41
+#define IREG_MEMCONTROL				0x42
+#define IREG_MEMRANGEHI				0x43
+#define IREG_MEMRANGELO				0x44
+#define MEMTYPE_8BIT				0x00
+#define MEMTYPE_16BIT				0x02
+#define MEMTYPE_RANGE				0x00
+#define MEMTYPE_HIADDR				0x01
+#define IREG_IO0_BASEHI				0x60
+#define IREG_IO0_BASELO				0x61
+#define IREG_IO1_BASEHI				0x62
+#define IREG_IO1_BASELO				0x63
+#define IREG_IRQ_NUMBER				0x70
+#define IREG_IRQ_TYPE				0x71
+#define IRQTYPE_HIGH				0x02
+#define IRQTYPE_LOW				0x00
+#define IRQTYPE_LEVEL				0x01
+#define IRQTYPE_EDGE				0x00
+
+#define	HP_DSPR					0x04
+#define	HP_BLKS					0x04
+
+#define HPDSPRESET_OFF				2
+#define HPDSPRESET_ON				0
+
+#define HPBLKSEL_0				2
+#define HPBLKSEL_1				3
+
+#define	HIMT_DAT_OFF				0x03
+
+#define	HIDSP_PLAY_UNDER			0x00
+#define	HIDSP_INT_PLAY_UNDER			0x01
+#define	HIDSP_SSI_TX_UNDER  			0x02
+#define HIDSP_RECQ_OVERFLOW			0x08
+#define HIDSP_INT_RECORD_OVER			0x09
+#define HIDSP_SSI_RX_OVERFLOW			0x0a
+
+#define	HIDSP_MIDI_IN_OVER			0x10
+
+#define	HIDSP_MIDI_FRAME_ERR			0x11
+#define	HIDSP_MIDI_PARITY_ERR			0x12
+#define	HIDSP_MIDI_OVERRUN_ERR			0x13
+
+#define HIDSP_INPUT_CLIPPING			0x20
+#define	HIDSP_MIX_CLIPPING			0x30
+#define HIDSP_DAT_IN_OFF			0x21
+
+#define	HDEXAR_SET_ANA_IN			0
+#define	HDEXAR_CLEAR_PEAKS			1
+#define	HDEXAR_IN_SET_POTS			2
+#define	HDEXAR_AUX_SET_POTS			3
+#define	HDEXAR_CAL_A_TO_D			4
+#define	HDEXAR_RD_EXT_DSP_BITS			5
+
+#define	HDEXAR_SET_SYNTH_IN			4
+#define	HDEXAR_READ_DAT_IN			5
+#define	HDEXAR_MIC_SET_POTS			6
+#define	HDEXAR_SET_DAT_IN			7
+
+#define HDEXAR_SET_SYNTH_48			8
+#define HDEXAR_SET_SYNTH_44			9
+
+#define TIME_PRO_RESET_DONE			0x028A
+#define TIME_PRO_SYSEX				0x001E
+#define TIME_PRO_RESET				0x0032
+
+#define AGND					0x01
+#define SIGNAL					0x02
+
+#define EXT_DSP_BIT_DCAL			0x0001
+#define EXT_DSP_BIT_MIDI_CON			0x0002
+
+#define BUFFSIZE				0x8000
+#define HOSTQ_SIZE				0x40
+
+#define SRAM_CNTL_START				0x7F00
+#define SMA_STRUCT_START			0x7F40
+
+#define DAP_BUFF_SIZE				0x2400
+#define DAR_BUFF_SIZE				0x1000
+
+#define DAPQ_STRUCT_SIZE			0x10
+#define DARQ_STRUCT_SIZE			0x10
+#define DAPQ_BUFF_SIZE				(3 * 0x10)
+#define DARQ_BUFF_SIZE				(3 * 0x10)
+#define MODQ_BUFF_SIZE				0x400
+#define MIDQ_BUFF_SIZE				0x800
+#define DSPQ_BUFF_SIZE				0x5A0
+
+#define DAPQ_DATA_BUFF				0x6C00
+#define DARQ_DATA_BUFF				0x6C30
+#define MODQ_DATA_BUFF				0x6C60
+#define MIDQ_DATA_BUFF				0x7060
+#define DSPQ_DATA_BUFF				0x7860
+
+#define DAPQ_OFFSET				SRAM_CNTL_START
+#define DARQ_OFFSET				(SRAM_CNTL_START + 0x08)
+#define MODQ_OFFSET				(SRAM_CNTL_START + 0x10)
+#define MIDQ_OFFSET				(SRAM_CNTL_START + 0x18)
+#define DSPQ_OFFSET				(SRAM_CNTL_START + 0x20)
+
+#define MOP_WAVEHDR				0
+#define MOP_EXTOUT				1
+#define MOP_HWINIT				0xfe
+#define MOP_NONE				0xff
+#define MOP_MAX					1
+
+#define MIP_EXTIN				0
+#define MIP_WAVEHDR				1
+#define MIP_HWINIT				0xfe
+#define MIP_MAX					1
+
+/* Pinnacle/Fiji SMA Common Data */
+#define SMA_wCurrPlayBytes			0x0000
+#define SMA_wCurrRecordBytes			0x0002
+#define SMA_wCurrPlayVolLeft			0x0004
+#define SMA_wCurrPlayVolRight			0x0006
+#define SMA_wCurrInVolLeft			0x0008
+#define SMA_wCurrInVolRight			0x000a
+#define SMA_wCurrMHdrVolLeft			0x000c
+#define SMA_wCurrMHdrVolRight			0x000e
+#define SMA_dwCurrPlayPitch			0x0010
+#define SMA_dwCurrPlayRate			0x0014
+#define SMA_wCurrMIDIIOPatch			0x0018
+#define SMA_wCurrPlayFormat			0x001a
+#define SMA_wCurrPlaySampleSize			0x001c
+#define SMA_wCurrPlayChannels			0x001e
+#define SMA_wCurrPlaySampleRate			0x0020
+#define SMA_wCurrRecordFormat			0x0022
+#define SMA_wCurrRecordSampleSize		0x0024
+#define SMA_wCurrRecordChannels			0x0026
+#define SMA_wCurrRecordSampleRate		0x0028
+#define SMA_wCurrDSPStatusFlags			0x002a
+#define SMA_wCurrHostStatusFlags		0x002c
+#define SMA_wCurrInputTagBits			0x002e
+#define SMA_wCurrLeftPeak			0x0030
+#define SMA_wCurrRightPeak			0x0032
+#define SMA_bMicPotPosLeft			0x0034
+#define SMA_bMicPotPosRight			0x0035
+#define SMA_bMicPotMaxLeft			0x0036
+#define SMA_bMicPotMaxRight			0x0037
+#define SMA_bInPotPosLeft			0x0038
+#define SMA_bInPotPosRight			0x0039
+#define SMA_bAuxPotPosLeft			0x003a
+#define SMA_bAuxPotPosRight			0x003b
+#define SMA_bInPotMaxLeft			0x003c
+#define SMA_bInPotMaxRight			0x003d
+#define SMA_bAuxPotMaxLeft			0x003e
+#define SMA_bAuxPotMaxRight			0x003f
+#define SMA_bInPotMaxMethod			0x0040
+#define SMA_bAuxPotMaxMethod			0x0041
+#define SMA_wCurrMastVolLeft			0x0042
+#define SMA_wCurrMastVolRight			0x0044
+#define SMA_wCalFreqAtoD			0x0046
+#define SMA_wCurrAuxVolLeft			0x0048
+#define SMA_wCurrAuxVolRight			0x004a
+#define SMA_wCurrPlay1VolLeft			0x004c
+#define SMA_wCurrPlay1VolRight			0x004e
+#define SMA_wCurrPlay2VolLeft			0x0050
+#define SMA_wCurrPlay2VolRight			0x0052
+#define SMA_wCurrPlay3VolLeft			0x0054
+#define SMA_wCurrPlay3VolRight			0x0056
+#define SMA_wCurrPlay4VolLeft			0x0058
+#define SMA_wCurrPlay4VolRight			0x005a
+#define SMA_wCurrPlay1PeakLeft			0x005c
+#define SMA_wCurrPlay1PeakRight			0x005e
+#define SMA_wCurrPlay2PeakLeft			0x0060
+#define SMA_wCurrPlay2PeakRight			0x0062
+#define SMA_wCurrPlay3PeakLeft			0x0064
+#define SMA_wCurrPlay3PeakRight			0x0066
+#define SMA_wCurrPlay4PeakLeft			0x0068
+#define SMA_wCurrPlay4PeakRight			0x006a
+#define SMA_wCurrPlayPeakLeft			0x006c
+#define SMA_wCurrPlayPeakRight			0x006e
+#define SMA_wCurrDATSR				0x0070
+#define SMA_wCurrDATRXCHNL			0x0072
+#define SMA_wCurrDATTXCHNL			0x0074
+#define SMA_wCurrDATRXRate			0x0076
+#define SMA_dwDSPPlayCount			0x0078
+#define SMA__size				0x007c
+
+#ifdef HAVE_DSPCODEH
+#  include "pndsperm.c"
+#  include "pndspini.c"
+#  define PERMCODE		pndsperm
+#  define INITCODE		pndspini
+#  define PERMCODESIZE		sizeof(pndsperm)
+#  define INITCODESIZE		sizeof(pndspini)
+#else
+#  ifndef CONFIG_MSNDPIN_INIT_FILE
+#    define CONFIG_MSNDPIN_INIT_FILE				\
+				"/etc/sound/pndspini.bin"
+#  endif
+#  ifndef CONFIG_MSNDPIN_PERM_FILE
+#    define CONFIG_MSNDPIN_PERM_FILE				\
+				"/etc/sound/pndsperm.bin"
+#  endif
+#  define PERMCODEFILE		CONFIG_MSNDPIN_PERM_FILE
+#  define INITCODEFILE		CONFIG_MSNDPIN_INIT_FILE
+#  define PERMCODE		dspini
+#  define INITCODE		permini
+#  define PERMCODESIZE		sizeof_dspini
+#  define INITCODESIZE		sizeof_permini
+#endif
+#define LONGNAME		"MultiSound (Pinnacle/Fiji)"
+
+int snd_msnd_send_dsp_cmd_chk(multisound_dev_t *dev, register BYTE cmd);
+unsigned long snd_msndmix_force_recsrc( multisound_dev_t * dev, int recsrc);
+int __init snd_msndmix_new( multisound_dev_t * dummy);
+void snd_msndmix_setup( multisound_dev_t * dev);
+
+
+#endif /* __MSND_PINNACLE_H */
--- /dev/null	2002-06-21 03:44:19.000000000 +0200
+++ linux/sound/isa/msnd/msnd_pinnacle_mixer.c	2002-07-08 12:14:27.000000000 +0200
@@ -0,0 +1,341 @@
+/***************************************************************************
+                          msnd_pinnacle_mixer.c  -  description
+                             -------------------
+    begin                : Fre Jun 7 2002
+    copyright            : (C) 2002 by karsten wiese
+    email                : annabellesgarden@yahoo.de
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <sound/driver.h>
+#include <sound/core.h>
+#include <sound/control.h>
+#include "msnd.h"
+#include "msnd_pinnacle.h"
+
+
+#define MSND_MIXER_VOLUME	0
+#define MSND_MIXER_PCM		1
+#define MSND_MIXER_AUX		2	/* Input source 1  (aux1) */
+#define MSND_MIXER_IMIX		3	/*  Recording monitor  */
+#define MSND_MIXER_SYNTH	4
+#define MSND_MIXER_SPEAKER	5
+#define MSND_MIXER_LINE		6
+#define MSND_MIXER_MIC		7
+#define MSND_MIXER_RECLEV	11	/* Recording level */
+#define MSND_MIXER_IGAIN	12	/* Input gain */
+#define MSND_MIXER_OGAIN	13	/* Output gain */
+#define MSND_MIXER_DIGITAL	17	/* Digital (input) 1 */
+
+/*	Device mask bits	*/
+
+#define MSND_MASK_VOLUME	(1 << MSND_MIXER_VOLUME)
+#define MSND_MASK_SYNTH		(1 << MSND_MIXER_SYNTH)
+#define MSND_MASK_PCM		(1 << MSND_MIXER_PCM)
+#define MSND_MASK_SPEAKER	(1 << MSND_MIXER_SPEAKER)
+#define MSND_MASK_LINE		(1 << MSND_MIXER_LINE)
+#define MSND_MASK_MIC		(1 << MSND_MIXER_MIC)
+#define MSND_MASK_IMIX		(1 << MSND_MIXER_IMIX)
+#define MSND_MASK_RECLEV	(1 << MSND_MIXER_RECLEV)
+#define MSND_MASK_IGAIN		(1 << MSND_MIXER_IGAIN)
+#define MSND_MASK_OGAIN		(1 << MSND_MIXER_OGAIN)
+#define MSND_MASK_AUX		(1 << MSND_MIXER_AUX)
+#define MSND_MASK_DIGITAL	(1 << MSND_MIXER_DIGITAL)
+
+
+
+
+
+static int snd_msndmix_info_mux(snd_kcontrol_t *kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	static char *texts[3] = {
+		"Analog", "SPDIF", "MASS"
+	};
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = 3;
+	if (uinfo->value.enumerated.item > 2)
+		uinfo->value.enumerated.item = 2;
+	strcpy(uinfo->value.enumerated.name, texts[uinfo->value.enumerated.item]);
+	return 0;
+}
+
+static int snd_msndmix_get_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	multisound_dev_t *	msnd =	_snd_kcontrol_chip(kcontrol);
+	ucontrol->value.enumerated.item[0] = 0;
+
+/*	if (msnd->recsrc & MSND_MASK_IMIX) {             this is the default
+		ucontrol->value.enumerated.item[0] = 0;
+	}
+	else */if (msnd->recsrc & MSND_MASK_SYNTH) {
+		ucontrol->value.enumerated.item[0] = 2;
+	}
+	else if ((msnd->recsrc & MSND_MASK_DIGITAL) && test_bit(F_HAVEDIGITAL, &msnd->flags)) {
+		ucontrol->value.enumerated.item[0] = 1;
+	}
+
+	return 0;
+}
+
+
+static int snd_msndmix_set_mux( multisound_dev_t * msnd, int val)
+{
+	unsigned newrecsrc;
+	int change;
+	unsigned char msndbyte;
+	
+	//snd_printd( "   snd_msndmix_set_mux(, %i)\n", val);
+	switch ( val){
+	case 0:
+		newrecsrc = MSND_MASK_IMIX;
+		msndbyte = HDEXAR_SET_ANA_IN;
+		break;
+	case 1:
+		newrecsrc = MSND_MASK_DIGITAL;
+		msndbyte = HDEXAR_SET_DAT_IN;
+		break;
+	case 2:
+		newrecsrc = MSND_MASK_SYNTH;
+		msndbyte = HDEXAR_SET_SYNTH_IN;
+		break;
+	default:
+		return -EINVAL;
+	}
+	if ( ( change  = ( newrecsrc != msnd->recsrc))){
+		if ( 0 == snd_msnd_send_word( msnd, 0, 0, msndbyte))
+			if( 0 == snd_msnd_send_dsp_cmd_chk( msnd, HDEX_AUX_REQ))
+				msnd->recsrc = newrecsrc;
+	}
+	return change;
+}
+
+
+static int snd_msndmix_put_mux(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	multisound_dev_t *	msnd =	_snd_kcontrol_chip( kcontrol);
+	return snd_msndmix_set_mux( msnd, ucontrol->value.enumerated.item[ 0]);
+}
+
+
+static int snd_msndmix_volume_info(snd_kcontrol_t * kcontrol, snd_ctl_elem_info_t * uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 100;
+	return 0;
+}
+
+static int snd_msndmix_volume_get(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	multisound_dev_t *	msnd =	_snd_kcontrol_chip(kcontrol);
+	int			addr =	kcontrol->private_value;
+
+	ucontrol->value.integer.value[0] = ( msnd->left_levels[ addr] * 100) / 0xFFFF;
+	ucontrol->value.integer.value[1] = ( msnd->right_levels[ addr] * 100) / 0xFFFF;
+	return 0;
+}
+
+
+#define update_volm(a,b)						\
+	isa_writew((dev->left_levels[a] >> 1) *				\
+	       isa_readw(dev->SMA + SMA_wCurrMastVolLeft) / 0xffff,	\
+	       dev->SMA + SMA_##b##Left);				\
+	isa_writew((dev->right_levels[a] >> 1)  *			\
+	       isa_readw(dev->SMA + SMA_wCurrMastVolRight) / 0xffff,	\
+	       dev->SMA + SMA_##b##Right);
+
+#define update_potm(d,s,ar)						\
+	isa_writeb((dev->left_levels[d] >> 8) *				\
+	       isa_readw(dev->SMA + SMA_wCurrMastVolLeft) / 0xffff,	\
+	       dev->SMA + SMA_##s##Left);				\
+	isa_writeb((dev->right_levels[d] >> 8) *				\
+	       isa_readw(dev->SMA + SMA_wCurrMastVolRight) / 0xffff,	\
+	       dev->SMA + SMA_##s##Right);				\
+	if (snd_msnd_send_word( dev, 0, 0, ar) == 0)			\
+		snd_msnd_send_dsp_cmd_chk( dev, HDEX_AUX_REQ);
+
+#define update_pot(d,s,ar)				\
+	isa_writeb(dev->left_levels[d] >> 8,		\
+	       dev->SMA + SMA_##s##Left);		\
+	isa_writeb(dev->right_levels[d] >> 8,		\
+	       dev->SMA + SMA_##s##Right);		\
+	if (snd_msnd_send_word( dev, 0, 0, ar) == 0)	\
+		snd_msnd_send_dsp_cmd_chk( dev, HDEX_AUX_REQ);
+
+
+static int snd_msndmix_set( multisound_dev_t * dev, int d, int left, int right)
+{
+	int bLeft, bRight;
+	int wLeft, wRight;
+	int updatemaster = 0;
+
+	//snd_printd( "mixer_set( multisound_dev_t * %X, d=%i, left=%i, right=%i\n",
+	//		(unsigned)dev, d, left, right);
+
+	if( d >= LEVEL_ENTRIES)
+		return -EINVAL;
+
+	bLeft = left * 0xff / 100;
+	wLeft = left * 0xffff / 100;
+
+	bRight = right * 0xff / 100;
+	wRight = right * 0xffff / 100;
+
+	dev->left_levels[d] = wLeft;
+	dev->right_levels[d] = wRight;
+
+	switch (d) {
+		/* master volume unscaled controls */
+	case MSND_MIXER_LINE:			/* line pot control */
+		/* scaled by IMIX in digital mix */
+		isa_writeb(bLeft, dev->SMA + SMA_bInPotPosLeft);
+		isa_writeb(bRight, dev->SMA + SMA_bInPotPosRight);
+		if (snd_msnd_send_word( dev, 0, 0, HDEXAR_IN_SET_POTS) == 0)
+			snd_msnd_send_dsp_cmd_chk( dev, HDEX_AUX_REQ);
+		break;
+#ifndef MSND_CLASSIC
+	case MSND_MIXER_MIC:			/* mic pot control */
+		/* scaled by IMIX in digital mix */
+		isa_writeb(bLeft, dev->SMA + SMA_bMicPotPosLeft);
+		isa_writeb(bRight, dev->SMA + SMA_bMicPotPosRight);
+		if (snd_msnd_send_word( dev, 0, 0, HDEXAR_MIC_SET_POTS) == 0)
+			snd_msnd_send_dsp_cmd_chk( dev, HDEX_AUX_REQ);
+		break;
+#endif
+	case MSND_MIXER_VOLUME:		/* master volume */
+		isa_writew(wLeft, dev->SMA + SMA_wCurrMastVolLeft);
+		isa_writew(wRight, dev->SMA + SMA_wCurrMastVolRight);
+		/* fall through */
+
+	case MSND_MIXER_AUX:			/* aux pot control */
+		/* scaled by master volume */
+		/* fall through */
+
+		/* digital controls */
+	case MSND_MIXER_SYNTH:			/* synth vol (dsp mix) */
+	case MSND_MIXER_PCM:			/* pcm vol (dsp mix) */
+	case MSND_MIXER_IMIX:			/* input monitor (dsp mix) */
+		/* scaled by master volume */
+		updatemaster = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	if (updatemaster) {
+		/* update master volume scaled controls */
+		update_volm(MSND_MIXER_PCM, wCurrPlayVol);
+		update_volm(MSND_MIXER_IMIX, wCurrInVol);
+#ifndef MSND_CLASSIC
+		update_volm(MSND_MIXER_SYNTH, wCurrMHdrVol);
+#endif
+		update_potm(MSND_MIXER_AUX, bAuxPotPos, HDEXAR_AUX_SET_POTS);
+	}
+
+	return 0;
+}
+
+
+static int snd_msndmix_volume_put(snd_kcontrol_t * kcontrol, snd_ctl_elem_value_t * ucontrol)
+{
+	multisound_dev_t *msnd = _snd_kcontrol_chip(kcontrol);
+	int change, addr = kcontrol->private_value;
+	int left, right;
+	// unsigned long flags;
+	//snd_printd( "snd_msndmix_volume_put( addr=%i, l=%i, r=%i)\n", addr, (int)ucontrol->value.integer.value[0], (int)ucontrol->value.integer.value[1]);
+
+	left = ucontrol->value.integer.value[0] % 101;
+	right = ucontrol->value.integer.value[1] % 101;
+	// spin_lock_irqsave(&msnd->mixer_lock, flags);
+	change = 	msnd->left_levels[ addr] != left
+		||      msnd->right_levels[ addr] != right;
+	snd_msndmix_set( msnd, addr, left, right);
+	// spin_unlock__irqrestore(&msnd->mixer_lock, flags);
+	return change;
+}
+
+
+#define DUMMY_VOLUME(xname, xindex, addr) \
+{ iface: SNDRV_CTL_ELEM_IFACE_MIXER, name: xname, index: xindex, \
+  info: snd_msndmix_volume_info, \
+  get: snd_msndmix_volume_get, put: snd_msndmix_volume_put, \
+  private_value: addr }
+
+
+#define MSND_CONTROLS (sizeof(snd_msnd_controls)/sizeof(snd_kcontrol_new_t))
+
+static snd_kcontrol_new_t snd_msnd_controls[] = {
+DUMMY_VOLUME(	"Master Volume",0, MSND_MIXER_VOLUME),
+DUMMY_VOLUME(	"PCM Volume",	0, MSND_MIXER_PCM),
+DUMMY_VOLUME(	"Aux Volume",	0, MSND_MIXER_AUX),
+DUMMY_VOLUME(	"Line Volume",	0, MSND_MIXER_LINE),
+DUMMY_VOLUME(	"Mic Volume",	0, MSND_MIXER_MIC),
+DUMMY_VOLUME(	"Monitor",	0, MSND_MIXER_IMIX),
+{
+	iface: SNDRV_CTL_ELEM_IFACE_MIXER,
+	name: "Capture Source",
+	info: snd_msndmix_info_mux,
+	get: snd_msndmix_get_mux,
+	put: snd_msndmix_put_mux,
+}
+};
+
+
+
+int __init snd_msndmix_new( multisound_dev_t * msnd)
+{
+	snd_card_t *card = msnd->card;
+	int idx, err;
+
+	snd_assert(msnd != NULL, return -EINVAL);
+	// spin_lock_init(&msnd->mixer_lock);
+	strcpy(card->mixername, "MSND Pinnacle Mixer");
+
+	for (idx = 0; idx < MSND_CONTROLS; idx++)
+		if ( ( err = snd_ctl_add( card, snd_ctl_new1( snd_msnd_controls + idx, msnd))) < 0)
+			return err;
+
+#ifndef MSND_CLASSIC
+	//	snd_msndmix_force_recsrc( msnd, 0);
+#endif
+
+	return 0;
+}
+
+
+
+void snd_msndmix_setup( multisound_dev_t * dev)
+{
+	update_pot(MSND_MIXER_LINE, bInPotPos, HDEXAR_IN_SET_POTS);
+	update_potm(MSND_MIXER_AUX, bAuxPotPos, HDEXAR_AUX_SET_POTS);
+	update_volm(MSND_MIXER_PCM, wCurrPlayVol);
+	update_volm(MSND_MIXER_IMIX, wCurrInVol);
+#ifndef MSND_CLASSIC
+	update_pot(MSND_MIXER_MIC, bMicPotPos, HDEXAR_MIC_SET_POTS);
+	update_volm(MSND_MIXER_SYNTH, wCurrMHdrVol);
+#endif
+
+}
+
+
+unsigned long snd_msndmix_force_recsrc( multisound_dev_t * dev, int recsrc)
+{
+//	snd_msndmix_set( dev, MSND_MIXER_VOLUME, 100, 100);
+//	snd_msndmix_set( dev, MSND_MIXER_LINE, 70, 70);
+//	snd_msndmix_set( dev, MSND_MIXER_IMIX, 100, 100);
+	dev->recsrc = -1;
+	return snd_msndmix_set_mux( dev, recsrc);
+}
+
+
--- /dev/null	2002-06-21 03:44:19.000000000 +0200
+++ linux/sound/isa/msnd/sintable.h	2002-07-08 12:14:27.000000000 +0200
@@ -0,0 +1,72 @@
+0x0000, 0x00B2, 0x0165, 0x0218, 0x02CA, 0x037D, 0x0430, 0x04E2, 0x0595, 0x0647, 0x06FA, 0x07AC, 0x085F, 0x0911, 0x09C3, 0x0A75, 
+0x0B27, 0x0BD9, 0x0C8B, 0x0D3D, 0x0DEF, 0x0EA0, 0x0F52, 0x1003, 0x10B4, 0x1166, 0x1217, 0x12C7, 0x1378, 0x1429, 0x14D9, 0x1589, 
+0x1639, 0x16E9, 0x1799, 0x1849, 0x18F8, 0x19A7, 0x1A56, 0x1B05, 0x1BB4, 0x1C62, 0x1D10, 0x1DBE, 0x1E6C, 0x1F19, 0x1FC6, 0x2073, 
+0x2120, 0x21CD, 0x2279, 0x2325, 0x23D1, 0x247C, 0x2527, 0x25D2, 0x267D, 0x2727, 0x27D1, 0x287B, 0x2924, 0x29CD, 0x2A76, 0x2B1E, 
+0x2BC6, 0x2C6E, 0x2D16, 0x2DBD, 0x2E64, 0x2F0A, 0x2FB0, 0x3056, 0x30FB, 0x31A0, 0x3244, 0x32E9, 0x338C, 0x3430, 0x34D3, 0x3575, 
+0x3617, 0x36B9, 0x375B, 0x37FB, 0x389C, 0x393C, 0x39DC, 0x3A7B, 0x3B1A, 0x3BB8, 0x3C56, 0x3CF3, 0x3D90, 0x3E2D, 0x3EC8, 0x3F64, 
+0x3FFF, 0x409A, 0x4134, 0x41CD, 0x4266, 0x42FF, 0x4397, 0x442E, 0x44C5, 0x455C, 0x45F2, 0x4687, 0x471C, 0x47B0, 0x4844, 0x48D7, 
+0x496A, 0x49FC, 0x4A8E, 0x4B1F, 0x4BAF, 0x4C3F, 0x4CCE, 0x4D5D, 0x4DEB, 0x4E78, 0x4F05, 0x4F91, 0x501D, 0x50A8, 0x5133, 0x51BD, 
+0x5246, 0x52CE, 0x5356, 0x53DE, 0x5464, 0x54EA, 0x5570, 0x55F4, 0x5679, 0x56FC, 0x577F, 0x5801, 0x5882, 0x5903, 0x5983, 0x5A03, 
+0x5A81, 0x5AFF, 0x5B7D, 0x5BF9, 0x5C75, 0x5CF0, 0x5D6B, 0x5DE5, 0x5E5E, 0x5ED6, 0x5F4E, 0x5FC5, 0x603B, 0x60B1, 0x6125, 0x6199, 
+0x620C, 0x627F, 0x62F1, 0x6362, 0x63D2, 0x6441, 0x64B0, 0x651E, 0x658B, 0x65F8, 0x6663, 0x66CE, 0x6738, 0x67A2, 0x680A, 0x6872, 
+0x68D9, 0x693F, 0x69A4, 0x6A09, 0x6A6C, 0x6ACF, 0x6B31, 0x6B92, 0x6BF3, 0x6C53, 0x6CB1, 0x6D0F, 0x6D6C, 0x6DC9, 0x6E24, 0x6E7F, 
+0x6ED9, 0x6F31, 0x6F8A, 0x6FE1, 0x7037, 0x708D, 0x70E1, 0x7135, 0x7188, 0x71DA, 0x722B, 0x727C, 0x72CB, 0x731A, 0x7368, 0x73B5, 
+0x7400, 0x744C, 0x7496, 0x74DF, 0x7528, 0x756F, 0x75B6, 0x75FB, 0x7640, 0x7684, 0x76C7, 0x7709, 0x774B, 0x778B, 0x77CA, 0x7809, 
+0x7846, 0x7883, 0x78BF, 0x78FA, 0x7934, 0x796D, 0x79A5, 0x79DC, 0x7A12, 0x7A47, 0x7A7C, 0x7AAF, 0x7AE1, 0x7B13, 0x7B44, 0x7B73, 
+0x7BA2, 0x7BD0, 0x7BFD, 0x7C29, 0x7C53, 0x7C7D, 0x7CA7, 0x7CCF, 0x7CF6, 0x7D1C, 0x7D41, 0x7D66, 0x7D89, 0x7DAB, 0x7DCD, 0x7DED, 
+0x7E0D, 0x7E2B, 0x7E49, 0x7E65, 0x7E81, 0x7E9C, 0x7EB6, 0x7ECE, 0x7EE6, 0x7EFD, 0x7F13, 0x7F28, 0x7F3C, 0x7F4F, 0x7F61, 0x7F72, 
+0x7F82, 0x7F91, 0x7F9F, 0x7FAC, 0x7FB8, 0x7FC4, 0x7FCE, 0x7FD7, 0x7FDF, 0x7FE7, 0x7FED, 0x7FF2, 0x7FF7, 0x7FFA, 0x7FFD, 0x7FFE, 
+0x7FFF, 0x7FFE, 0x7FFD, 0x7FFA, 0x7FF7, 0x7FF2, 0x7FED, 0x7FE7, 0x7FDF, 0x7FD7, 0x7FCE, 0x7FC4, 0x7FB8, 0x7FAC, 0x7F9F, 0x7F91, 
+0x7F82, 0x7F72, 0x7F61, 0x7F4F, 0x7F3C, 0x7F28, 0x7F13, 0x7EFD, 0x7EE6, 0x7ECE, 0x7EB6, 0x7E9C, 0x7E81, 0x7E65, 0x7E49, 0x7E2B, 
+0x7E0D, 0x7DED, 0x7DCD, 0x7DAB, 0x7D89, 0x7D66, 0x7D41, 0x7D1C, 0x7CF6, 0x7CCF, 0x7CA7, 0x7C7D, 0x7C53, 0x7C29, 0x7BFD, 0x7BD0, 
+0x7BA2, 0x7B73, 0x7B44, 0x7B13, 0x7AE1, 0x7AAF, 0x7A7C, 0x7A47, 0x7A12, 0x79DC, 0x79A5, 0x796D, 0x7934, 0x78FA, 0x78BF, 0x7883, 
+0x7846, 0x7809, 0x77CA, 0x778B, 0x774B, 0x7709, 0x76C7, 0x7684, 0x7640, 0x75FB, 0x75B6, 0x756F, 0x7528, 0x74DF, 0x7496, 0x744C, 
+0x7400, 0x73B5, 0x7368, 0x731A, 0x72CB, 0x727C, 0x722B, 0x71DA, 0x7188, 0x7135, 0x70E1, 0x708D, 0x7037, 0x6FE1, 0x6F8A, 0x6F31, 
+0x6ED9, 0x6E7F, 0x6E24, 0x6DC9, 0x6D6C, 0x6D0F, 0x6CB1, 0x6C53, 0x6BF3, 0x6B92, 0x6B31, 0x6ACF, 0x6A6C, 0x6A09, 0x69A4, 0x693F, 
+0x68D9, 0x6872, 0x680A, 0x67A2, 0x6738, 0x66CE, 0x6663, 0x65F8, 0x658B, 0x651E, 0x64B0, 0x6441, 0x63D2, 0x6362, 0x62F1, 0x627F, 
+0x620C, 0x6199, 0x6125, 0x60B1, 0x603B, 0x5FC5, 0x5F4E, 0x5ED6, 0x5E5E, 0x5DE5, 0x5D6B, 0x5CF0, 0x5C75, 0x5BF9, 0x5B7D, 0x5AFF, 
+0x5A81, 0x5A03, 0x5983, 0x5903, 0x5882, 0x5801, 0x577F, 0x56FC, 0x5679, 0x55F4, 0x5570, 0x54EA, 0x5464, 0x53DE, 0x5356, 0x52CE, 
+0x5246, 0x51BD, 0x5133, 0x50A8, 0x501D, 0x4F91, 0x4F05, 0x4E78, 0x4DEB, 0x4D5D, 0x4CCE, 0x4C3F, 0x4BAF, 0x4B1F, 0x4A8E, 0x49FC, 
+0x496A, 0x48D7, 0x4844, 0x47B0, 0x471C, 0x4687, 0x45F2, 0x455C, 0x44C5, 0x442E, 0x4397, 0x42FF, 0x4266, 0x41CD, 0x4134, 0x409A, 
+0x3FFF, 0x3F64, 0x3EC8, 0x3E2D, 0x3D90, 0x3CF3, 0x3C56, 0x3BB8, 0x3B1A, 0x3A7B, 0x39DC, 0x393C, 0x389C, 0x37FB, 0x375B, 0x36B9, 
+0x3617, 0x3575, 0x34D3, 0x3430, 0x338C, 0x32E9, 0x3244, 0x31A0, 0x30FB, 0x3056, 0x2FB0, 0x2F0A, 0x2E64, 0x2DBD, 0x2D16, 0x2C6E, 
+0x2BC6, 0x2B1E, 0x2A76, 0x29CD, 0x2924, 0x287B, 0x27D1, 0x2727, 0x267D, 0x25D2, 0x2527, 0x247C, 0x23D1, 0x2325, 0x2279, 0x21CD, 
+0x2120, 0x2073, 0x1FC6, 0x1F19, 0x1E6C, 0x1DBE, 0x1D10, 0x1C62, 0x1BB4, 0x1B05, 0x1A56, 0x19A7, 0x18F8, 0x1849, 0x1799, 0x16E9, 
+0x1639, 0x1589, 0x14D9, 0x1429, 0x1378, 0x12C7, 0x1217, 0x1166, 0x10B4, 0x1003, 0x0F52, 0x0EA0, 0x0DEF, 0x0D3D, 0x0C8B, 0x0BD9, 
+0x0B27, 0x0A75, 0x09C3, 0x0911, 0x085F, 0x07AC, 0x06FA, 0x0647, 0x0595, 0x04E2, 0x0430, 0x037D, 0x02CA, 0x0218, 0x0165, 0x00B2, 
+0x0000, 0xFF4E, 0xFE9B, 0xFDE8, 0xFD36, 0xFC83, 0xFBD0, 0xFB1E, 0xFA6B, 0xF9B9, 0xF906, 0xF854, 0xF7A1, 0xF6EF, 0xF63D, 0xF58B, 
+0xF4D9, 0xF427, 0xF375, 0xF2C3, 0xF211, 0xF160, 0xF0AE, 0xEFFD, 0xEF4C, 0xEE9A, 0xEDE9, 0xED39, 0xEC88, 0xEBD7, 0xEB27, 0xEA77, 
+0xE9C7, 0xE917, 0xE867, 0xE7B7, 0xE708, 0xE659, 0xE5AA, 0xE4FB, 0xE44C, 0xE39E, 0xE2F0, 0xE242, 0xE194, 0xE0E7, 0xE03A, 0xDF8D, 
+0xDEE0, 0xDE33, 0xDD87, 0xDCDB, 0xDC2F, 0xDB84, 0xDAD9, 0xDA2E, 0xD983, 0xD8D9, 0xD82F, 0xD785, 0xD6DC, 0xD633, 0xD58A, 0xD4E2, 
+0xD43A, 0xD392, 0xD2EA, 0xD243, 0xD19C, 0xD0F6, 0xD050, 0xCFAA, 0xCF05, 0xCE60, 0xCDBC, 0xCD17, 0xCC74, 0xCBD0, 0xCB2D, 0xCA8B, 
+0xC9E9, 0xC947, 0xC8A5, 0xC805, 0xC764, 0xC6C4, 0xC624, 0xC585, 0xC4E6, 0xC448, 0xC3AA, 0xC30D, 0xC270, 0xC1D3, 0xC138, 0xC09C, 
+0xC001, 0xBF66, 0xBECC, 0xBE33, 0xBD9A, 0xBD01, 0xBC69, 0xBBD2, 0xBB3B, 0xBAA4, 0xBA0E, 0xB979, 0xB8E4, 0xB850, 0xB7BC, 0xB729, 
+0xB696, 0xB604, 0xB572, 0xB4E1, 0xB451, 0xB3C1, 0xB332, 0xB2A3, 0xB215, 0xB188, 0xB0FB, 0xB06F, 0xAFE3, 0xAF58, 0xAECD, 0xAE43, 
+0xADBA, 0xAD32, 0xACAA, 0xAC22, 0xAB9C, 0xAB16, 0xAA90, 0xAA0C, 0xA987, 0xA904, 0xA881, 0xA7FF, 0xA77E, 0xA6FD, 0xA67D, 0xA5FD, 
+0xA57F, 0xA501, 0xA483, 0xA407, 0xA38B, 0xA310, 0xA295, 0xA21B, 0xA1A2, 0xA12A, 0xA0B2, 0xA03B, 0x9FC5, 0x9F4F, 0x9EDB, 0x9E67, 
+0x9DF4, 0x9D81, 0x9D0F, 0x9C9E, 0x9C2E, 0x9BBF, 0x9B50, 0x9AE2, 0x9A75, 0x9A08, 0x999D, 0x9932, 0x98C8, 0x985E, 0x97F6, 0x978E, 
+0x9727, 0x96C1, 0x965C, 0x95F7, 0x9594, 0x9531, 0x94CF, 0x946E, 0x940D, 0x93AD, 0x934F, 0x92F1, 0x9294, 0x9237, 0x91DC, 0x9181, 
+0x9127, 0x90CF, 0x9076, 0x901F, 0x8FC9, 0x8F73, 0x8F1F, 0x8ECB, 0x8E78, 0x8E26, 0x8DD5, 0x8D84, 0x8D35, 0x8CE6, 0x8C98, 0x8C4B, 
+0x8C00, 0x8BB4, 0x8B6A, 0x8B21, 0x8AD8, 0x8A91, 0x8A4A, 0x8A05, 0x89C0, 0x897C, 0x8939, 0x88F7, 0x88B5, 0x8875, 0x8836, 0x87F7, 
+0x87BA, 0x877D, 0x8741, 0x8706, 0x86CC, 0x8693, 0x865B, 0x8624, 0x85EE, 0x85B9, 0x8584, 0x8551, 0x851F, 0x84ED, 0x84BC, 0x848D, 
+0x845E, 0x8430, 0x8403, 0x83D7, 0x83AD, 0x8383, 0x8359, 0x8331, 0x830A, 0x82E4, 0x82BF, 0x829A, 0x8277, 0x8255, 0x8233, 0x8213, 
+0x81F3, 0x81D5, 0x81B7, 0x819B, 0x817F, 0x8164, 0x814A, 0x8132, 0x811A, 0x8103, 0x80ED, 0x80D8, 0x80C4, 0x80B1, 0x809F, 0x808E, 
+0x807E, 0x806F, 0x8061, 0x8054, 0x8048, 0x803C, 0x8032, 0x8029, 0x8021, 0x8019, 0x8013, 0x800E, 0x8009, 0x8006, 0x8003, 0x8002, 
+0x8001, 0x8002, 0x8003, 0x8006, 0x8009, 0x800E, 0x8013, 0x8019, 0x8021, 0x8029, 0x8032, 0x803C, 0x8048, 0x8054, 0x8061, 0x806F, 
+0x807E, 0x808E, 0x809F, 0x80B1, 0x80C4, 0x80D8, 0x80ED, 0x8103, 0x811A, 0x8132, 0x814A, 0x8164, 0x817F, 0x819B, 0x81B7, 0x81D5, 
+0x81F3, 0x8213, 0x8233, 0x8255, 0x8277, 0x829A, 0x82BF, 0x82E4, 0x830A, 0x8331, 0x8359, 0x8383, 0x83AD, 0x83D7, 0x8403, 0x8430, 
+0x845E, 0x848D, 0x84BC, 0x84ED, 0x851F, 0x8551, 0x8584, 0x85B9, 0x85EE, 0x8624, 0x865B, 0x8693, 0x86CC, 0x8706, 0x8741, 0x877D, 
+0x87BA, 0x87F7, 0x8836, 0x8875, 0x88B5, 0x88F7, 0x8939, 0x897C, 0x89C0, 0x8A05, 0x8A4A, 0x8A91, 0x8AD8, 0x8B21, 0x8B6A, 0x8BB4, 
+0x8C00, 0x8C4B, 0x8C98, 0x8CE6, 0x8D35, 0x8D84, 0x8DD5, 0x8E26, 0x8E78, 0x8ECB, 0x8F1F, 0x8F73, 0x8FC9, 0x901F, 0x9076, 0x90CF, 
+0x9127, 0x9181, 0x91DC, 0x9237, 0x9294, 0x92F1, 0x934F, 0x93AD, 0x940D, 0x946E, 0x94CF, 0x9531, 0x9594, 0x95F7, 0x965C, 0x96C1, 
+0x9727, 0x978E, 0x97F6, 0x985E, 0x98C8, 0x9932, 0x999D, 0x9A08, 0x9A75, 0x9AE2, 0x9B50, 0x9BBF, 0x9C2E, 0x9C9E, 0x9D0F, 0x9D81, 
+0x9DF4, 0x9E67, 0x9EDB, 0x9F4F, 0x9FC5, 0xA03B, 0xA0B2, 0xA12A, 0xA1A2, 0xA21B, 0xA295, 0xA310, 0xA38B, 0xA407, 0xA483, 0xA501, 
+0xA57F, 0xA5FD, 0xA67D, 0xA6FD, 0xA77E, 0xA7FF, 0xA881, 0xA904, 0xA987, 0xAA0C, 0xAA90, 0xAB16, 0xAB9C, 0xAC22, 0xACAA, 0xAD32, 
+0xADBA, 0xAE43, 0xAECD, 0xAF58, 0xAFE3, 0xB06F, 0xB0FB, 0xB188, 0xB215, 0xB2A3, 0xB332, 0xB3C1, 0xB451, 0xB4E1, 0xB572, 0xB604, 
+0xB696, 0xB729, 0xB7BC, 0xB850, 0xB8E4, 0xB979, 0xBA0E, 0xBAA4, 0xBB3B, 0xBBD2, 0xBC69, 0xBD01, 0xBD9A, 0xBE33, 0xBECC, 0xBF66, 
+0xC001, 0xC09C, 0xC138, 0xC1D3, 0xC270, 0xC30D, 0xC3AA, 0xC448, 0xC4E6, 0xC585, 0xC624, 0xC6C4, 0xC764, 0xC805, 0xC8A5, 0xC947, 
+0xC9E9, 0xCA8B, 0xCB2D, 0xCBD0, 0xCC74, 0xCD17, 0xCDBC, 0xCE60, 0xCF05, 0xCFAA, 0xD050, 0xD0F6, 0xD19C, 0xD243, 0xD2EA, 0xD392, 
+0xD43A, 0xD4E2, 0xD58A, 0xD633, 0xD6DC, 0xD785, 0xD82F, 0xD8D9, 0xD983, 0xDA2E, 0xDAD9, 0xDB84, 0xDC2F, 0xDCDB, 0xDD87, 0xDE33, 
+0xDEE0, 0xDF8D, 0xE03A, 0xE0E7, 0xE194, 0xE242, 0xE2F0, 0xE39E, 0xE44C, 0xE4FB, 0xE5AA, 0xE659, 0xE708, 0xE7B7, 0xE867, 0xE917, 
+0xE9C7, 0xEA77, 0xEB27, 0xEBD7, 0xEC88, 0xED39, 0xEDE9, 0xEE9A, 0xEF4C, 0xEFFD, 0xF0AE, 0xF160, 0xF211, 0xF2C3, 0xF375, 0xF427, 
+0xF4D9, 0xF58B, 0xF63D, 0xF6EF, 0xF7A1, 0xF854, 0xF906, 0xF9B9, 0xFA6B, 0xFB1E, 0xFBD0, 0xFC83, 0xFD36, 0xFDE8, 0xFE9B, 0xFF4E
