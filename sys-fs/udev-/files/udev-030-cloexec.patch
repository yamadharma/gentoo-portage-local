--- udev-030/udevd.c.cloexec	2004-07-09 19:59:09.000000000 +0200
+++ udev-030/udevd.c	2004-08-27 14:42:49.000000000 +0200
@@ -443,11 +443,14 @@
 	addrlen = offsetof(struct sockaddr_un, sun_path) + strlen(saddr.sun_path+1) + 1;
 
 	ssock = socket(AF_LOCAL, SOCK_DGRAM, 0);
+
 	if (ssock == -1) {
 		dbg("error getting socket, exit");
 		exit(1);
 	}
 
+	set_cloexec_flag(ssock, 1);
+
 	/* the bind takes care of ensuring only one copy running */
 	retval = bind(ssock, (struct sockaddr *) &saddr, addrlen);
 	if (retval < 0) {
--- udev-030/namedev.c.cloexec	2004-07-09 19:59:10.000000000 +0200
+++ udev-030/namedev.c	2004-08-27 14:42:49.000000000 +0200
@@ -43,6 +43,8 @@
 #include "namedev.h"
 #include "klibc_fixups.h"
 
+#define OPEN_MAX 256
+
 static struct sysfs_attribute *find_sysfs_attribute(struct sysfs_class_device *class_dev, struct sysfs_device *sysfs_device, char *attr);
 
 LIST_HEAD(config_device_list);
@@ -412,12 +414,24 @@
 
 	pid = fork();
 	switch(pid) {
+		int rlim_ofile_cur, tmpint;
+	        struct rlimit rlim_ofile;
+
 	case 0:
 		/* child */
-		close(STDOUT_FILENO);
-
 		/* dup write side of pipe to STDOUT */
-		dup(fds[1]);
+		dup2(fds[1], STDOUT_FILENO);
+ #if 0
+                if (getrlimit(RLIMIT_NOFILE, &rlim_ofile) < 0) {
+                        rlim_ofile_cur = OPEN_MAX;
+                } else {
+                        rlim_ofile_cur = rlim_ofile.rlim_cur;
+                        if (rlim_ofile_cur == RLIM_INFINITY)    /* ! */
+                                rlim_ofile_cur = OPEN_MAX;
+                }
+                for (tmpint = rlim_ofile_cur-1; --tmpint > 2; )
+                        (void)close(tmpint);
+ #endif
 		if (argv[0] !=  NULL) {
 			dbg("execute '%s' with given arguments", argv[0]);
 			retval = execv(argv[0], argv);
--- udev-030/tdb/tdb.c.cloexec	2004-07-09 19:59:10.000000000 +0200
+++ udev-030/tdb/tdb.c	2004-08-27 14:42:49.000000000 +0200
@@ -1736,6 +1736,12 @@
 		goto fail;	/* errno set by open(2) */
 	}
 
+	/* 
+	   Close file when execing another process.  
+	   Prevents SELinux access errors.
+	*/
+	set_cloexec_flag(tdb->fd, 1);
+
 	/* ensure there is only one process initialising at once */
 	if (tdb_brlock(tdb, GLOBAL_LOCK, F_WRLCK, F_SETLKW, 0) == -1) {
 		TDB_LOG((tdb, 0, "tdb_open_ex: failed to get global lock on %s: %s\n",
--- udev-030/dev_d.c.cloexec	2004-07-09 19:59:10.000000000 +0200
+++ udev-030/dev_d.c	2004-08-27 14:57:23.491005728 +0200
@@ -23,17 +23,28 @@
 #include <string.h>
 #include <sys/types.h>
 #include <sys/wait.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
 #include <unistd.h>
+
 #include "udev.h"
 #include "udev_lib.h"
+#include "udevdb.h"
 #include "logging.h"
 
+#define OPEN_MAX 256
+
 #define DEVD_DIR			"/etc/dev.d/"
 #define DEVD_SUFFIX			".dev"
 
 static int run_program(char *name)
 {
 	pid_t pid;
+	int fd;
+	struct rlimit rlim_ofile;
 
 	dbg("running %s", name);
 
@@ -41,6 +52,14 @@
 	switch (pid) {
 	case 0:
 		/* child */
+		udevdb_exit();  /* close udevdb */
+		fd = open("/dev/null", O_RDWR);
+		if ( fd >= 0) {
+			dup2(fd, STDOUT_FILENO);
+			dup2(fd, STDIN_FILENO);
+			dup2(fd, STDERR_FILENO);
+		}
+		close(fd);
 		execv(name, main_argv);
 		dbg("exec of child failed");
 		exit(1);
--- udev-030/udev_lib.h.cloexec	2004-07-09 19:59:09.000000000 +0200
+++ udev-030/udev_lib.h	2004-08-27 14:42:49.000000000 +0200
@@ -78,6 +78,6 @@
 extern void leading_slash(char *path);
 extern void no_leading_slash(char *path);
 extern int  call_foreach_file(int fnct(char *f) , char *filename, char *extension);
-
+extern int set_cloexec_flag (int desc, int value);
 
 #endif
--- udev-030/udev_lib.c.cloexec	2004-07-09 19:59:10.000000000 +0200
+++ udev-030/udev_lib.c	2004-08-27 14:42:49.000000000 +0200
@@ -255,3 +255,22 @@
 	closedir(dir);
 	return 0;
 }
+
+/* Set the FD_CLOEXEC  flag of desc if value is nonzero,
+   or clear the flag if value is 0.
+   Return 0 on success, or -1 on error with errno  set. */ 
+	
+int set_cloexec_flag (int desc, int value)
+{
+	int oldflags = fcntl (desc, F_GETFD, 0);
+	/* If reading the flags failed, return error indication now. */
+	if (oldflags < 0)
+		return oldflags;
+	/* Set just the flag we want to set. */
+	if (value != 0)
+		oldflags |= FD_CLOEXEC;
+	else
+		oldflags &= ~FD_CLOEXEC;
+	/* Store modified flag word in the descriptor. */
+	return fcntl (desc, F_SETFD, oldflags);
+}
--- udev-030/udevsend.c.cloexec	2004-07-09 19:59:08.000000000 +0200
+++ udev-030/udevsend.c	2004-08-27 14:42:49.000000000 +0200
@@ -171,6 +171,8 @@
 		goto fallback;
 	}
 
+	set_cloexec_flag(sock, 1);
+
 	memset(&saddr, 0x00, sizeof(struct sockaddr_un));
 	saddr.sun_family = AF_LOCAL;
 	/* use abstract namespace for socket path */
