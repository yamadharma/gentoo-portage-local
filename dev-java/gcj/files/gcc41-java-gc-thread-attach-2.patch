2006-03-29  Bryce McKinlay  <mckinlay@redhat.com>
	
	PR libgcj/13212:
	* configure.ac: Check for pthread_getattr_np(). Remove
	GC_PTHREAD_SYM_VERSION detection.
	* include/gc.h (GC_register_my_thread, GC_unregister_my_thread,
	GC_get_thread_stack_base): New declarations.
	* pthread_support.c (GC_register_my_thread, GC_unregister_my_thread,
	GC_get_thread_stack_base): New functions.
	(GC_delete_thread): Don't try to free the first_thread.
	* misc.c (GC_init_inner): Use GC_get_thread_stack_base() if possible.
	(pthread_create_, constr): Removed.
	(pthread_create): Don't rename.
	* include/gc_ext_config.h.in: Rebuilt.
	* include/gc_pthread_redirects.h (pthread_create): Define 
	unconditionally.
	* include/gc_config.h.in: Rebuilt.
	* configure: Rebuilt.

Index: libjava/boehm.cc
===================================================================
--- libjava/boehm.cc	(revision 112312)
+++ libjava/boehm.cc	(working copy)
@@ -713,3 +713,15 @@
   // For now, always reclaim soft references.  FIXME.
   return true;
 }
+
+void
+_Jv_GCAttachThread ()
+{
+  GC_register_my_thread ();
+}
+
+void
+_Jv_GCDetachThread ()
+{
+  GC_unregister_my_thread ();
+}
Index: libjava/java/lang/natThread.cc
===================================================================
--- libjava/java/lang/natThread.cc	(revision 112312)
+++ libjava/java/lang/natThread.cc	(working copy)
@@ -396,7 +396,8 @@
 }
 
 // Attach the current native thread to an existing (but unstarted) Thread 
-// object. Returns -1 on failure, 0 upon success.
+// object. Does not register thread with the garbage collector.
+// Returns -1 on failure, 0 upon success.
 jint
 _Jv_AttachCurrentThread(java::lang::Thread* thread)
 {
@@ -413,6 +414,8 @@
 java::lang::Thread*
 _Jv_AttachCurrentThread(jstring name, java::lang::ThreadGroup* group)
 {
+  // Register thread with GC before attempting any allocations.
+  _Jv_GCAttachThread ();
   java::lang::Thread *thread = _Jv_ThreadCurrent ();
   if (thread != NULL)
     return thread;
@@ -447,6 +450,7 @@
     return -1;
 
   _Jv_ThreadUnRegister ();
+  _Jv_GCDetachThread ();
   // Release the monitors.
   t->finish_ ();
 
Index: libjava/include/boehm-gc.h
===================================================================
--- libjava/include/boehm-gc.h	(revision 112312)
+++ libjava/include/boehm-gc.h	(working copy)
@@ -79,6 +79,12 @@
 
 #endif /* LIBGCJ_GC_DEBUG */
 
+void
+_Jv_GCAttachThread ();
+
+void
+_Jv_GCDetachThread ();
+
 // _Jv_AllocBytes (jsize size) should go here, too.  But clients don't
 // usually include this header.
 
Index: boehm-gc/configure.ac
===================================================================
--- boehm-gc/configure.ac	(revision 112312)
+++ boehm-gc/configure.ac	(working copy)
@@ -291,6 +291,13 @@
      ;;
 esac
 
+# Checks for pthreads functions
+#
+oldLIBS="$LIBS"
+LIBS="$LIBS -lpthread"
+AC_CHECK_FUNCS([pthread_getattr_np])
+LIBS="$oldLIBS"
+
 # Configuration of machine-dependent code
 #
 # We don't set NO_EXECUTE_PERMISSION by default because gcj (and
@@ -450,25 +457,6 @@
   AC_DEFINE(USE_MMAP, 1, [use MMAP instead of sbrk to get new memory])
 fi
 
-symver=
-case "$target" in
-  *-*-linux* )
-    cat > conftest.c <<EOF
-#include <pthread.h>
-void *tf (void *arg) { (void) arg; return NULL; }
-int main (void) { pthread_t th; pthread_create (&th, NULL, tf, NULL); return 0; }
-EOF
-    if $CC $CFLAGS -pthread -o conftest conftest.c > /dev/null 2>&1; then
-      symver=`readelf -s conftest 2> /dev/null | sed -n '/UND pthread_create@/{s/^.*@//;s/ .*$//;p;q}'`
-    fi
-    rm -f conftest conftest.c
-    ;;
-esac
-if test -n "$symver"; then
-  AC_DEFINE_UNQUOTED(GC_PTHREAD_SYM_VERSION, "$symver", [symbol version of pthread_create])
-fi
-
-
 if test -n "$with_cross_host" &&
    test x"$with_cross_host" != x"no"; then
   toolexecdir='$(exec_prefix)/$(target_noncanonical)'
Index: boehm-gc/include/gc.h
===================================================================
--- boehm-gc/include/gc.h	(revision 112312)
+++ boehm-gc/include/gc.h	(working copy)
@@ -69,7 +69,6 @@
     extern "C" {
 # endif
 
-
 /* Define word and signed_word to be unsigned and signed types of the 	*/
 /* size as char * or void *.  There seems to be no way to do this	*/
 /* even semi-portably.  The following is probably no better/worse 	*/
@@ -909,6 +908,25 @@
 # if defined(PCR) || defined(GC_SOLARIS_THREADS) || \
      defined(GC_PTHREADS) || defined(GC_WIN32_THREADS)
    	/* Any flavor of threads except SRC_M3.	*/
+
+/* Register the current thread as a new thread whose stack(s) should    */
+/* be traced by the GC.  						*/
+/* If a platform does not implicitly do so, this must be called before  */
+/* a thread can allocate garbage collected memory, or assign pointers	*/
+/* to the garbage collected heap.  Once registered, a thread will be	*/
+/* stopped during garbage collections.					*/
+GC_API void GC_register_my_thread GC_PROTO((void));
+
+/* Register the current thread, with the indicated stack base, as	*/
+/* a new thread whose stack(s) should be traced by the GC.  If a 	*/
+/* platform does not implicitly do so, this must be called before a	*/
+/* thread can allocate garbage collected memory, or assign pointers	*/
+/* to the garbage collected heap.  Once registered, a thread will be	*/
+/* stopped during garbage collections.					*/
+GC_API void GC_unregister_my_thread GC_PROTO((void));
+
+GC_API GC_PTR GC_get_thread_stack_base GC_PROTO((void));
+
 /* This returns a list of objects, linked through their first		*/
 /* word.  Its use can greatly reduce lock contention problems, since	*/
 /* the allocation lock can be acquired and released many fewer times.	*/
Index: boehm-gc/include/gc_ext_config.h.in
===================================================================
--- boehm-gc/include/gc_ext_config.h.in	(revision 112312)
+++ boehm-gc/include/gc_ext_config.h.in	(working copy)
@@ -3,5 +3,3 @@
 is used by libjava/include/boehm-gc.h. */
 
 #undef THREAD_LOCAL_ALLOC
-
-#undef GC_PTHREAD_SYM_VERSION
Index: boehm-gc/include/gc_pthread_redirects.h
===================================================================
--- boehm-gc/include/gc_pthread_redirects.h	(revision 112312)
+++ boehm-gc/include/gc_pthread_redirects.h	(working copy)
@@ -68,9 +68,7 @@
 # undef pthread_detach
 #endif
 
-#ifndef GC_PTHREAD_SYM_VERSION
 # define pthread_create GC_pthread_create
-#endif
 # define pthread_join GC_pthread_join
 # define pthread_detach GC_pthread_detach
 
Index: boehm-gc/include/gc_config.h.in
===================================================================
--- boehm-gc/include/gc_config.h.in	(revision 112312)
+++ boehm-gc/include/gc_config.h.in	(working copy)
@@ -45,9 +45,6 @@
 /* support for Tru64 pthreads */
 #undef GC_OSF1_THREADS
 
-/* symbol version of pthread_create */
-#undef GC_PTHREAD_SYM_VERSION
-
 /* support for Solaris pthreads */
 #undef GC_SOLARIS_PTHREADS
 
@@ -63,6 +60,9 @@
 /* Define to 1 if you have the <memory.h> header file. */
 #undef HAVE_MEMORY_H
 
+/* Define to 1 if you have the `pthread_getattr_np' function. */
+#undef HAVE_PTHREAD_GETATTR_NP
+
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
Index: boehm-gc/configure
===================================================================
--- boehm-gc/configure	(revision 112312)
+++ boehm-gc/configure	(working copy)
@@ -5759,6 +5759,119 @@
      ;;
 esac
 
+# Checks for pthreads functions
+#
+oldLIBS="$LIBS"
+LIBS="$LIBS -lpthread"
+
+for ac_func in pthread_getattr_np
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test x$gcc_no_link = xyes; then
+  { { echo "$as_me:$LINENO: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&5
+echo "$as_me: error: Link tests are not allowed after GCC_NO_EXECUTABLES." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+
+#undef $ac_func
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+LIBS="$oldLIBS"
+
 # Configuration of machine-dependent code
 #
 # We don't set NO_EXECUTE_PERMISSION by default because gcj (and
@@ -6627,29 +6740,6 @@
 
 fi
 
-symver=
-case "$target" in
-  *-*-linux* )
-    cat > conftest.c <<EOF
-#include <pthread.h>
-void *tf (void *arg) { (void) arg; return NULL; }
-int main (void) { pthread_t th; pthread_create (&th, NULL, tf, NULL); return 0; }
-EOF
-    if $CC $CFLAGS -pthread -o conftest conftest.c > /dev/null 2>&1; then
-      symver=`readelf -s conftest 2> /dev/null | sed -n '/UND pthread_create@/{s/^.*@//;s/ .*$//;p;q}'`
-    fi
-    rm -f conftest conftest.c
-    ;;
-esac
-if test -n "$symver"; then
-
-cat >>confdefs.h <<_ACEOF
-#define GC_PTHREAD_SYM_VERSION "$symver"
-_ACEOF
-
-fi
-
-
 if test -n "$with_cross_host" &&
    test x"$with_cross_host" != x"no"; then
   toolexecdir='$(exec_prefix)/$(target_noncanonical)'
Index: boehm-gc/pthread_support.c
===================================================================
--- boehm-gc/pthread_support.c	(revision 112312)
+++ boehm-gc/pthread_support.c	(working copy)
@@ -602,7 +602,9 @@
     } else {
         prev -> next = p -> next;
     }
-    GC_INTERNAL_FREE(p);
+
+    if (p != &first_thread)
+      GC_INTERNAL_FREE(p);
 }
 
 /* If a thread has been joined, but we have not yet		*/
@@ -1125,6 +1127,107 @@
 
 GC_bool GC_in_thread_creation = FALSE;
 
+GC_PTR GC_get_thread_stack_base()
+{  
+# ifdef HAVE_PTHREAD_GETATTR_NP
+  pthread_t my_pthread;
+  pthread_attr_t attr;
+  ptr_t stack_addr;
+  size_t stack_size;
+  
+  my_pthread = pthread_self();  
+  pthread_getattr_np (my_pthread, &attr);
+  pthread_attr_getstack (&attr, (void **) &stack_addr, &stack_size);
+  pthread_attr_destroy (&attr);
+  
+#   ifdef DEBUG_THREADS
+	GC_printf1("attached thread stack address: 0x%x\n", stack_addr);
+#   endif
+
+#   ifdef STACK_GROWS_DOWN
+      return stack_addr + stack_size;
+#   else
+      return stack_addr - stack_size;
+#   endif
+
+# else
+#   ifdef DEBUG_THREADS
+	GC_printf1("Can not determine stack base for attached thread");
+#   endif
+  return 0;
+# endif
+}
+
+void GC_register_my_thread()
+{
+  GC_thread me;
+  pthread_t my_pthread;
+
+  my_pthread = pthread_self();
+#   ifdef DEBUG_THREADS
+      GC_printf1("Attaching thread 0x%lx\n", my_pthread);
+      GC_printf1("pid = %ld\n", (long) getpid());
+#   endif
+  
+  /* Check to ensure this thread isn't attached already. */
+  LOCK();
+  me = GC_lookup_thread (my_pthread);
+  UNLOCK();
+  if (me != 0)
+    {
+#   ifdef DEBUG_THREADS
+      GC_printf1("Attempt to re-attach known thread 0x%lx\n", my_pthread);
+#   endif
+      return;
+    }
+
+  LOCK();
+  GC_in_thread_creation = TRUE;
+  me = GC_new_thread(my_pthread);
+  GC_in_thread_creation = FALSE;
+
+  me -> flags |= DETACHED;  
+
+#ifdef GC_DARWIN_THREADS
+    me -> stop_info.mach_thread = mach_thread_self();
+#else
+    me -> stack_end = GC_get_thread_stack_base();    
+    if (me -> stack_end == 0)
+      GC_abort("Can not determine stack base for attached thread");
+    
+#   ifdef STACK_GROWS_DOWN
+      me -> stop_info.stack_ptr = me -> stack_end - 0x10;
+#   else
+      me -> stop_info.stack_ptr = me -> stack_end + 0x10;
+#   endif
+#endif
+
+#   ifdef IA64
+      me -> backing_store_end = (ptr_t)
+			(GC_save_regs_in_stack() & ~(GC_page_size - 1));
+      /* This is also < 100% convincing.  We should also read this 	*/
+      /* from /proc, but the hook to do so isn't there yet.		*/
+#   endif /* IA64 */
+
+#   if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)
+        GC_init_thread_local(me);
+#   endif
+  UNLOCK();
+}
+
+void GC_unregister_my_thread()
+{
+  pthread_t my_pthread;
+
+  my_pthread = pthread_self();
+
+#   ifdef DEBUG_THREADS
+      GC_printf1("Detaching thread 0x%lx\n", my_pthread);
+#   endif
+
+  GC_thread_exit_proc (0);
+}
+
 void * GC_start_routine(void * arg)
 {
     int dummy;
@@ -1201,37 +1304,8 @@
     return(result);
 }
 
-#ifdef GC_PTHREAD_SYM_VERSION
-
-/* Force constr to execute prior to main().  */
-static void constr (void) __attribute__ ((constructor));
-
-static int
-(*pthread_create_)(pthread_t *new_thread,
-		   const pthread_attr_t *attr_in,
-		   void * (*thread_execp)(void *), void *arg);
-
-static void
-constr (void)
-{
-  /* Get a pointer to the real pthread_create.  */
-  pthread_create_ = dlvsym (RTLD_NEXT, "pthread_create",
-			    GC_PTHREAD_SYM_VERSION);
-}
-
-#define GC_PTHREAD_CREATE_NAME pthread_create
-#define GC_PTHREAD_REAL_NAME (*pthread_create_)
-
-#else
-
-#define GC_PTHREAD_CREATE_NAME WRAP_FUNC(pthread_create)
-#define GC_PTHREAD_REAL_NAME REAL_FUNC(pthread_create)
-
-#endif
-
-
 int
-GC_PTHREAD_CREATE_NAME(pthread_t *new_thread,
+WRAP_FUNC(pthread_create)(pthread_t *new_thread,
 		  const pthread_attr_t *attr,
                   void *(*start_routine)(void *), void *arg)
 {
@@ -1286,7 +1360,7 @@
 		   pthread_self());
 #   endif
 
-    result = GC_PTHREAD_REAL_NAME(new_thread, attr, GC_start_routine, si);
+    result = REAL_FUNC(pthread_create)(new_thread, attr, GC_start_routine, si);
 
 #   ifdef DEBUG_THREADS
         GC_printf1("Started thread 0x%X\n", *new_thread);
Index: boehm-gc/misc.c
===================================================================
--- boehm-gc/misc.c	(revision 112312)
+++ boehm-gc/misc.c	(working copy)
@@ -674,7 +674,13 @@
 #   if !defined(THREADS) || defined(GC_PTHREADS) || defined(GC_WIN32_THREADS) \
 	|| defined(GC_SOLARIS_THREADS)
       if (GC_stackbottom == 0) {
-	GC_stackbottom = GC_get_stack_base();
+        # ifdef GC_PTHREADS
+	/* Use thread_stack_base if available, as GC could be initialized from
+	   a thread that is not the "main" thread.  */
+	GC_stackbottom = GC_get_thread_stack_base();
+	# endif
+	if (GC_stackbottom == 0)
+	  GC_stackbottom = GC_get_stack_base();
 #       if (defined(LINUX) || defined(HPUX)) && defined(IA64)
 	  GC_register_stackbottom = GC_get_register_stack_base();
 #       endif
