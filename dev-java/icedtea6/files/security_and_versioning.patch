diff -Nru icedtea6-1.2.orig/acinclude.m4 icedtea6-1.2/acinclude.m4
--- icedtea6-1.2.orig/acinclude.m4	2008-05-20 14:40:43.000000000 +0100
+++ icedtea6-1.2/acinclude.m4	2008-09-14 21:54:47.000000000 +0100
@@ -664,3 +664,32 @@
   AM_CONDITIONAL(WITH_CACAO, test x"${CACAO}" != "xno")
   AC_SUBST(CACAO)
 ])
+
+AC_DEFUN([WITH_VERSION_SUFFIX],
+[
+  AC_MSG_CHECKING(if a version suffix has been specified)
+  AC_ARG_WITH([version-suffix],
+              [AS_HELP_STRING(--with-version-suffix,appends the given text to the JDK version)],
+  [
+    case "${withval}" in
+      yes)
+	version_suffix=
+	AC_MSG_RESULT([no])
+        ;;
+      no)
+	version_suffix=
+	AC_MSG_RESULT([no])
+	;;
+      *)
+        version_suffix=${withval}
+	AC_MSG_RESULT([${version_suffix}])
+        ;;
+    esac
+  ],
+  [
+    version_suffix=
+    AC_MSG_RESULT([no])
+  ])
+  AC_SUBST(VERSION_SUFFIX, $version_suffix)
+])
+ 
diff -Nru icedtea6-1.2.orig/acinclude.m4.rej icedtea6-1.2/acinclude.m4.rej
--- icedtea6-1.2.orig/acinclude.m4.rej	1970-01-01 01:00:00.000000000 +0100
+++ icedtea6-1.2/acinclude.m4.rej	2008-09-14 21:57:29.000000000 +0100
@@ -0,0 +1,38 @@
+***************
+*** 664,666 ****
+    AM_CONDITIONAL(WITH_CACAO, test x"${CACAO}" != "xno")
+    AC_SUBST(CACAO)
+  ])
+--- 664,695 ----
+    AM_CONDITIONAL(WITH_CACAO, test x"${CACAO}" != "xno")
+    AC_SUBST(CACAO)
+  ])
++ 
++ AC_DEFUN([WITH_VERSION_SUFFIX],
++ [
++   AC_MSG_CHECKING(if a version suffix has been specified)
++   AC_ARG_WITH([version-suffix],
++               [AS_HELP_STRING(--with-version-suffix,appends the given text to the JDK version)],
++   [
++     case "${withval}" in
++       yes)
++ 	version_suffix=
++ 	AC_MSG_RESULT([no])
++         ;;
++       no)
++ 	version_suffix=
++ 	AC_MSG_RESULT([no])
++ 	;;
++       *)
++         version_suffix=${withval}
++ 	AC_MSG_RESULT([${version_suffix}])
++         ;;
++     esac
++   ],
++   [
++     version_suffix=
++     AC_MSG_RESULT([no])
++   ])
++   AC_SUBST(VERSION_SUFFIX, $version_suffix)
++ ])
++  
diff -Nru icedtea6-1.2.orig/configure.ac icedtea6-1.2/configure.ac
--- icedtea6-1.2.orig/configure.ac	2008-09-14 21:54:17.000000000 +0100
+++ icedtea6-1.2/configure.ac	2008-09-14 21:54:47.000000000 +0100
@@ -209,6 +209,7 @@
 ENABLE_ZERO_BUILD
 ENABLE_NETX_PLUGIN
 SET_CORE_BUILD
+WITH_VERSION_SUFFIX
 
 dnl pkgconfig cannot be used to finid these headers and libraries.
 AC_CHECK_HEADERS([cups/cups.h cups/ppd.h],[]
diff -Nru icedtea6-1.2.orig/configure.ac.rej icedtea6-1.2/configure.ac.rej
--- icedtea6-1.2.orig/configure.ac.rej	1970-01-01 01:00:00.000000000 +0100
+++ icedtea6-1.2/configure.ac.rej	2008-09-14 21:57:29.000000000 +0100
@@ -0,0 +1,16 @@
+***************
+*** 209,214 ****
+  ENABLE_ZERO_BUILD
+  ENABLE_NETX_PLUGIN
+  SET_CORE_BUILD
+  
+  dnl pkgconfig cannot be used to finid these headers and libraries.
+  AC_CHECK_HEADERS([cups/cups.h cups/ppd.h],[]
+--- 209,215 ----
+  ENABLE_ZERO_BUILD
+  ENABLE_NETX_PLUGIN
+  SET_CORE_BUILD
++ WITH_VERSION_SUFFIX
+  
+  dnl pkgconfig cannot be used to finid these headers and libraries.
+  AC_CHECK_HEADERS([cups/cups.h cups/ppd.h],[]
diff -Nru icedtea6-1.2.orig/Makefile.am icedtea6-1.2/Makefile.am
--- icedtea6-1.2.orig/Makefile.am	2008-09-14 21:54:17.000000000 +0100
+++ icedtea6-1.2/Makefile.am	2008-09-14 21:59:42.000000000 +0100
@@ -192,7 +192,7 @@
 
 # Mercurial snapshot.
 snapshot: dist
-	mv $(DIST_ARCHIVES) $(distdir)-`hg tip --template '{node}'`.tar.gz
+	mv $(DIST_ARCHIVES) $(distdir)-`${HG} tip --template '{node}'`.tar.gz
 
 # OpenJDK Source Preparation Targets
 # ==================================
@@ -320,6 +320,7 @@
 	patches/icedtea-override-redirect-metacity.patch \
 	patches/icedtea-nomotif-6706121.patch \
         patches/icedtea-nomotif.patch \
+	patches/icedtea-security-updates.patch \
 	$(GCC_PATCH) \
 	$(DISTRIBUTION_PATCHES)
 
@@ -361,8 +362,17 @@
 	  echo ERROR patch $${all_patches_ok} FAILED! ; \
 	  echo WARNING make clean-patch before retrying a fix ; \
 	  false; \
-       fi
-
+	fi ; \
+	if [ -e $(abs_top_srcdir)/.hg ]; then \
+	  revision="-r`(cd $(srcdir); $(HG) --template '{rev}')`" ; \
+	fi ; 
+	icedtea_version="$(PACKAGE_VERSION)$${revision}" ; \
+	if test x"$(VERSION_SUFFIX)" != "x"; then \
+	  ver_suffix="-$(VERSION_SUFFIX)"; \
+	fi ; \
+	sed -i "s#IcedTea6#IcedTea6 $${icedtea_version}#" openjdk/jdk/make/common/shared/Defs.gmk ; \
+	sed -i "s#BUILD_VARIANT_RELEASE)#BUILD_VARIANT_RELEASE)$${proj_suffix}$${ver_suffix}#" \
+	  openjdk/jdk/make/common/shared/Defs.gmk
 
 clean-patch:
 	rm -f stamps/patch.stamp
diff -Nru icedtea6-1.2.orig/patches/icedtea-security-updates.patch icedtea6-1.2/patches/icedtea-security-updates.patch
--- icedtea6-1.2.orig/patches/icedtea-security-updates.patch	1970-01-01 01:00:00.000000000 +0100
+++ icedtea6-1.2/patches/icedtea-security-updates.patch	2008-09-14 21:57:29.000000000 +0100
@@ -0,0 +1,994 @@
+--- old/src/share/classes/sun/management/jmxremote/ConnectorBootstrap.java	Mon Jun  2 08:53:51 2008
++++ openjdk/jdk/src/share/classes/sun/management/jmxremote/ConnectorBootstrap.java	Mon Jun  2 08:53:51 2008
+@@ -94,6 +94,7 @@
+     public static interface DefaultValues {
+         public static final String PORT="0";
+         public static final String CONFIG_FILE_NAME="management.properties";
++        public static final String USE_LOCAL_ONLY="true";
+         public static final String USE_SSL="true";
+         public static final String USE_REGISTRY_SSL="false";
+         public static final String USE_AUTHENTICATION="true";
+@@ -110,6 +111,8 @@
+                 "com.sun.management.jmxremote.port";
+         public static final String CONFIG_FILE_NAME =
+                 "com.sun.management.config.file";
++        public static final String USE_LOCAL_ONLY =
++                "com.sun.management.jmxremote.local.only";
+         public static final String USE_SSL =
+                 "com.sun.management.jmxremote.ssl";
+         public static final String USE_REGISTRY_SSL =
+@@ -255,7 +258,6 @@
+ 
+         final String portStr = props.getProperty(PropertyNames.PORT);
+ 
+-
+         // System.out.println("initializing: {port=" + portStr + ",
+         //                     properties="+props+"}");
+         return initialize(portStr,props);
+@@ -442,6 +444,18 @@
+         MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
+         try {
+             JMXServiceURL url = new JMXServiceURL("rmi", localhost, 0);
++            // Do we accept connections from local interfaces only?
++            Properties props = Agent.getManagementProperties();
++            if (props ==  null) {
++                props = new Properties();
++            }
++            String useLocalOnlyStr = props.getProperty(
++                    PropertyNames.USE_LOCAL_ONLY, DefaultValues.USE_LOCAL_ONLY);
++            boolean useLocalOnly = Boolean.valueOf(useLocalOnlyStr).booleanValue();
++            if (useLocalOnly) {
++                env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE,
++                        new LocalRMIServerSocketFactory());
++            }
+             JMXConnectorServer server =
+                     JMXConnectorServerFactory.newJMXConnectorServer(url, env, mbs);
+             server.start();
+@@ -489,12 +500,11 @@
+         if (!file.exists()) {
+             throw new AgentConfigurationError(ACCESS_FILE_NOT_FOUND, accessFileName);
+         }
+-
+         if (!file.canRead()) {
+             throw new AgentConfigurationError(ACCESS_FILE_NOT_READABLE, accessFileName);
+         }
+     }
+-
++    
+     private static void checkRestrictedFile(String restrictedFileName) {
+         if (restrictedFileName == null || restrictedFileName.length() == 0) {
+             throw new AgentConfigurationError(FILE_NOT_SET);
+@@ -726,5 +736,4 @@
+     private static final ClassLogger log =
+         new ClassLogger(ConnectorBootstrap.class.getPackage().getName(),
+                         "ConnectorBootstrap");
+-
+ }
+--- /dev/null	Mon Jun  2 08:53:52 2008
++++ openjdk/jdk/src/share/classes/sun/management/jmxremote/LocalRMIServerSocketFactory.java	Mon Jun  2 08:53:51 2008
+@@ -0,0 +1,110 @@
++/*
++ * Copyright 2007 Sun Microsystems, Inc.  All Rights Reserved.
++ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++ *
++ * This code is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License version 2 only, as
++ * published by the Free Software Foundation.  Sun designates this
++ * particular file as subject to the "Classpath" exception as provided
++ * by Sun in the LICENSE file that accompanied this code.
++ *
++ * This code is distributed in the hope that it will be useful, but WITHOUT
++ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++ * version 2 for more details (a copy is included in the LICENSE file that
++ * accompanied this code).
++ *
++ * You should have received a copy of the GNU General Public License version
++ * 2 along with this work; if not, write to the Free Software Foundation,
++ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
++ *
++ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
++ * CA 95054 USA or visit www.sun.com if you need additional information or
++ * have any questions.
++ */
++
++package sun.management.jmxremote;
++
++import java.io.IOException;
++import java.net.InetAddress;
++import java.net.NetworkInterface;
++import java.net.ServerSocket;
++import java.net.Socket;
++import java.net.SocketException;
++import java.rmi.server.RMIServerSocketFactory;
++import java.util.Enumeration;
++
++/**
++ * This RMI server socket factory creates server sockets that
++ * will only accept connection requests from clients running
++ * on the host where the RMI remote objects have been exported.
++ */
++public final class LocalRMIServerSocketFactory implements RMIServerSocketFactory {
++    /**
++     * Creates a server socket that only accepts connection requests from
++     * clients running on the host where the RMI remote objects have been
++     * exported.
++     */
++    public ServerSocket createServerSocket(int port) throws IOException {
++        return new ServerSocket(port) {
++            @Override
++            public Socket accept() throws IOException {
++                Socket socket = super.accept();
++                InetAddress remoteAddr = socket.getInetAddress();
++                final String msg = "The server sockets created using the " +
++                        "LocalRMIServerSocketFactory only accept connections " +
++                        "from clients running on the host where the RMI " +
++                        "remote objects have been exported.";
++                // Retrieve all the network interfaces on this host.
++                Enumeration<NetworkInterface> nis;
++                try {
++                    nis = NetworkInterface.getNetworkInterfaces();
++                } catch (SocketException e) {
++                    try {
++                        socket.close();
++                    } catch (IOException ioe) {
++                        // Ignore...
++                    }
++                    throw new IOException(msg, e);
++                }
++                // Walk through the network interfaces to see
++                // if any of them matches the client's address.
++                // If true, then the client's address is local.
++                while (nis.hasMoreElements()) {
++                    NetworkInterface ni = nis.nextElement();
++                    Enumeration<InetAddress> addrs = ni.getInetAddresses();
++                    while (addrs.hasMoreElements()) {
++                        InetAddress localAddr = addrs.nextElement();
++                        if (localAddr.equals(remoteAddr)) {
++                            return socket;
++                        }
++                    }
++                }
++                // The client's address is remote so refuse the connection.
++                try {
++                    socket.close();
++                } catch (IOException ioe) {
++                    // Ignore...
++                }
++                throw new IOException(msg);
++            }
++        };
++    }
++
++    /**
++     * Two LocalRMIServerSocketFactory objects
++     * are equal if they are of the same type.
++     */
++    @Override
++    public boolean equals(Object obj) {
++        return (obj instanceof LocalRMIServerSocketFactory);
++    }
++
++    /**
++     * Returns a hash code value for this LocalRMIServerSocketFactory.
++     */
++    @Override
++    public int hashCode() {
++        return getClass().hashCode();
++    }
++}
+--- old/src/share/lib/management/management.properties	Mon Jun  2 08:53:52 2008
++++ openjdk/jdk/src/share/lib/management/management.properties	Mon Jun  2 08:53:52 2008
+@@ -82,7 +82,7 @@
+ #
+ # com.sun.management.snmp.interface=<InetAddress>
+ #      Specifies the local interface on which the SNMP agent will bind.
+-#      This is usefull when running on machines which have several
++#      This is useful when running on machines which have several
+ #      interfaces defined. It makes it possible to listen to a specific
+ #      subnet accessible through that interface.
+ #      Default for this property is "localhost".
+@@ -144,6 +144,26 @@
+ #
+ 
+ #
++# ########## RMI connector settings for local management ##########
++#
++# com.sun.management.jmxremote.local.only=true|false
++#      Default for this property is true. (Case for true/false ignored)
++#      If this property is specified as true then the local JMX RMI connector
++#      server will only accept connection requests from clients running on
++#      the host where the out-of-the-box JMX management agent is running.
++#      In order to ensure backwards compatibility this property could be
++#      set to false. However, deploying the local management agent in this
++#      way is discouraged because the local JMX RMI connector server will
++#      accept connection requests from any client either local or remote.
++#      For remote management the remote JMX RMI connector server should
++#      be used instead with authentication and SSL/TLS encryption enabled.
++#
++
++# For allowing the local management agent accept local
++# and remote connection requests use the following line
++# com.sun.management.jmxremote.local.only=false
++
++#
+ # ###################### RMI SSL #############################
+ #
+ # com.sun.management.jmxremote.ssl=true|false
+No differences encountered
+--- old/src/share/classes/com/sun/org/apache/xerces/internal/impl/XMLDocumentScannerImpl.java	Fri May 30 16:49:25 2008
++++ openjdk/jaxp/src/share/classes/com/sun/org/apache/xerces/internal/impl/XMLDocumentScannerImpl.java	Fri May 30 16:49:25 2008
+@@ -62,6 +62,9 @@
+  * @author Arnaud  Le Hors, IBM
+  * @author Eric Ye, IBM
+  * @author Sunitha Reddy, Sun Microsystems
++ * Refer to the table in unit-test javax.xml.stream.XMLStreamReaderTest.SupportDTD for changes
++ * related to property SupportDTD.
++ * @author Joe Wang, Sun Microsystems
+  */
+ public class XMLDocumentScannerImpl
+         extends XMLDocumentFragmentScannerImpl{
+@@ -185,9 +188,6 @@
+     /** Load external DTD. */
+     protected boolean fLoadExternalDTD = true;
+ 
+-    /** Disallow doctype declaration. */
+-    protected boolean fDisallowDoctype = false;
+-
+     // state
+ 
+     /** Seen doctype declaration. */
+@@ -227,8 +227,8 @@
+     /** String. */
+     private XMLString fString = new XMLString();
+ 
+-    public static final char [] DOCTYPE = {'D','O','C','T','Y','P','E'};
+-    public static final char [] COMMENTSTRING = {'-','-'};
++    private static final char [] DOCTYPE = {'D','O','C','T','Y','P','E'};
++    private static final char [] COMMENTSTRING = {'-','-'};
+ 
+     //
+     // Constructors
+@@ -708,6 +708,12 @@
+     //
+     // Private methods
+     //
++    /** Set the scanner state after scanning DTD */
++    protected void setEndDTDScanState() {
++        setScannerState(SCANNER_STATE_PROLOG);
++        setDriver(fPrologDriver);
++        fEntityManager.setEntityHandler(XMLDocumentScannerImpl.this);
++    }
+ 
+     /** Returns the scanner state name. */
+     protected String getScannerStateName(int state) {
+@@ -930,19 +936,21 @@
+                             reportFatalError("AlreadySeenDoctype", null);
+                         }
+                         fSeenDoctypeDecl = true;
+-                        if(fDTDDriver == null){
+-                            fDTDDriver = new DTDDriver();
+-                        }
+ 
+                         // scanDoctypeDecl() sends XNI doctypeDecl event that
+                         // in SAX is converted to startDTD() event.
+                         if (scanDoctypeDecl(fDisallowDoctype)) {
++                            //allow parsing of entity decls to continue in order to stay well-formed
+                             setScannerState(SCANNER_STATE_DTD_INTERNAL_DECLS);
+                             fSeenInternalSubset = true;
++                            if(fDTDDriver == null){
++                                fDTDDriver = new DTDDriver();
++                            }
+                             setDriver(fContentDriver);
+-                            int dtdEvent = fDTDDriver.next();
++                            //always return DTD event, the event however, will not contain any entities
++                            return fDTDDriver.next();
+                             // If no DTD support, ignore and continue parsing
+-                            return fDisallowDoctype ? next() : dtdEvent;
++                            //return fDisallowDoctype ? next() : dtdEvent;
+                         }
+ 
+                         /** xxx:check this part again
+@@ -955,17 +963,18 @@
+                         }
+                          */
+ 
+-                        if (fDisallowDoctype) {
+-                            setScannerState(SCANNER_STATE_PROLOG);
+-                            return next();
+-                        }
+-
+                         // handle external subset
+                         if (fDoctypeSystemId != null) {
+                             if (((fValidation || fLoadExternalDTD)
+                                 && (fValidationManager == null || !fValidationManager.isCachedDTD()))) {
+-                                setScannerState(SCANNER_STATE_DTD_EXTERNAL);
++                                if (!fDisallowDoctype) {
++                                    setScannerState(SCANNER_STATE_DTD_EXTERNAL);
++                                } else {
++                                    setScannerState(SCANNER_STATE_PROLOG);
++                                }
+                                 setDriver(fContentDriver);
++                                if(fDTDDriver == null)
++                                    fDTDDriver = new DTDDriver();
+                                 return fDTDDriver.next();
+ 
+                             }
+@@ -976,8 +985,14 @@
+                                 // This handles the case of a DOCTYPE that had neither an internal subset or an external subset.
+                                 fDTDScanner.setInputSource(fExternalSubsetSource);
+                                 fExternalSubsetSource = null;
+-                                setScannerState(SCANNER_STATE_DTD_EXTERNAL_DECLS);
++                                if (!fDisallowDoctype) {
++                                    setScannerState(SCANNER_STATE_DTD_EXTERNAL_DECLS);
++                                } else {
++                                    setScannerState(SCANNER_STATE_PROLOG);
++                                }
+                                 setDriver(fContentDriver);
++                                if(fDTDDriver == null)
++                                    fDTDDriver = new DTDDriver();
+                                 return fDTDDriver.next();
+                             }
+                         }
+@@ -1117,19 +1132,21 @@
+                                 }
+                                 fMarkupDepth--;
+ 
+-                                // scan external subset next
+-                                if (!XMLDocumentScannerImpl.this.fDisallowDoctype &&
+-                                        fDoctypeSystemId != null && (fValidation || fLoadExternalDTD)) {
+-                                    setScannerState(SCANNER_STATE_DTD_EXTERNAL);
++                                if (fDisallowDoctype) {
++                                    //simply reset the entity store without having to mess around
++                                    //with the DTD Scanner code
++                                    fEntityStore = fEntityManager.getEntityStore();
++                                    fEntityStore.reset();
++                                } else {
++                                    // scan external subset next unless we are ignoring DTDs
++                                    if (fDoctypeSystemId != null && (fValidation || fLoadExternalDTD)) {
++                                        setScannerState(SCANNER_STATE_DTD_EXTERNAL);
++                                        break;
++                                    }
+                                 }
++                                setEndDTDScanState();
+ 
+-                                // break out of here
+-                                else {
+-                                    setScannerState(SCANNER_STATE_PROLOG);
+-                                    setDriver(fPrologDriver);
+-                                    fEntityManager.setEntityHandler(XMLDocumentScannerImpl.this);
+-                                    return true;
+-                                }
++                                return true;
+                             }
+                             break;
+                         }
+@@ -1160,13 +1177,16 @@
+                             boolean completeDTD = true;
+                             boolean moreToScan = fDTDScanner.scanDTDExternalSubset(completeDTD);
+                             if (!moreToScan) {
+-                                setScannerState(SCANNER_STATE_PROLOG);
+-                                setDriver(fPrologDriver);
+-                                fEntityManager.setEntityHandler(XMLDocumentScannerImpl.this);
++                                setEndDTDScanState();
+                                 return true;
+                             }
+                             break;
+                         }
++                        case SCANNER_STATE_PROLOG : {
++                            // skip entity decls
++                            setEndDTDScanState();
++                            return true;
++                        }
+                         default: {
+                             throw new XNIException("DTDDriver#dispatch: scanner state="+fScannerState+" ("+getScannerStateName(fScannerState)+')');
+                         }
+--- old/src/share/classes/com/sun/org/apache/xerces/internal/impl/XMLDocumentFragmentScannerImpl.java	Fri May 30 16:49:29 2008
++++ openjdk/jaxp/src/share/classes/com/sun/org/apache/xerces/internal/impl/XMLDocumentFragmentScannerImpl.java	Fri May 30 16:49:29 2008
+@@ -289,6 +289,8 @@
+     protected boolean fReportCdataEvent = false ;
+     protected boolean fIsCoalesce = false ;
+     protected String fDeclaredEncoding =  null;
++    /** Disallow doctype declaration. */
++    protected boolean fDisallowDoctype = false;
+ 
+     // drivers
+ 
+@@ -1852,6 +1854,11 @@
+         }
+         // start general entity
+         if (!fEntityStore.isDeclaredEntity(name)) {
++            //SUPPORT_DTD=false && ReplaceEntityReferences should throw exception
++            if (fDisallowDoctype && fReplaceEntityReferences) {
++                reportFatalError("EntityNotDeclared", new Object[]{name});
++                return;
++            }
+             //REVISIT: one more case needs to be included: external PE and standalone is no
+             if ( fHasExternalDTD && !fStandalone) {
+                 if (fValidation)
+--- old/src/share/classes/com/sun/xml/internal/ws/api/streaming/XMLStreamReaderFactory.java	Fri May 30 16:48:30 2008
++++ openjdk/jaxws/src/share/classes/com/sun/xml/internal/ws/api/streaming/XMLStreamReaderFactory.java	Fri May 30 16:48:30 2008
+@@ -60,6 +60,7 @@
+     static {
+         XMLInputFactory xif = XMLInputFactory.newInstance();
+         xif.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE, true);
++        xif.setProperty(XMLInputFactory.SUPPORT_DTD, false);
+ 
+         XMLStreamReaderFactory f=null;
+ 
+--- /dev/null	Mon Jun  2 16:07:10 2008
++++ openjdk/jdk/test/closed/javax/xml/stream/XMLStreamReaderTest/SupportDTD.java	Mon Jun  2 16:07:26 2008
+@@ -0,0 +1,296 @@
++/*
++ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
++ *
++ * Copyright 1997-2007 Sun Microsystems, Inc. All rights reserved.
++ *
++ * The contents of this file are subject to the terms of either the GNU
++ * General Public License Version 2 only ("GPL") or the Common Development
++ * and Distribution License("CDDL") (collectively, the "License").  You
++ * may not use this file except in compliance with the License. You can obtain
++ * a copy of the License at https://glassfish.dev.java.net/public/CDDL+GPL.html
++ * or glassfish/bootstrap/legal/LICENSE.txt.  See the License for the specific
++ * language governing permissions and limitations under the License.
++ *
++ * When distributing the software, include this License Header Notice in each
++ * file and include the License file at glassfish/bootstrap/legal/LICENSE.txt.
++ * Sun designates this particular file as subject to the "Classpath" exception
++ * as provided by Sun in the GPL Version 2 section of the License file that
++ * accompanied this code.  If applicable, add the following below the License
++ * Header, with the fields enclosed by brackets [] replaced by your own
++ * identifying information: "Portions Copyrighted [year]
++ * [name of copyright owner]"
++ *
++ * Contributor(s):
++ *
++ * If you wish your version of this file to be governed by only the CDDL or
++ * only the GPL Version 2, indicate your decision by adding "[Contributor]
++ * elects to include this software in this distribution under the [CDDL or GPL
++ * Version 2] license."  If you don't indicate a single choice of license, a
++ * recipient has the option to distribute your version of this file under
++ * either the CDDL, the GPL Version 2 or to extend the choice of license to
++ * its licensees as provided above.  However, if you add GPL Version 2 code
++ * and therefore, elected the GPL Version 2 license, then the option applies
++ * only if the new code is made subject to such option by the copyright
++ * holder.
++ */
++
++/*
++ * @test @(#)SupportDTD.java	1.1 08/03/28
++ * @bug 6542088
++ * @key cte_test
++ * @summary JAX-WS server allows XXE attacks
++ *          Fixed in JDK6u7
++ * @run main SupportDTD
++*/
++
++import java.io.StringReader;
++import java.io.File;
++import java.io.FileInputStream;
++import java.util.List;
++
++import javax.xml.stream.XMLEventReader;
++
++import javax.xml.stream.XMLInputFactory;
++import javax.xml.stream.XMLStreamConstants;
++import javax.xml.stream.XMLStreamReader;
++import javax.xml.stream.events.*;
++import javax.xml.stream.events.Characters;
++
++/**
++ *
++ * SUPPORT_DTD behavior:
++ * Regardless of supportDTD, always report a DTD event () and throw an
++ * exception if an entity reference is found when supportDTD is false
++ *
++ * The behavior is related to property IS_REPLACING_ENTITY_REFERENCES.
++ *
++ * SUPPORT_DTD      Replace Entity   DTD                    ENTITY_REFERENCE
++ * true (default)   true (default)   yes, has entities      no, return Characters
++ * true (default)   false            yes, has entities      yes, can print entity name
++ * false            true (default)   yes, but no entity     Exception: Undeclared general entity
++ * false            false            yes, but no entity     yes, can print entity name
++ *
++ * Two patches related:
++ * sjsxp issue 9: XMLDocumentScannerImpl.java rev 1.6
++ * If the supportDTD property is set to FALSE, external and internal subsets
++ * are now ignored, rather than an error being reported. In particular, with
++ * this property set to FALSE, no error is reported if an external subset cannot
++ * be found. Note that the internal subset is still parsed (and errors could be
++ * reported here) but no events are returned by the parser. This fixes SJSXP
++ * issue 9 from Java.net.
++ * Note: SAX and DOM report fatal errors:
++ *       If either SAX or DOM is used, turning on http://apache.org/xml/features/disallow-doctype-decl [1] effectively disables DTD,
++ *       according to the spec: A fatal error is thrown if the incoming document contains a DOCTYPE declaration.
++ *       The current jaxp implementation actually throws a nullpointexception. A better error message could be used.
++ *
++ * This change is required by CR 6542088.
++ * @author joe.wang@sun.com
++ */
++public class SupportDTD  {
++    static final boolean DEBUG = false;
++    static final String _file = "./tests/XMLStreamReader/ExternalDTD.xml";
++    static final String XML = "<?xml version='1.0' ?>"
++            +"<!DOCTYPE root [\n"
++            +"<!ENTITY intEnt 'internal entity'>\n"
++            +"<!ENTITY extParsedEnt SYSTEM 'url:dummy'>\n"
++            +"<!NOTATION notation PUBLIC 'notation-public-id'>\n"
++            +"<!NOTATION notation2 SYSTEM 'url:dummy'>\n"
++            +"<!ENTITY extUnparsedEnt SYSTEM 'url:dummy2' NDATA notation>\n"
++            +"]>"
++            +"<root>&intEnt;</root>";
++    static final String XML1 = "<?xml version='1.0' encoding ='utf-8'?>"
++            +"<!DOCTYPE document SYSTEM \"tests/XMLStreamReader/ExternalDTD.dtd\">"
++            +"<document>"
++            +       "<name>&mkm;</name>"
++            +"</document>";
++    
++    static final int ENTITY_INTERNAL_ONLY = 1;
++    static final int ENTITY_EXTERNAL_ONLY = 2;
++    static final int ENTITY_BOTH = 3;
++    
++    static boolean _DTDReturned = false;
++    static boolean _EntityEventReturned = false;
++    static boolean _hasEntityDelaration = false;
++    static boolean _exceptionThrown = false;
++
++    public static void reset() {
++        _DTDReturned = false;
++        _EntityEventReturned = false;
++        _hasEntityDelaration = false;
++        _exceptionThrown = false;
++    }
++
++    /**
++     * @param args the command line arguments
++     */
++    public static void main(String[] args) {
++        test1();
++        test2();
++        test3();
++        test4();
++        test5();
++        test6();
++        test7();
++        test8();
++        test9();
++        test10();
++        test11();
++        test12();
++    }
++    
++    //tests 1-4 test internal entities only
++    public static void test1() {
++        supportDTD(true, true, ENTITY_INTERNAL_ONLY);
++        assertEquals(true, _DTDReturned);
++        assertEquals(true, _hasEntityDelaration);
++        assertEquals(false, _EntityEventReturned);
++    }
++    public static void test2() {
++        supportDTD(true, false, ENTITY_INTERNAL_ONLY);
++        assertEquals(true, _DTDReturned);
++        assertEquals(true, _hasEntityDelaration);
++        assertEquals(true, _EntityEventReturned);
++    }
++    public static void test3() {
++        supportDTD(false, true, ENTITY_INTERNAL_ONLY);
++        assertEquals(true, _DTDReturned);
++        assertEquals(false, _hasEntityDelaration);
++        assertEquals(true, _exceptionThrown);
++    }
++    public static void test4() {
++        supportDTD(false, false, ENTITY_INTERNAL_ONLY);
++        assertEquals(true, _DTDReturned);
++        assertEquals(false, _hasEntityDelaration);
++        assertEquals(true, _EntityEventReturned);
++    }
++    //tests 5-8 test external entities only
++    public static void test5() {
++        supportDTD(true, true, ENTITY_INTERNAL_ONLY);
++        assertEquals(true, _DTDReturned);
++        assertEquals(true, _hasEntityDelaration);
++        assertEquals(false, _EntityEventReturned);
++    }
++    public static void test6() {
++        supportDTD(true, false, ENTITY_INTERNAL_ONLY);
++        assertEquals(true, _DTDReturned);
++        assertEquals(true, _hasEntityDelaration);
++        assertEquals(true, _EntityEventReturned);
++    }
++    public static void test7() {
++        supportDTD(false, true, ENTITY_INTERNAL_ONLY);
++        assertEquals(true, _DTDReturned);
++        assertEquals(false, _hasEntityDelaration);
++        assertEquals(true, _exceptionThrown);
++    }
++    public static void test8() {
++        supportDTD(false, false, ENTITY_INTERNAL_ONLY);
++        assertEquals(true, _DTDReturned);
++        assertEquals(false, _hasEntityDelaration);
++        assertEquals(true, _EntityEventReturned);
++    }    
++    //tests 9-12 test both internal and external entities
++    public static void test9() {
++        supportDTD(true, true, ENTITY_INTERNAL_ONLY);
++        assertEquals(true, _DTDReturned);
++        assertEquals(true, _hasEntityDelaration);
++        assertEquals(false, _EntityEventReturned);
++    }
++    public static void test10() {
++        supportDTD(true, false, ENTITY_INTERNAL_ONLY);
++        assertEquals(true, _DTDReturned);
++        assertEquals(true, _hasEntityDelaration);
++        assertEquals(true, _EntityEventReturned);
++    }
++    public static void test11() {
++        supportDTD(false, true, ENTITY_INTERNAL_ONLY);
++        assertEquals(true, _DTDReturned);
++        assertEquals(false, _hasEntityDelaration);
++        assertEquals(true, _exceptionThrown);
++    }
++    public static void test12() {
++        supportDTD(false, false, ENTITY_INTERNAL_ONLY);
++        assertEquals(true, _DTDReturned);
++        assertEquals(false, _hasEntityDelaration);
++        assertEquals(true, _EntityEventReturned);
++    }    
++    
++    public static void assertEquals(boolean bExpected, boolean bActual) {
++        if (bExpected != bActual) {
++            throw new RuntimeException("Test Failed");
++        }
++    }    
++
++    public static void supportDTD(boolean supportDTD, boolean replaceEntity, int inputType) {
++        reset();
++        print("\n");
++        print((supportDTD?"SupportDTD=true":"SupportDTD=false") + ", " + (replaceEntity?"replaceEntity=true":"replaceEntity=false"));
++        try {
++            XMLInputFactory xif = getFactory(supportDTD, replaceEntity);
++            XMLEventReader r = getEventReader(xif, inputType);
++            int eventType = 0;
++            int count = 0;
++            while (r.hasNext()) {
++                XMLEvent event = r.nextEvent();
++                eventType = event.getEventType();
++                print("Event " + ++count +": " + eventType);
++                switch (eventType) {
++                    case XMLStreamConstants.DTD :
++                        DisplayEntities((DTD)event);
++                        _DTDReturned = true;
++                        break;
++                    case XMLStreamConstants.ENTITY_REFERENCE :
++                        print("Entity Name: " + ((EntityReference)event).getName());
++                        _EntityEventReturned = true;
++                        break;
++                    case XMLStreamConstants.CHARACTERS :
++                        print("Text: " + ((Characters)event).getData());
++                }
++            }
++            
++        } catch (Exception e) {
++            _exceptionThrown = true;
++            if (DEBUG) e.printStackTrace();
++        }
++    }
++    
++    static XMLInputFactory getFactory(boolean supportDTD, boolean replaceEntity) {
++        XMLInputFactory xif = XMLInputFactory.newInstance();
++        xif.setProperty(XMLInputFactory.SUPPORT_DTD, (supportDTD)?Boolean.TRUE:Boolean.FALSE);
++        xif.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, (replaceEntity)?Boolean.TRUE:Boolean.FALSE);
++        //xif.setProperty(XMLInputFactory.IS_VALIDATING, Boolean.TRUE);
++        return xif;
++    }
++    static private XMLEventReader getEventReader(XMLInputFactory inputFactory, int input)
++    throws Exception {
++        XMLEventReader er = null;
++        if (input == ENTITY_INTERNAL_ONLY) {
++            er = inputFactory.createXMLEventReader(new StringReader(XML));
++        } else if (input == ENTITY_EXTERNAL_ONLY) {
++            er = inputFactory.createXMLEventReader(new StringReader(XML1));
++        } else {
++            File file = new File(_file);
++            FileInputStream inputStream = new FileInputStream(file);
++            //XMLStreamReader r = xif.createXMLStreamReader(inputStream);
++            er = inputFactory.createXMLEventReader(inputStream);
++        }
++        return er;
++    }
++    static void DisplayEntities(DTD event) {
++        List entities = event.getEntities();
++        if (entities == null) {
++            _hasEntityDelaration = false;
++            print("No entity found.");
++        } else {
++            _hasEntityDelaration = true;
++            for (int i=0; i<entities.size(); i++) {
++                EntityDeclaration entity = (EntityDeclaration)entities.get(i);
++                print(entity.getName());
++            }
++        }
++        
++    }
++    static void print(String s) {
++        if (DEBUG) System.out.println(s);
++    }
++    
++}
+--- old/src/share/classes/com/sun/org/apache/xml/internal/utils/ThreadControllerWrapper.java	Fri May 30 17:01:31 2008
++++ openjdk/jaxp/src/share/classes/com/sun/org/apache/xml/internal/utils/ThreadControllerWrapper.java	Fri May 30 17:01:31 2008
+@@ -53,7 +53,35 @@
+   {
+ 
+     /**
+-     * Will get a thread from the pool, execute the task
++      * This class was introduced as a fix for CR 6607339.
++      */
++     final class SafeThread extends Thread {
++          private volatile boolean ran = false;
++                  
++          public SafeThread(Runnable target) {
++              super(target);
++          }
++                  
++          public final void run() {
++              if (Thread.currentThread() != this) {
++                  throw new IllegalStateException("The run() method in a"
++                      + " SafeThread cannot be called from another thread.");
++              }
++              synchronized (this) {
++                 if (!ran) {
++                     ran = true;
++                 }
++                 else {
++                  throw new IllegalStateException("The run() method in a"
++                      + " SafeThread cannot be called more than once.");
++                 }                 
++              }             
++              super.run();
++          }
++     }
++ 
++     /**
++     *  Will get a thread from the pool, execute the task
+      *  and return the thread to the pool.
+      *
+      *  The return value is used only to wait for completion
+@@ -68,7 +96,7 @@
+     public Thread run(Runnable task, int priority)
+     {
+ 
+-      Thread t = new Thread(task);
++      Thread t = new SafeThread(task);
+ 
+       t.start();
+ 
+--- /dev/null	Mon Jun  2 16:57:20 2008
++++ openjdk/jdk/test/closed/com/sun/org/apache/xml/internal/utils/Test.java	Mon Jun  2 16:57:36 2008
+@@ -0,0 +1,110 @@
++/*
++ * @test @(#)Test.java	1.2 08/04/23
++ * @bug 6607339
++ * @key cte_test
++ * @summary IncrementalSAXSource_Filter still allows reading of local files
++ * @compile Test.java
++ * @run shell Test6607339.sh
++*/
++/*
++ * Test.java
++ *
++ * Created on February 20, 2007, 10:42 AM
++ *
++ * To change this template, choose Tools | Template Manager
++ * and open the template in the editor.
++ */
++
++import java.lang.reflect.*;
++
++import com.sun.org.apache.xml.internal.dtm.ref.DTMManagerDefault;
++import java.awt.EventQueue;
++import java.io.File;
++
++/**
++ * Test for CR 6607339. Note that this isn't a unit test, but a
++ * standalone test instead. Correct termination is based on the 
++ * exact number of remaining threads and requires calling System.exit(). 
++ * Thus, it cannot be executed as a unit test
++ *
++ * @author Santiago.PericasGeertsen@sun.com
++ */
++public class Test {
++    
++    public static void main(String[] args) throws Exception {
++        new Test().test();
++    }
++    
++    public void test() throws Exception {
++        // The GNOME Accessibility JavaBridge will not initialise
++        // from an untrusted context.
++        // So we need to load the toolkit before the security manager is set.
++        java.awt.Toolkit.getDefaultToolkit();
++
++        // Target XML filewe should not be able to access.
++        // Requires full path name.
++        java.io.File target = 
++                new File(getClass().getResource("target.xml").getFile());
++        String systemID = target.toURI().toURL().toString();
++
++        System.setSecurityManager(new SecurityManager());
++
++        DTMManagerDefault manager = new DTMManagerDefault() {
++            // We need a SAXParser that does the job of SAXParser
++            //   without quite being SAXParser itself.
++            // So we return an instance of an (anonymous) subclass.
++            public org.xml.sax.XMLReader getXMLReader(
++                javax.xml.transform.Source inputSource
++            ) {
++                org.xml.sax.XMLReader reader =
++                    super.getXMLReader(inputSource);
++                return
++                   new
++                       com.sun.org.apache.xerces.internal.parsers.
++                       SAXParser() { };
++            }
++        };
++        // Enable incremental parsing.
++        manager.setIncremental(true);
++
++        // Grab old threads, so we can detect the new one.
++        java.util.Set oldThreads = getThreads();
++
++        com.sun.org.apache.xml.internal.dtm.DTM dtm =
++            manager.getDTM(
++                new javax.xml.transform.stream.StreamSource(systemID),
++                true, // unique
++                null, // DTMWSFilter
++                true, // incremental
++                false // doIndexing
++            );
++
++        // Should be exactly one new thread.
++        java.util.Set threads = getThreads();
++        threads.removeAll(oldThreads);
++        if (threads.size() != 1) {
++            throw new Error(threads.toString());
++        }
++        Thread thread = (Thread) threads.iterator().next();
++        // Suspend the thread.
++        thread.suspend();
++        // Run the Thread as a Runnable
++        //   without user code on the stack.
++        java.awt.EventQueue.invokeLater(thread);
++
++        // Ensure correct termination by counting number of threads
++        Thread.sleep(100);
++        assert getThreads().size() == 5;
++
++        // Call exit to kill all remaining threads
++        System.exit(0);
++    }
++    
++    private static java.util.Set getThreads() {
++        Thread[] threads = new Thread[Thread.activeCount()*2+10];
++        Thread.enumerate(threads);
++        return new java.util.HashSet(
++            java.util.Arrays.asList(threads)
++        );
++    }
++}
+--- /dev/null	Mon Jun  2 16:57:21 2008
++++ openjdk/jdk/test/closed/com/sun/org/apache/xml/internal/utils/target.xml	Mon Jun  2 16:57:37 2008
+@@ -0,0 +1,2 @@
++<?xml version="1.0"?>
++<doc>this is a secret</doc>
+--- old/src/share/vm/opto/parse3.cpp	Wed Apr  9 12:49:10 2008
++++ openjdk/hotspot/src/share/vm/opto/parse3.cpp	Wed Apr  9 12:49:08 2008
+@@ -398,7 +398,7 @@
+   // fill the lowest dimensions with unknown sizes
+   for (int index = 0; index < mdimensions - ndimensions; index++) {
+     const TypeAry* arr0 = TypeAry::make(prev_type, TypeInt::POS);
+-    prev_type = TypeAryPtr::make(TypePtr::BotPTR, arr0, prev_array, true, 0);
++    prev_type = TypeAryPtr::make(TypePtr::BotPTR, arr0, prev_array, false, 0);
+     prev_array = NULL; // array klasses can be lazy, except the first
+   }
+ 
+--- /dev/null	Mon Jun  2 09:19:39 2008
++++ openjdk/jdk/test/sun/management/jmxremote/bootstrap/LocalOnlyTest.java	Mon Jun  2 09:19:39 2008
+@@ -0,0 +1,97 @@
++/*
++ * Copyright 2007 Sun Microsystems, Inc.  All Rights Reserved.
++ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
++ *
++ * This code is free software; you can redistribute it and/or modify it
++ * under the terms of the GNU General Public License version 2 only, as
++ * published by the Free Software Foundation.
++ *
++ * This code is distributed in the hope that it will be useful, but WITHOUT
++ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
++ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
++ * version 2 for more details (a copy is included in the LICENSE file that
++ * accompanied this code).
++ *
++ * You should have received a copy of the GNU General Public License version
++ * 2 along with this work; if not, write to the Free Software Foundation,
++ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
++ *
++ * Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa Clara,
++ * CA 95054 USA or visit www.sun.com if you need additional information or
++ * have any questions.
++ */
++
++/*
++ * @test
++ * @bug 6685178
++ * @summary Sanity check for local only option. In order to fully test this
++ *          new local only option two different machines would be required.
++ * @author Luis-Miguel Alventosa
++ * @run main/othervm LocalOnlyTest
++ * @run main/othervm -Dcom.sun.management.jmxremote.local.only=true LocalOnlyTest
++ * @run main/othervm -Dcom.sun.management.jmxremote.local.only=false LocalOnlyTest
++ * @run main/othervm -Dcom.sun.management.jmxremote LocalOnlyTest
++ * @run main/othervm -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=true LocalOnlyTest
++ * @run main/othervm -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.local.only=false LocalOnlyTest
++ * @run main/othervm -Dcom.sun.management.jmxremote.port=0 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false LocalOnlyTest
++ * @run main/othervm -Dcom.sun.management.jmxremote.port=0 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.local.only=true LocalOnlyTest
++ * @run main/othervm -Dcom.sun.management.jmxremote.port=0 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.local.only=false LocalOnlyTest
++ */
++
++import java.io.*;
++import java.lang.management.*;
++import java.util.*;
++import javax.management.*;
++import javax.management.remote.*;
++import com.sun.tools.attach.*;
++
++public class LocalOnlyTest {
++
++    public static void main(String args[]) throws Exception {
++        RuntimeMXBean rt = ManagementFactory.getRuntimeMXBean();
++        String name = rt.getName();
++        System.out.println("name = " + name);
++        String vmid = name.substring(0, name.indexOf("@"));
++        System.out.println("vmid = " + vmid);
++        VirtualMachine vm = VirtualMachine.attach(vmid);
++        String addr = vm.getAgentProperties().getProperty(
++                "com.sun.management.jmxremote.localConnectorAddress");
++        System.out.println("connectorAddress = " + addr);
++        if (addr == null) {
++            // Normally in ${java.home}/jre/lib/management-agent.jar
++            // but might be in ${java.home}/lib in build environments.
++            String javaHome = System.getProperty("java.home");
++            String agent = javaHome + File.separator + "jre" + File.separator +
++                    "lib" + File.separator + "management-agent.jar";
++            File f = new File(agent);
++            if (!f.exists()) {
++                agent = javaHome + File.separator + "lib" + File.separator +
++                        "management-agent.jar";
++                f = new File(agent);
++                if (!f.exists()) {
++                    throw new IOException("Management agent not found");
++                }
++            }
++            agent = f.getCanonicalPath();
++            try {
++                vm.loadAgent(agent, "com.sun.management.jmxremote");
++            } catch (AgentLoadException x) {
++                IOException ioe = new IOException(x.getMessage());
++                ioe.initCause(x);
++                throw ioe;
++            } catch (AgentInitializationException x) {
++                IOException ioe = new IOException(x.getMessage());
++                ioe.initCause(x);
++                throw ioe;
++            }
++            addr = vm.getAgentProperties().getProperty(
++                    "com.sun.management.jmxremote.localConnectorAddress");
++            System.out.println("connectorAddress (after loading agent) = " + addr);
++        }
++        vm.detach();
++        JMXServiceURL url = new JMXServiceURL(addr);
++        JMXConnector c = JMXConnectorFactory.connect(url);
++        System.out.println("connectionId  = " + c.getConnectionId());
++        System.out.println("Bye! Bye!");
++    }
++}
diff -Nru icedtea6-1.2.orig/patches/icedtea-version.patch icedtea6-1.2/patches/icedtea-version.patch
--- icedtea6-1.2.orig/patches/icedtea-version.patch	2008-04-24 20:43:46.000000000 +0100
+++ icedtea6-1.2/patches/icedtea-version.patch	2008-09-14 21:57:29.000000000 +0100
@@ -13,7 +13,7 @@
 -  LAUNCHER_NAME = openjdk
 -  PRODUCT_NAME = OpenJDK
 +  LAUNCHER_NAME = java
-+  PRODUCT_NAME = OpenJDK 
++  PRODUCT_NAME = IcedTea6
    PRODUCT_SUFFIX = Runtime Environment
    COMPANY_NAME =
  endif
