diff --git a/CHANGELOG b/CHANGELOG
index 3397b3b..c5fb124 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -6,6 +6,7 @@
 - fix pasre error in replicated server module.
 - correct spelling error in default config.
 - fix default auth config not being installed.
+- change LDAP query method as my test db was incorrect.
 
 20/6/2006 autofs-5.0.0_beta5
 ---------------------------
diff --git a/include/lookup_ldap.h b/include/lookup_ldap.h
index 0d14b1b..db6389c 100644
--- a/include/lookup_ldap.h
+++ b/include/lookup_ldap.h
@@ -14,6 +14,7 @@ struct lookup_context {
 
 	char *server;
 	char *base;
+	char *qdn;
 
 	/* LDAP version 2 or 3 */
 	int version;
diff --git a/modules/lookup_ldap.c b/modules/lookup_ldap.c
index 8a6faca..2910d38 100644
--- a/modules/lookup_ldap.c
+++ b/modules/lookup_ldap.c
@@ -683,6 +683,88 @@ static void free_context(struct lookup_c
 	return;
 }
 
+static int get_query_dn(LDAP *ldap, struct lookup_context *ctxt)
+{
+	char buf[PARSE_MAX_BUF];
+	char *query, *dn;
+	LDAPMessage *result, *e;
+	char *class, *key;
+	char *attrs[2];
+	int rv, l;
+
+	class = ctxt->map_obj_class;
+	key = ctxt->map_attr;
+
+	attrs[0] = LDAP_NO_ATTRS;
+	attrs[1] = NULL;
+
+	if (!ctxt->mapname && !ctxt->base) {
+		error(LOGOPT_ANY, MODPREFIX "no master map to lookup");
+		return 0;
+	}
+
+	/* Build a query string. */
+	l = strlen("(objectclass=)") + strlen(class) + 1;
+	if (ctxt->mapname)
+		l += strlen(key) + strlen(ctxt->mapname) + strlen("(&(=))");
+
+	query = alloca(l);
+	if (query == NULL) {
+		char *estr = strerror_r(errno, buf, MAX_ERR_BUF);
+		crit(LOGOPT_ANY, MODPREFIX "alloca: %s", estr);
+		return NSS_STATUS_UNAVAIL;
+	}
+
+	/*
+	 * If we have a master mapname construct a query using it
+	 * otherwise assume the base dn will catch it.
+	 */
+	if (ctxt->mapname) {
+		if (sprintf(query, "(&(objectclass=%s)(%s=%.*s))", class,
+		     key, (int) strlen(ctxt->mapname), ctxt->mapname) >= l) {
+			debug(LOGOPT_NONE,
+			      MODPREFIX "error forming query string");
+			return 0;
+		}
+	} else {
+		if (sprintf(query, "(objectclass=%s)", class) >= l) {
+			debug(LOGOPT_NONE,
+			      MODPREFIX "error forming query string");
+			return 0;
+		}
+	}
+	query[l] = '\0';
+
+	rv = ldap_search_s(ldap, ctxt->base, LDAP_SCOPE_ONE,
+			   query, attrs, 0, &result);
+
+	if ((rv != LDAP_SUCCESS) || !result) {
+		error(LOGOPT_NONE,
+		      MODPREFIX "query failed for %s: %s",
+		      query, ldap_err2string(rv));
+		ldap_unbind_connection(ldap, ctxt);
+		return 0;
+	}
+
+	e = ldap_first_entry(ldap, result);
+	if (e) {
+		dn = ldap_get_dn(ldap, e);
+		debug(LOGOPT_NONE, MODPREFIX "query dn %s", dn);
+		ldap_msgfree(result);
+	} else {
+		debug(LOGOPT_NONE,
+		      MODPREFIX "query succeeded, no matches for %s",
+		      query);
+		ldap_msgfree(result);
+		ldap_unbind_connection(ldap, ctxt);
+		return 0;
+	}
+
+	ctxt->qdn = dn;
+
+	return 1;
+}
+
 /*
  * This initializes a context (persistent non-global data) for queries to
  * this module.  Return zero if we succeed.
@@ -746,6 +828,13 @@ #endif
 		return 1;
 	}
 
+	if (!get_query_dn(ldap, ctxt)) {
+		error(LOGOPT_ANY, MODPREFIX "failed to get query dn");
+		ldap_unbind_connection(ldap, ctxt);
+		free_context(ctxt);
+		return 1;
+	}
+
 	/* Okay, we're done here. */
 	ldap_unbind_connection(ldap, ctxt);
 
@@ -770,14 +859,13 @@ int lookup_read_master(struct master *ma
 	char buf[PARSE_MAX_BUF];
 	char *query;
 	LDAPMessage *result, *e;
-	char *class, *key, *info, *entry;
+	char *class, *info, *entry;
 	char **keyValue = NULL;
 	char **values = NULL;
 	char *attrs[3];
 	LDAP *ldap;
 
 	class = ctxt->entry_obj_class;
-	key = ctxt->map_attr;
 	entry = ctxt->entry_attr;
 	info = ctxt->value_attr;
 
@@ -785,15 +873,7 @@ int lookup_read_master(struct master *ma
 	attrs[1] = info;
 	attrs[2] = NULL;
 
-	if (!ctxt->mapname && !ctxt->base) {
-		error(LOGOPT_ANY, MODPREFIX "no master map to lookup");
-		return NSS_STATUS_UNAVAIL;
-	}
-
-	/* Build a query string. */
 	l = strlen("(objectclass=)") + strlen(class) + 1;
-	if (ctxt->mapname)
-		l += strlen(key) + strlen(ctxt->mapname) + strlen("(&(=))");
 
 	query = alloca(l);
 	if (query == NULL) {
@@ -802,22 +882,9 @@ int lookup_read_master(struct master *ma
 		return NSS_STATUS_UNAVAIL;
 	}
 
-	/*
-	 * If we have a master mapname construct a query using it
-	 * otherwise assume the base dn will catch it.
-	 */
-	memset(query, '\0', l);
-	if (ctxt->mapname) {
-		if (sprintf(query, "(&(objectclass=%s)(%s=%.*s))", class,
-		     key, (int) strlen(ctxt->mapname), ctxt->mapname) >= l) {
-			debug(LOGOPT_NONE,
-			      MODPREFIX "error forming query string");
-		}
-	} else {
-		if (sprintf(query, "(objectclass=%s)", class) >= l) {
-			debug(LOGOPT_NONE,
-			      MODPREFIX "error forming query string");
-		}
+	if (sprintf(query, "(objectclass=%s)", class) >= l) {
+		debug(LOGOPT_NONE, MODPREFIX "error forming query string");
+		return NSS_STATUS_UNAVAIL;
 	}
 	query[l] = '\0';
 
@@ -828,11 +895,10 @@ int lookup_read_master(struct master *ma
 
 	/* Look around. */
 	debug(LOGOPT_NONE,
-	      MODPREFIX "searching for \"%s\" under \"%s\"",
-	      query, ctxt->base ? ctxt->base : "(default)");
+	      MODPREFIX "searching for \"%s\" under \"%s\"", query, ctxt->qdn);
 
-	rv = ldap_search_s(ldap, ctxt->base, LDAP_SCOPE_SUBTREE,
-			   query, attrs, 0, &result);
+	rv = ldap_search_s(ldap, ctxt->qdn,
+			   LDAP_SCOPE_SUBTREE, query, attrs, 0, &result);
 
 	if ((rv != LDAP_SUCCESS) || !result) {
 		error(LOGOPT_NONE,
@@ -929,7 +995,6 @@ next:
 }
 
 static int read_one_map(struct autofs_point *ap,
-			const char *keyval, int keyvallen,
 			struct lookup_context *ctxt,
 			time_t age, int *result_ldap)
 {
@@ -939,7 +1004,7 @@ static int read_one_map(struct autofs_po
 	char buf[MAX_ERR_BUF];
 	char *query;
 	LDAPMessage *result, *e;
-	char *class, *key, *info, *entry;
+	char *class, *info, *entry;
 	char **keyValue = NULL;
 	char **values = NULL;
 	char *attrs[3];
@@ -951,7 +1016,6 @@ static int read_one_map(struct autofs_po
 	}
 
 	class = ctxt->entry_obj_class;
-	key = ctxt->map_attr;
 	entry = ctxt->entry_attr;
 	info = ctxt->value_attr;
 
@@ -961,9 +1025,6 @@ static int read_one_map(struct autofs_po
 
 	/* Build a query string. */
 	l = strlen("(objectclass=)") + strlen(class) + 1;
-	if (keyvallen > 0) {
-		l += strlen(key) + keyvallen + strlen("(&(=))");
-	}
 
 	query = alloca(l);
 	if (query == NULL) {
@@ -972,22 +1033,9 @@ static int read_one_map(struct autofs_po
 		return NSS_STATUS_UNAVAIL;
 	}
 
-	/*
-	 * If we have a mapname (keyval) construct a query using it
-	 * otherwise assume the base dn will catch it.
-	 */
-	memset(query, 0, l);
-	if (keyvallen > 0) {
-		if (sprintf(query, "(&(objectclass=%s)(%s=%.*s))", class,
-			    key, keyvallen, keyval) >= l) {
-			error(ap->logopt,
-			      MODPREFIX "error forming query string");
-		}
-	} else {
-		if (sprintf(query, "(objectclass=%s)", class) >= l) {
-			error(ap->logopt,
-			      MODPREFIX "error forming query string");
-		}
+	if (sprintf(query, "(objectclass=%s)", class) >= l) {
+		error(ap->logopt, MODPREFIX "error forming query string");
+		return NSS_STATUS_UNAVAIL;
 	}
 	query[l] = '\0';
 
@@ -998,10 +1046,9 @@ static int read_one_map(struct autofs_po
 
 	/* Look around. */
 	debug(ap->logopt,
-	      MODPREFIX "searching for \"%s\" under \"%s\"",
-	      query, ctxt->base ? ctxt->base : "(default)");
+	      MODPREFIX "searching for \"%s\" under \"%s\"", query, ctxt->qdn);
 
-	rv = ldap_search_s(ldap, ctxt->base, LDAP_SCOPE_SUBTREE,
+	rv = ldap_search_s(ldap, ctxt->qdn, LDAP_SCOPE_SUBTREE,
 			   query, attrs, 0, &result);
 
 	if ((rv != LDAP_SUCCESS) || !result) {
@@ -1145,14 +1192,7 @@ int lookup_read_map(struct autofs_point 
 	int keylen;
 	int ret;
 
-	key = ctxt->mapname;
-	keylen = strlen(ctxt->mapname);
-
-	if (key)
-		ret = read_one_map(ap, key, keylen, ctxt, age, &rv);
-	else
-		ret = read_one_map(ap, NULL, 0, ctxt, age, &rv);
-
+	ret = read_one_map(ap, ctxt, age, &rv);
 	if (ret != NSS_STATUS_SUCCESS) {
 		switch (rv) {
 		case LDAP_SIZELIMIT_EXCEEDED:
@@ -1174,7 +1214,7 @@ static int lookup_one(struct autofs_poin
 	time_t age = time(NULL);
 	char *query;
 	LDAPMessage *result, *e;
-	char *class, *info, *map, *entry;
+	char *class, *info, *entry;
 	char **keyValue;
 	char **values = NULL;
 	char *attrs[3];
@@ -1188,7 +1228,6 @@ static int lookup_one(struct autofs_poin
 	}
 
 	class = ctxt->entry_obj_class;
-	map = ctxt->map_attr;
 	entry = ctxt->entry_attr;
 	info = ctxt->value_attr;
 
@@ -1200,13 +1239,7 @@ static int lookup_one(struct autofs_poin
 		*qKey = '/';
 
 	/* Build a query string. */
-	if (ctxt->mapname) {
-		l = strlen(class) 
-			+ strlen(map) + strlen(ctxt->mapname)
-			+ strlen(entry) + strlen(qKey) + 28;
-	} else {
-		l = strlen(class) + strlen(entry) + strlen(qKey) + 21;
-	}
+	l = strlen(class) + strlen(entry) + strlen(qKey) + 21;
 
 	query = alloca(l);
 	if (query == NULL) {
@@ -1215,24 +1248,11 @@ static int lookup_one(struct autofs_poin
 		return CHE_FAIL;
 	}
 
-	/* Look around. */
-	memset(query, 0, l);
-	if (ctxt->mapname) {
-		/*
-		 * Look for an entry in class containing map
-		 * ctxt->mapname whose entry is equal to qKey.
-		 */
-		ql = sprintf(query,
-			 "(&(&(objectclass=%s)(%s=%s)(%s=%s)))",
-			 class, map, ctxt->mapname, entry, qKey);
-	} else {
-		/*
-		 * Look for an entry in class under ctxt-base
-		 * whose entry is equal to qKey.
-		 */
-		ql = sprintf(query,
-			 "(&(objectclass=%s)(%s=%s))", class, entry, qKey);
-	}
+	/*
+	 * Look for an entry in class under ctxt-base
+	 * whose entry is equal to qKey.
+	 */
+	ql = sprintf(query, "(&(objectclass=%s)(%s=%s))", class, entry, qKey);
 	if (ql >= l) {
 		error(ap->logopt,
 		      MODPREFIX "error forming query string");
@@ -1241,15 +1261,14 @@ static int lookup_one(struct autofs_poin
 	query[ql] = '\0';
 
 	debug(ap->logopt,
-	      MODPREFIX "searching for \"%s\" under \"%s\"",
-	      query, ctxt->base ? ctxt->base : "(default)");
+	      MODPREFIX "searching for \"%s\" under \"%s\"", query, ctxt->qdn);
 
 	/* Initialize the LDAP context. */
 	ldap = do_connect(ctxt);
 	if (!ldap)
 		return CHE_FAIL;
 
-	rv = ldap_search_s(ldap, ctxt->base, LDAP_SCOPE_SUBTREE,
+	rv = ldap_search_s(ldap, ctxt->qdn, LDAP_SCOPE_SUBTREE,
 			   query, attrs, 0, &result);
 
 	if ((rv != LDAP_SUCCESS) || !result) {
@@ -1511,6 +1530,8 @@ #if WITH_SASL
 	EVP_cleanup();
 	ERR_free_strings();
 #endif
+	if (ctxt->qdn)
+		ldap_memfree(ctxt->qdn);
 	free_context(ctxt);
 	return rv;
 }
