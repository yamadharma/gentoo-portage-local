diff -U8 -rNp moc-2.4.1/config.example moc-2.4.1.new/config.example
--- moc-2.4.1/config.example	2006-10-31 11:21:18 +0300
+++ moc-2.4.1.new/config.example	2006-10-31 11:12:03 +0300
@@ -128,16 +128,19 @@ UseMmap			= yes
 # UTF-8 is not used here and MOC can't guess how tags are encoded. Another
 # solution is using librcc (see the next option). This option is ignored
 # if UseRCC is set to yes.
 #ID3v1TagsEncoding		= WINDOWS-1250
 
 # Use librcc to fix ID3 version 1/1.1 tags encoding.
 #UseRCC				= yes
 
+# Use librcc to filenames and directory names encoding.
+#UseRCCForFilesystem			= yes
+
 # Remember the playlist after exit?
 SavePlaylist		= yes
 
 # When using more than one client (interface) at a time, do the share the
 # playlist?
 SyncPlaylist		= yes
 
 # Choose a keymap file (relative to ~/.moc/ or absolute path)
diff -U8 -rNp moc-2.4.1/interface_elements.c moc-2.4.1.new/interface_elements.c
--- moc-2.4.1/interface_elements.c	2006-10-31 11:21:18 +0300
+++ moc-2.4.1.new/interface_elements.c	2006-10-31 11:10:06 +0300
@@ -909,17 +909,16 @@ static char *make_menu_title (const char
 			if (slash && slash != title) {
 				char *old_title = title;
 				
 				title = xstrdup (slash + 1);
 				free (old_title);
 			}
 		}
 	}
-
 	return title;
 }
 
 /* Add an item from the playlist to the menu.
  * If full_paths has non-zero value, full paths will be displayed instead of
  * just file names.
  * Return a non-zero value if the added item is visible on the screen. */
 static int add_to_menu (struct menu *menu, const struct plist *plist,
@@ -997,19 +996,28 @@ static void side_menu_make_list_content 
 		menu_item_set_attr_normal (added, get_color(CLR_MENU_ITEM_DIR));
 		menu_item_set_attr_sel (added,
 				get_color(CLR_MENU_ITEM_DIR_SELECTED));
 	}
 	
 	if (dirs)
 		for (i = 0; i < dirs->num; i++) {
 			char title[PATH_MAX];
+			char *t_str = NULL;
 
 			strcpy (title, strrchr(dirs->items[i], '/') + 1);
 			strcat (title, "/");
+#ifdef HAVE_RCC 
+			if (options_get_int("UseRCCForFilesystem")) {
+				t_str = xstrdup (title);
+				t_str = iconv_rcc (t_str);
+				snprintf(title, PATH_MAX, "%s", t_str);
+				free(t_str);
+			}
+#endif
 			
 			added = menu_add (m->menu.list.main, title, F_DIR,
 					dirs->items[i]);
 			menu_item_set_attr_normal (added,
 					get_color(CLR_MENU_ITEM_DIR));
 			menu_item_set_attr_sel (added,
 					get_color(CLR_MENU_ITEM_DIR_SELECTED));
 		}
diff -U8 -rNp moc-2.4.1/Makefile.am moc-2.4.1.new/Makefile.am
--- moc-2.4.1/Makefile.am	2006-10-31 11:21:20 +0300
+++ moc-2.4.1.new/Makefile.am	2006-10-29 12:37:50 +0300
@@ -67,16 +67,16 @@ EXTRA_mocp_SOURCES = gnugetopt.h \
 		     alsa.h \
 		     io_curl.c \
 		     io_curl.h \
 		     jack.c \
 		     jack.h
 man_MANS = mocp.1
 mocp_LDADD = @EXTRA_OBJS@
 mocp_DEPENDENCIES = @EXTRA_OBJS@
-mocp_LDFLAGS = @EXTRA_LIBS@
+mocp_LDFLAGS = @EXTRA_LIBS@ $(RCC_LIBS)
 EXTRA_DIST = config.example mocp.1 THANKS keymap.example Doxyfile \
 	     doxy_pages/decoder_api.doxy doxy_pages/main_page.doxy \
 	     doxy_pages/sound_output_driver_api.doxy moc.spec.in \
 	     moc.spec
 
 docdir = $(datadir)/doc/$(PACKAGE)
 doc_DATA = config.example THANKS README keymap.example
diff -U8 -rNp moc-2.4.1/options.c moc-2.4.1.new/options.c
--- moc-2.4.1/options.c	2006-10-31 11:21:18 +0300
+++ moc-2.4.1.new/options.c	2006-10-31 11:12:45 +0300
@@ -209,16 +209,17 @@ void options_init ()
 	option_add_str ("Layout2",
 			"directory:0,0,100%,100% playlist:0,0,100%,100%");
 	option_add_str ("Layout3", NULL);
 	option_add_int ("FollowPlayedFile", 1);
 	option_add_int ("CanStartInPlaylist", 1);
 	option_add_int ("UseCursorSelection", 0);
 	option_add_str ("ID3v1TagsEncoding", "WINDOWS-1250");
 	option_add_int ("UseRCC", 1);
+	option_add_int ("UseRCCForFilesystem", 1);
 	option_add_int ("SetXtermTitle", 1);
 	option_add_int ("PlaylistFullPaths", 1);
 }
 
 /* Return 1 if a parameter to an integer option is valid. */
 int check_int_option (const char *name, const int val)
 {
 	/* YES/NO options */
@@ -234,16 +235,17 @@ int check_int_option (const char *name, 
 			|| !strcasecmp(name, "SavePlaylist")
 			|| !strcasecmp(name, "SyncPlaylist")
 			|| !strcasecmp(name, "Mp3IgnoreCRCErrors")
 			|| !strcasecmp(name, "PlaylistNumbering")
 			|| !strcasecmp(name, "FollowPlayedFile")
 			|| !strcasecmp(name, "CanStartInPlaylist")
 			|| !strcasecmp(name, "UseCursorSelection")
 			|| !strcasecmp(name, "UseRCC")
+			|| !strcasecmp(name, "UseRCCForFilesystem")
 			|| !strcasecmp(name, "SetXtermTitle")
 			|| !strcasecmp(name, "PlaylistFullPaths")
 			) {
 		if (!(val == 1 || val == 0))
 			return 0;
 	}
 	else if (!strcasecmp(name, "OutputBuffer")) {
 		if (val < 128)
diff -U8 -rNp moc-2.4.1/playlist.c moc-2.4.1.new/playlist.c
--- moc-2.4.1/playlist.c	2006-10-31 11:21:20 +0300
+++ moc-2.4.1.new/playlist.c	2006-10-31 11:10:14 +0300
@@ -26,16 +26,17 @@
 #define DEBUG
 
 #include "playlist.h"
 #include "common.h"
 #include "log.h"
 #include "options.h"
 #include "files.h"
 #include "rbtree.h"
+#include "utf8.h"
 
 /* Initial size of the table */
 #define	INIT_SIZE	64
 
 void tags_free (struct file_tags *tags)
 {
 	assert (tags != NULL);
 
@@ -661,16 +662,23 @@ void plist_set_title_tags (struct plist 
 /* Set file title of an item. */
 void plist_set_title_file (struct plist *plist, const int num,
 		const char *title)
 {
 	assert (num >= 0 && num < plist->num);
 
 	if (plist->items[num].title_file)
 		free (plist->items[num].title_file);
+#ifdef  HAVE_RCC
+	if (options_get_int("UseRCCForFilesystem")) {
+		char *t_str = xstrdup (title);
+		plist->items[num].title_file = iconv_rcc(t_str);
+		return;
+	}
+#endif
 	plist->items[num].title_file = xstrdup (title);
 }
 
 /* Set file for an item. */
 void plist_set_file (struct plist *plist, const int num, const char *file)
 {
 	assert (num >=0 && num < plist->num);
 	assert (file != NULL);
diff -U8 -rNp moc-2.4.1/utf8.c moc-2.4.1.new/utf8.c
--- moc-2.4.1/utf8.c	2006-10-31 11:21:18 +0300
+++ moc-2.4.1.new/utf8.c	2006-10-31 11:15:44 +0300
@@ -17,16 +17,19 @@
 #ifndef OPENBSD
 # define _XOPEN_SOURCE  500 /* for wcswidth() */
 #endif
 
 #include <stdarg.h>
 #ifdef HAVE_ICONV
 # include <iconv.h>
 #endif
+#ifdef HAVE_RCC
+# include <librcc.h>
+#endif
 #ifdef HAVE_NL_TYPES_H
 # include <nl_types.h>
 #endif
 #ifdef HAVE_LANGINFO_H
 # include <langinfo.h>
 #endif
 
 #ifdef HAVE_NCURSESW_H
@@ -47,16 +50,40 @@
 
 static char *terminal_charset = NULL;
 static int using_utf8 = 0;
 
 #ifdef HAVE_ICONV
 static iconv_t iconv_desc = (iconv_t)(-1);
 #endif
 
+char *iconv_rcc (char *str)
+{
+#ifdef HAVE_RCC
+	rcc_string rccstring;
+	char *reencoded;
+
+	assert (str != NULL);
+
+	rccstring = rccFrom(NULL, 0, str);
+	if (rccstring) {
+		if (*rccstring && (reencoded = rccToCharset(NULL, "UTF-8", rccstring))) {
+		    free(str);
+		    free(rccstring);
+		    return reencoded;
+		}
+		
+		free (rccstring);
+	}
+	return str;
+#endif /* HAVE_RCC */
+	return xstrdup (str);
+}
+
+
 /* Return a malloc()ed string converted using iconv().
  * if for_file_name is not 0, uses the conversion defined for file names.
  * For NULL returns NULL. */
 char *iconv_str (const iconv_t desc, const char *str)
 {
 #ifdef HAVE_ICONV
 	char buf[512];
 	char *inbuf, *outbuf;
@@ -291,16 +318,19 @@ int xwprintw (WINDOW *win, const char *f
 
 static void iconv_cleanup ()
 {
 #ifdef HAVE_ICONV
 	if (iconv_desc != (iconv_t)(-1)
 			&& iconv_close(iconv_desc) == -1)
 		logit ("iconv_close() failed: %s", strerror(errno));
 #endif
+#ifdef HAVE_RCC
+	rccFree ();
+#endif
 }
 
 void utf8_init ()
 {
 #ifdef HAVE_NL_LANGINFO_CODESET
 #ifdef HAVE_NL_LANGINFO
 	terminal_charset = xstrdup (nl_langinfo(CODESET));
 	assert (terminal_charset != NULL);
@@ -325,16 +355,32 @@ void utf8_init ()
 
 #ifdef HAVE_ICONV
 	if (!using_utf8 && terminal_charset) {
 		iconv_desc = iconv_open (terminal_charset, "UTF-8");
 		if (iconv_desc == (iconv_t)(-1))
 			logit ("iconv_open() failed: %s", strerror(errno));
 	}
 #endif
+#ifdef HAVE_RCC
+	rcc_class classes[] = {
+		{ "input", RCC_CLASS_STANDARD, NULL, NULL, "Input Encoding",
+			0 },
+		{ "output", RCC_CLASS_KNOWN, NULL, NULL,
+			"Output Encoding", 0 },
+		{ NULL, 0, NULL, NULL, NULL, 0 }
+	};
+
+	rccInit ();
+	rccInitDefaultContext(NULL, 0, 0, classes, 0);
+	rccLoad(NULL, "moc");
+	rccSetOption(NULL, RCC_OPTION_TRANSLATE,
+			RCC_OPTION_TRANSLATE_SKIP_PARRENT);
+	rccSetOption(NULL, RCC_OPTION_AUTODETECT_LANGUAGE, 1);
+#endif /* HAVE_RCC */
 }
 
 void utf8_cleanup ()
 {
 	if (terminal_charset)
 		free (terminal_charset);
 	iconv_cleanup ();
 }
diff -U8 -rNp moc-2.4.1/utf8.h moc-2.4.1.new/utf8.h
--- moc-2.4.1/utf8.h	2006-10-31 11:21:18 +0300
+++ moc-2.4.1.new/utf8.h	2006-10-29 21:56:41 +0300
@@ -32,10 +32,11 @@ int xwprintw (WINDOW *win, const char *f
 #endif
 
 size_t strwidth (const char *s);
 char *xstrtail (const char *str, const int len);
 
 #ifdef HAVE_ICONV
 char *iconv_str (const iconv_t desc, const char *str);
 #endif
+char *iconv_rcc (char *str);
 
 #endif
