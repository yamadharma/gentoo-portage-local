#!/bin/sh
#!/sbin/runscript
# Copyright 1999-2003 Gentoo Technologies, Inc.
# Distributed under the terms of the GNU General Public License, v2 or later
# $Header: $
#
# chkconfig: 2345 61 61
# description: Startup/shutdown script for Xprint server(s)
#
############################################################################
#
# This script has three main tasks:
# 1. Start Xprint servers ("Xprt") at boot time.
# 2. Shutdown Xprint servers when the machine is being shut down.
# 3. Query the list of available printers.
#
# Additional tasks are:
# 4. Restart ('restart'|'reload'|'force-reload') and conditional restart
#    ('condrestart') for Linux support
# 5. Wrapping of application call with setting XPSERVERLIST ('wrapper')
#
# Usage:
# - Start Xprint server(s) manually:
#   % /etc/init.d/xprint start
#
# - Stop Xprint server(s) manually:
#   % /etc/init.d/xprint stop
#
# - Populate $XPSERVERLIST env var (for example as part of a global
#   login script like /etc/profile or per-user login scripts like
#   $HOME/.profile (sh/ksh/bash))
#   % XPSERVERLIST="`/etc/init.d/xprint get_xpserverlist`"
#   % export XPSERVERLIST
#
# Installation:
#   Copy this script to /etc/init.d/xprint, create links to the matching
#   run levels and make sure that the script is executable.
#   Examples:
#     - Solaris 2.7/2.8:
#       % cp xprint /etc/init.d/xprint
#       % chmod a+rx /etc/init.d/xprint
#       % ln /etc/init.d/xprint /etc/rc0.d/K38xprint
#       % ln /etc/init.d/xprint /etc/rc1.d/K38xprint
#       % ln /etc/init.d/xprint /etc/rc2.d/S81xprint
#       % ln /etc/init.d/xprint /etc/rcS.d/K38xprint
#
#     - SuSE Linux 7.3
#       % cp xprint /etc/init.d/xprint
#       % chmod a+rx /etc/init.d/xprint
#       % ln -s ../xprint /etc/init.d/rc3.d/K13xprint
#       % ln -s ../xprint /etc/init.d/rc3.d/S12xprint
#       % ln -s ../xprint /etc/init.d/rc5.d/K13xprint
#       % ln -s ../xprint /etc/init.d/rc5.d/S12xprint
#       % ln -s ../xprint /etc/init.d/rc2.d/K13xprint
#       % ln -s ../xprint /etc/init.d/rc2.d/S12xprint
#
#     - SuSE Linux 6.4:
#       % cp xprint /sbin/init.d/xprint
#       % chmod a+rx /sbin/init.d/xprint
#       % ln -s ../xprint /sbin/init.d/rc2.d/K20xprint
#       % ln -s ../xprint /sbin/init.d/rc2.d/S20xprint
#       % ln -s ../xprint /sbin/init.d/rc3.d/K20xprint
#       % ln -s ../xprint /sbin/init.d/rc3.d/S20xprint
#
#   Notes: 
#   - The Xprint servers must be started _after_ the print
#     spooler or the server(s) may refuse to start
#   - The script should be readable by all users to ensure that they
#     can use the "get_xpserverlist"-option
#
# Custom configuration:
#   - Edit the function setup_config() in this script to match your needs
#
# Known bugs/ToDo/Notes:
#   - The shell script assumes that a Xserver can be reached via 
#     "hostname:displaynum" where "hostname" is obtained from
#     "/usr/bin/hostname". It may happen that a kernel firewall
#     blocks an X connection on the same host (e.g. client && Xserver 
#     are running on the same host).
#     Suggested fix: Fix the firewall config.
#     Suggested workaround: Edit this script and replace the use of 
#     /usr/bin/hostname with "echo 'localhost'".
#
############################################################################

opts="${opts} get_xpserverlist"

XPRT_BIN=/usr/X11R6/bin/Xprt_xprint_org
SERVICENAME="Xprint servers"

############################################################################

# Set the location of the global file where we store the locations 
# of the system-wide servers

XPROJECTROOT=/usr/X11R6

if [ -d /var/run ] ; then
    XP_GLOBAL_SERVERS=/var/run/Xprint_servers
else
    XP_GLOBAL_SERVERS=/tmp/.Xprint_servers
fi

# ${LOGNAME} will not work if user su'ed into another account
export CURRLOGNAME="$(getent passwd $(id -u) | cut -f 1 -d ':')"

# Set location where we want to store the list of Xprint servers managed
# by this user
# - If we start as "root" use the global file
# - If we start as normal user use a per-user file

if [ "${CURRLOGNAME}" != "root" -a "${CURRLOGNAME}" != "" ] ; 
then
    XP_PER_USER_SERVERS="/tmp/.Xprint_servers_${CURRLOGNAME}"
    XP_SERVERS="${XP_PER_USER_SERVERS}"
else
    XP_SERVERS="${XP_GLOBAL_SERVERS}"
fi

############################################################################

# {{{ Get list of fonts

# Get list of system fonts
get_system_fontlist()
{
    find ${XPROJECTROOT}/lib/X11/fonts -name fonts.dir | \
        while read i ; 
	do 
	    echo "${i%/fonts.dir}" ; done | \
            (fontpath="" ; fpdelim=""; 
        while read i ; 
	do
            fontpath="${fontpath}${fpdelim}${i}" ; fpdelim="," ; 
        done ; 
        echo "$fontpath") | \
        tr "," "\n" | sort | uniq
}

# Get list of fonts for a given display
get_fontlist_from_display()
{
    ${XPROJECTROOT}/bin/xset -display "${1}" q | 
      awk "/Font Path:/ { i=1 ; next } i==1 { print \$0 ; i=0 }" | 
        fontpath2fontlist
}

# Get list from a fontserver config
get_fontlist_from_xfs_config()
{
    (
      if [ "${1}" ] ; 
      then
          XFS_CONFIG_FILE="${1}"
      else
          XFS_CONFIG_FILE="/etc/X11/fs/config"
      fi
    
      cat "${XFS_CONFIG_FILE}" |
      while read -r i ; 
      do
          for val in $i; 
	  do
              case $val in
                \#*)  
		    break 
		    ;;	
                ?*=*) 
		    key="${val%%=*}" 
		    ;;
                =*)   
		    key="${tok}" 
		    ;;
                *)    
		    [ "${key}" = "catalogue" -a "${tok}" != "" ] && echo "${tok}" 
		    ;;
              esac
              tok="${val#*=}"
          done
      done
      [ "${key}" = "catalogue" -a "${tok}" != "" ] && echo "${tok}"
    ) | tr "," "[\n]" | fontpath2fontlist
}

# Filter fonts per given extended regular expressions
# (and make sure we filter any model-config fonts - they are managed by Xprt internally)
filter_fontlist()
{
    egrep -- "${1}" | fgrep -v "/models/" | egrep -v -- "${2}"
}

# Filter dirs with TrueType fonts
filter_ttf_fontlist()
{
    egrep -v "/TrueType|/truetype|/TT(/$|$)|/TTF(/$|$)"
}

# Validate fontpath
# Only return valid font path entries (note that these entries may
# include non-file stuff like font server references)
validate_fontlist()
{
    while read i ; do       
        case "${i}" in
            # Check if font path entry is a font server...
            tcp/*|tcp6/*|unix/*)
                echo "${i}"
                ;;
            # ... if not check if the path is accessible
            # and has a valid "fonts.dir" index
            *)
                [ -f "${i}/fonts.dir" ] && echo "${i}"
                ;;
        esac
    done
}

# Build a comma-seperated list of fonts (font path) from a list of fonts
fontlist2fontpath()
{
    fp=""
    read fp;
    while read i ; do
        fp="${fp},${i}"
    done
    
    echo "$fp"
}

# Build a list (one item per line) of fonts from a font path
fontpath2fontlist()
{
    while read i ; do
        echo "${i}" | tr "," "\n"
    done
}

# Sort scaleable fonts (PS Type1 and TrueType) first in a font list
sort_scaleable_fonts_first()
{
    i="$(fontlist2fontpath)"
    # First list PS Type1 fonts...
    echo "${i}" | fontpath2fontlist | fgrep "/Type1"
    # ... then TrueType fonts ...
    echo "${i}" | fontpath2fontlist | egrep "/TrueType|/truetype|/TT(/$|$)|/TTF(/$|$)"
    # ... then all others
    echo "${i}" | fontpath2fontlist | egrep -v "/Type1|/TrueType|/truetype|/TT(/$|$)|/TTF(/$|$)"
}

# }}}

# Check if a X display is used by a Xserver or not
# Known bugs:
# - there is no way in plain bourne shell or bash (see comment about ksh93
#   below) to test if a Xserver sits only on a socket and not on a pipe
# - some Xserver's don't cleanup their stuff in /tmp on exit which may end
#   in the problem that we don't detect possible free display numbers
#   (one problem is that only ksh93 can do stuff like 
#   "cat </dev/tcp/0.0.0.0/6001")
CheckIfDisplayIsInUse()
{
    id=$1
    
    [ -r "/tmp/.X${id}-lock"     ] && return 0;
    [ -r "/tmp/.X11-unix/X${id}" ] && return 0;
    [ -r "/tmp/.X11-pipe/X${id}" ] && return 0;
    
    return 1;
}

lastdisplaynumreturned_store=/tmp/.Xp_last_display_returned_by_findfreexdisplaynum_${RANDOM}_${RANDOM}

# Try to find a free display number
FindFreeXDisplayNum()
{
    if [ -r "${lastdisplaynumreturned_store}" ] ; 
    then
      i="$(cat "${lastdisplaynumreturned_store}")"
    else
      i=32 # start at display 32
    fi
    
    while [ $i -lt 127 ] ; 
    do
        i=$(($i + 1))

        if CheckIfDisplayIsInUse $i ; 
	then
            true
        else
            echo "$i"
            echo "$i" >"${lastdisplaynumreturned_store}"
            return 0
        fi
    done
    
    return 1
}

# Check if a process exists or not
pexists()
{
    [ "$1" = "" ] && return 1;

    # Use of /proc would be better but not all platforms (like AIX) have procfs
    [ "$(ps -p $1 | fgrep $1)" != "" ] && return 0;
    return 1
}

# Start Xprint servers
start_servers()
{
    # Write registry "intro" ...
    einfo "Xprint server list"                               >>"${XP_SERVERS}"
    einfo "File is for private use for ${0}."                >>"${XP_SERVERS}"
    einfo "Do not edit, rely on the content or file format." >>"${XP_SERVERS}"

    hostname="$(hostname)"

    default_fontpath="$(get_system_fontlist | fontlist2fontpath)"
    default_fontpath_acceptpattern=".*";
    default_fontpath_rejectpattern="_No_Match_"; # Match nothing   
    
    curr=0
    while [ $curr -lt $num_xpstart ] ; 
    do
        if [ "${xpstart_remote_server[$curr]}" != "" ] ; then
            # Remote Xprt, just put the entry into the registry
            echo "display=${xpstart_remote_server[$curr]}" >>"${XP_SERVERS}"
        else
            # Run block in seperate process to avoid that changes to the
            # xpstart_* variables affect the next cycle
            (
              # Use defaults if there are no special options
              [ "${xpstart_fontpath[$curr]}"               = "" ] &&               xpstart_fontpath[$curr]="${default_fontpath}";
              [ "${xpstart_fontpath_acceptpattern[$curr]}" = "" ] && xpstart_fontpath_acceptpattern[$curr]="$default_fontpath_acceptpattern";
              [ "${xpstart_fontpath_rejectpattern[$curr]}" = "" ] && xpstart_fontpath_rejectpattern[$curr]="$default_fontpath_rejectpattern";
              [ "${xpstart_enable_truetype[$curr]}"        = "" ] &&        xpstart_enable_truetype[$curr]="false";
              [ "${xpstart_font_encodings_dir[$curr]}"     = "" ] &&     xpstart_font_encodings_dir[$curr]="${XPROJECTROOT}/lib/X11/fonts/encodings/encodings.dir";
              [ "${xpstart_displayid[$curr]}"              = "" ] &&              xpstart_displayid[$curr]="$(FindFreeXDisplayNum)"       
              [ "${xpstart_logger[$curr]}"                 = "" ] &&                 xpstart_logger[$curr]="logger -p lpr.notice -t Xprt_${xpstart_displayid[$curr]}";
              [ "${xpstart_logfile[$curr]}"                = "" ] &&                xpstart_logfile[$curr]="/dev/null";
              [ "${xpstart_xprt_binary[$curr]}"            = "" ] &&            xpstart_xprt_binary[$curr]="${XPRT_BIN}";
              if [ "${xpstart_xprt_binary[$curr]}" = "/usr/openwin/bin/Xprt" -o "$(uname -s)" = "SunOS" ] ; then
                  # Solaris /usr/openwin/bin/Xprt does not support "-nolisten tcp"
                  # yet nor is it possible to run a Xserver on a unix socket only
                  # in Solaris since access to the unix domain sockets in
                  # /tmp/.X11-pipe and /tmp/.X11-unix is restricted to applications
                  # with group-id "root" (e.g. the Xprt server would need to be
                  # setgid "root" that plain users can start it listening on a unix
                  # socket only)
                  [ "${xpstart_options[$curr]}" = "" ] && xpstart_options[$curr]="-ac -pn"
              else
                  [ "${xpstart_options[$curr]}" = "" ] && xpstart_options[$curr]="-ac -pn -nolisten tcp"
              fi

              # Check if the Xprt binary is available                                     
              if [ ! -x "${xpstart_xprt_binary[$curr]}" ] ; then                                            
                  error_echo "Can't find \"${xpstart_xprt_binary[$curr]}\"."                                  
                  exit 1 # exit block                                                               
              fi                                                                          

              # Verify and set location of font encodings directory file
              unset FONT_ENCODINGS_DIRECTORY
              if ${xpstart_enable_truetype[$curr]} ; then
                  if [ ! -f "${xpstart_font_encodings_dir[$curr]}" ] ; then
                      warning_echo "Can't find \"${xpstart_font_encodings_dir[$curr]}\", TrueType font support disabled."
                      xpstart_enable_truetype[$curr]="false";
                  else
                      if [ "${xpstart_xprt_binary[$curr]}" != "/usr/openwin/bin/Xprt" ] ; then
                          if [ "${xpstart_font_encodings_dir[$curr]}" = "/usr/openwin/lib/X11/fonts/encodings/encodings.dir" ] ; then
                              warning_echo "\"${xpstart_font_encodings_dir[$curr]}\" is in Solaris format which is not supported by non-Solaris Xprt servers, TrueType font support disabled."
                              xpstart_enable_truetype[$curr]="false";
                          fi
                      fi
                  fi
              fi
              if ${xpstart_enable_truetype[$curr]} ; then
                  export FONT_ENCODINGS_DIRECTORY="${xpstart_font_encodings_dir[$curr]}"
              fi

              # Generate font path (containing only valid font path elements)
              # from input font path and filter expressions
              curr_fp=$(echo "${xpstart_fontpath[$curr]}" | 
                        fontpath2fontlist |
                        (if ${xpstart_enable_truetype[$curr]} ; then cat ; else filter_ttf_fontlist ; fi) |
                        filter_fontlist "${xpstart_fontpath_acceptpattern[$curr]}" "${xpstart_fontpath_rejectpattern[$curr]}" | 
                        sort_scaleable_fonts_first | 
                        validate_fontlist | 
                        fontlist2fontpath)

              # Set Xserver auditing level option
              unset curr_audit
              if [ "${xpstart_auditlevel[$curr]}" != "" ] ; then
                  curr_audit="-audit ${xpstart_auditlevel[$curr]}"
              fi

              # Set Xprt -XpFile option
              unset curr_xpfile
              if [ "${xpstart_xpfile[$curr]}" != "" ] ; then
                  curr_xpfile="-XpFile ${xpstart_xpfile[$curr]}"
              fi

              # Set custom XPCONFIGDIR (if there is one)
              unset XPCONFIGDIR
              if [ "${xpstart_xpconfigdir[$curr]}" != "" ] ; then
                  export XPCONFIGDIR="${xpstart_xpconfigdir[$curr]}"
              fi

              # If someone uses "-nolisten tcp" make sure we do not add a hostname to force local transport
              if [ "$(echo "${xpstart_options[$curr]}" | egrep "nolisten.*tcp")" != "" ] ; then
                  xp_display=":${xpstart_displayid[$curr]}"
              else
                  xp_display="${hostname}:${xpstart_displayid[$curr]}"
              fi
              
              (
                (
                  "${xpstart_xprt_binary[$curr]}" \
                      ${xpstart_options[$curr]} \
                      ${curr_xpfile} ${curr_audit} \
                      -fp ${curr_fp} \
                      :${xpstart_displayid[$curr]} &
                  echo "display=${xp_display} display_id=${xpstart_displayid[$curr]} pid=$!" >>"${XP_SERVERS}"
                ) 2>&1 | tee -a "${xpstart_logfile[$curr]}" | ${xpstart_logger[$curr]}
              ) &
              sleep 2 # try to avoid that two started procs append to ${XP_SERVERS} at the same time
            )
        fi
        
        curr=$(($curr + 1))
    done
    
    # Remove tmp. file created by |FindFreeXDisplayNum()|
    rm -f "${lastdisplaynumreturned_store}"

    # Done.
    echo "# EOF." >>"${XP_SERVERS}"
    return 0
}

# Convenience function to obtain a list of available Xprint servers
get_xpserverlist()
{
    if [ -f "${XP_PER_USER_SERVERS}" -o -f "${XP_GLOBAL_SERVERS}" ] ; then
        xpserverlist=$(
          # Enumerate both per-user and global servers (in that order)
          (
            [ -f "${XP_PER_USER_SERVERS}" ]  && cat "${XP_PER_USER_SERVERS}"
            [ -f "${XP_GLOBAL_SERVERS}"   ]  && cat "${XP_GLOBAL_SERVERS}"
          ) |
            egrep "^display=.*:.* pid=[0-9]*$|^display=.*:[0-9]*$" |
              while read i ; do
                  (
                    pid="none"
                    eval ${i}
                    # Check if the Xprt process exists (if possible)
                    if [ "$pid" != "none" ] ; then
                        if pexists ${pid} ; then
                            echo ${display}
                        fi
                    else
                        echo ${display}
                    fi
                  )
              done | tr "[\n]" " "
          )
        # Only produce output if we have some entries...
        [ "${xpserverlist}" != "" ] && echo "${xpserverlist}"
    fi
}

# Set platform-defaults for setup_config()
setup_config_defaults()
{
    curr_num_xpstart="${1}"
    
    #### Defaults for Linux/Solaris
    # Start Xprt using builtin XPCONFIGDIR at a free display numer
    # (Solaris(=SunOS5.x)'s /usr/openwin/bin/Xprt supports TrueType fonts,
    # therefore we don't need to filter them)
                      xpstart_fontpath[${curr_num_xpstart}]="";
        xpstart_fontpath_acceptpattern[${curr_num_xpstart}]=".*";
    if [ "$(uname -s)" = "SunOS" ] ; then
        # Solaris /usr/openwin/bin/Xprt supports TrueType fonts
               xpstart_enable_truetype[${curr_num_xpstart}]="true";
        xpstart_fontpath_rejectpattern[${curr_num_xpstart}]="/Speedo|/F3bitmaps|/F3";
    else
        # xprint.mozdev.org-based Xprt servers support TrueType fonts since version 0.8
               xpstart_enable_truetype[${curr_num_xpstart}]="true";
        xpstart_fontpath_rejectpattern[${curr_num_xpstart}]="/Speedo";
    fi
                     xpstart_displayid[${curr_num_xpstart}]="";
                   xpstart_xpconfigdir[${curr_num_xpstart}]="";
                        xpstart_xpfile[${curr_num_xpstart}]="";
                    xpstart_auditlevel[${curr_num_xpstart}]="4";
                       xpstart_options[${curr_num_xpstart}]="";
                        xpstart_logger[${curr_num_xpstart}]="";
    if [ "$(uname -s)" = "AIX" ] ; then
                       xpstart_logfile[${curr_num_xpstart}]="/dev/tty";
    else
                       xpstart_logfile[${curr_num_xpstart}]="/dev/stderr";
    fi
                   xpstart_xprt_binary[${curr_num_xpstart}]="";

    # Custom rules for the GISWxprintglue package on Solaris
    # (which uses Solaris's /usr/openwin/bin/Xprt but a custom config)
    if [ "${XPCUSTOMGLUE}" = "GISWxprintglue" ] ; then
        xpstart_xpconfigdir[${curr_num_xpstart}]="/opt/GISWxprintglue/server/etc/XpConfig"
        xpstart_xprt_binary[${curr_num_xpstart}]="/usr/openwin/bin/Xprt";
    fi
    # Custom rules for the GISWxprint package on Solaris
    # (which uses both it's own Xprt and a custom config)
    if [ "${XPCUSTOMGLUE}" = "GISWxprint" ] ; then
        xpstart_xpconfigdir[${curr_num_xpstart}]="/opt/GISWxprint/server/etc/XpConfig"
        xpstart_xprt_binary[${curr_num_xpstart}]="/opt/GISWxprint/bin/Xprt";
    fi
    
    #######################################################
    ###
    ### Debian Xprint package default configuration
    ###
    if [ "${XPCUSTOMGLUE}" = "DebianGlue" ] ; then
        # Set XPCONFIGDIR=/usr/share/Xprint/xserver
        xpstart_xpconfigdir[${curr_num_xpstart}]="/usr/share/Xprint/xserver";

        # Use fixed display ID (":64"), or else all client programs will have to be
        # restarted simply to update XPSERVERLIST to the latest ID when upgrading,
        # which would be a nightmare.
        xpstart_displayid[${curr_num_xpstart}]=64;

        # Do not send any messages to console
        xpstart_logfile[${curr_num_xpstart}]="/dev/null";

        # By default use binary provided by Debian's "xprt-xprintorg" package
        # (=/usr/bin/Xprt), otherwise leave blank (e.g. use script's default
        # (=/usr/X11R6/bin/Xprt))
        if [ -x "/usr/bin/Xprt" ] ; 
	then
            xpstart_xprt_binary[${curr_num_xpstart}]="/usr/bin/Xprt";
        fi
    fi
    ###
    ### End Debian default configuration
    ###
    #######################################################
}

fetch_etc_initd_xprint_envvars()
{
    curr_num_xpstart="${1}"

    ## Process some $ETC_INITD_XPRINT_* vars after all which may be used by
    # a user to override the hardcoded values here when starting Xprt per-user
    # (a more flexible way is to provide an own setup config script in
    # "~./Xprint_per_user_startup" - see above)
    if [ "${ETC_INITD_XPRINT_XPRT_PATH}" != "" ] ; 
    then
        xpstart_xprt_binary[${curr_num_xpstart}]="${ETC_INITD_XPRINT_XPRT_PATH}"
    fi
    if [ "${ETC_INITD_XPRINT_XPCONFIGDIR}" != "" ] ; then
        xpstart_xpconfigdir[${curr_num_xpstart}]="${ETC_INITD_XPRINT_XPCONFIGDIR}"
    fi
    if [ "${ETC_INITD_XPRINT_XPFILE}" != "" ] ; then
        xpstart_xpfile[${curr_num_xpstart}]="${ETC_INITD_XPRINT_XPFILE}"
    fi
    if [ "${ETC_INITD_XPRINT_LOGFILE}" != "" ] ; then
        xpstart_logfile[${curr_num_xpstart}]="${ETC_INITD_XPRINT_LOGFILE}"
    fi
    if [ "${ETC_INITD_XPRINT_DISPLAYID}" != "" ] ; then
        xpstart_displayid[${curr_num_xpstart}]="${ETC_INITD_XPRINT_DISPLAYID}"
    fi
    if [ "${ETC_INITD_XPRINT_FONTPATH}" != "" ] ; then
        xpstart_fontpath[${curr_num_xpstart}]="${ETC_INITD_XPRINT_FONTPATH}"
    fi
    if [ "${ETC_INITD_XPRINT_XPRT_OPTIONS}" != "" ] ; then
        xpstart_options[${curr_num_xpstart}]="${ETC_INITD_XPRINT_XPRT_OPTIONS}"
    fi
    if [ "${ETC_INITD_XPRINT_AUDITLEVEL}" != "" ] ; then
        xpstart_auditlevel[${curr_num_xpstart}]="${ETC_INITD_XPRINT_AUDITLEVEL}"
    fi
}

############################################################################
# setup_config() sets the configuration parameters used to start one
# or more Xprint servers ("Xprt").
# The following variables are used:
# - "num_xpstart" - number of servers to start
# - "xpstart_fontpath[index]" - custom font path. Leave blank if you want
#   the platform-specific default
# - "xpstart_fontpath_acceptpattern[index]" - extended regular expression
#   (see egrep(1)) used to filter the font path - items only pass this
#   filter if they match the pattern (leave blank if you want to filter
#   nothing)
# - "xpstart_fontpath_rejectpattern[index]" - extended regular expression
#   (see egrep(1)) used to filter the font path - items only pass this
#   filter if they do not match the pattern (leave blank if you want to
#   filter nothing)
# - "xpstart_font_encodings_dir[index]" - location of "encodings.dir".
#   Leave blank to use the default.
# - "xpstart_enable_truetype[index]" - use "true" or "false" to enable or
#   disable use of TrueType fonts, leave blank to use the systems default
# - "xpstart_displayid[index]" - display id to use for the Xprint server
#   (leave blank to choose the next available free display id)
# - "xpstart_xpconfigdir[index]" - value for custom XPCONFIGDIR (leave blank
#   if you don not want that that XPCONFIGDIR is set at Xprt startup)
# - "xpstart_xpfile[index]" - value used for Xprt's "-XpFile" option (leave
#   blank if you do not want to set this option)
# - "xpstart_auditlevel[index]" - set Xserver auditing level (leave blank to
#   use no auditing)
# - "xpstart_options[index]" - set further Xprt options (leave blank to set
#   no further options)
# - "xpstart_logger[index]" - utility which gets stderr/stdout messages from
#   Xprt and sends them to a logging daemon. Leave blank to use /usr/bin/logger
#   to send such messages to the lpr.notice syslog)
# - "xpstart_logfile[index]" - log file to append stderr/stdout messages from
#   Xprt to. Leave blank to send messages to /dev/null
# - "xpstart_xprt_binary[index]" - set custom Xprt binary (leave blank to use
#   the platform-specifc default)
setup_config()
{
    num_xpstart=0;
    
    if [ "${ETC_INITD_XPRINT_CUSTOM_SETUP_CONFIG}" != "" ] ; then
        user_cfg="${ETC_INITD_XPRINT_CUSTOM_SETUP_CONFIG}"
    else
        user_cfg="${HOME}/.Xprint_per_user_startup"
    fi
    
    # Source per-user ~/.Xprint_per_user_startup file if there is one
    # (and do not use the script's defaults below)
    if [ -r "${user_cfg}" ] ; then
        # Define API version which should be checked by ${HOME}/.Xprint_per_user_startup
        # ${HOME}/.Xprint_per_user_startup should bail-out if the version differ
        etc_initd_xprint_api_version=2
        
        # Source per-user settings script
        . "${user_cfg}"
        
        # done with setting the config for per-user Xprt instances
        return 0;
    else
        # Use /etc/init.d/xprint's builtin config
        # Each entry should start with |setup_config_defaults| to pull the
        # platform defaults and finish with |num_xpstart=$(($num_xpstart + 1))|
        # to end the entry
        
        # Set platform-defaults
        setup_config_defaults "${num_xpstart}"

        ## -- snip --

        # Admins can put their stuff "in" here...

        ## -- snip --

        # Override script's builtin values with those a user may set via the
        # $ETC_INIITD_XPRINT_* env vars
        fetch_etc_initd_xprint_envvars "${num_xpstart}"

        num_xpstart=$((${num_xpstart} + 1))

        return 0;
    fi

    #### Sample 1:
    # # Start Xprt on a free display ID with custom XPCONFIGDIR and without
    # # Speedo and TrueType fonts
    #    xpstart_fontpath_rejectpattern[$num_xpstart]="/Speedo|/TrueType|/TT(/$|$)|/TTF(/$|$)";
    #               xpstart_xpconfigdir[$num_xpstart]="/home/gisburn/cwork/Xprint/Xprt_config/XpConfig";
    #                xpstart_auditlevel[$num_xpstart]="4";
    #                   xpstart_options[$num_xpstart]="-ac -pn";
    #num_xpstart=$(($num_xpstart + 1))


    #### Sample 2: 
    # # Start Xprt without TrueType fonts on a display 55 with custom
    # # XPCONFIGDIR
    #    xpstart_fontpath_rejectpattern[$num_xpstart]="/TrueType|/TT(/$|$)|/TTF(/$|$)";
    #                 xpstart_displayid[$num_xpstart]=55;
    #               xpstart_xpconfigdir[$num_xpstart]="/home/gisburn/cwork/Xprint/Xprt_config/XpConfig";
    #                xpstart_auditlevel[$num_xpstart]=4;
    #                   xpstart_options[$num_xpstart]="-ac -pn";
    #num_xpstart=$(($num_xpstart + 1))

    #### Sample 3: 
    # # Start Xprt without TrueType fonts on a display 56 with custom
    # # XPCONFIGDIR and alternate "Xprinters" file
    #    xpstart_fontpath_rejectpattern[$num_xpstart]="/TrueType|/TT(/$|$)|/TTF(/$|$)";
    #                 xpstart_displayid[$num_xpstart]=56;
    #               xpstart_xpconfigdir[$num_xpstart]="/etc/XpConfig/default";
    #                    xpstart_xpfile[$num_xpstart]="/etc/XpConfig/default/Xprinters_test2"
    #                xpstart_auditlevel[$num_xpstart]="4";
    #                   xpstart_options[$num_xpstart]="-ac -pn";
    #               xpstart_xprt_binary[$num_xpstart]="";
    #num_xpstart=$(($num_xpstart + 1))

    #### Sample 4:
    # # Start Xprt with Solaris ISO-8859-7 (greek(="el") locale) fonts on
    # # display 57
    #                  xpstart_fontpath[$num_xpstart]="/usr/openwin/lib/locale/iso_8859_7/X11/fonts/75dpi,/usr/openwin/lib/locale/iso_8859_7/X11/fonts/Type1,/usr/openwin/lib/X11/fonts/misc/";
    #    xpstart_fontpath_acceptpattern[$num_xpstart]="";
    #    xpstart_fontpath_rejectpattern[$num_xpstart]="_No_Match_";
    #           xpstart_enable_truetype[$num_xpstart]="true";
    #                 xpstart_displayid[$num_xpstart]="57";
    #                xpstart_auditlevel[$num_xpstart]="4";
    #                   xpstart_options[$num_xpstart]="-ac -pn";
    #num_xpstart=$(($num_xpstart + 1))

    #### Sample 5:
    # # Start Xprt with the font list of an existing Xserver (excluding Speedo fonts) on
    # # display 58
    # # Note that this only works within a X session. At system boot time
    # # there will be no $DISPLAY to fetch the information from!!
    #                  xpstart_fontpath[$num_xpstart]="$(get_fontlist_from_display ${DISPLAY} | fontlist2fontpath)";
    #           xpstart_enable_truetype[$num_xpstart]="true";
    #    xpstart_fontpath_acceptpattern[$num_xpstart]="";
    #    xpstart_fontpath_rejectpattern[$num_xpstart]="";
    #                 xpstart_displayid[$num_xpstart]="58";
    #               xpstart_xpconfigdir[$num_xpstart]="";
    #                xpstart_auditlevel[$num_xpstart]="4";
    #                   xpstart_options[$num_xpstart]="-ac -pn";
    #               xpstart_xprt_binary[$num_xpstart]="";
    #num_xpstart=$(($num_xpstart + 1))

    #### Sample 6:
    # # List remote Xprt's here 
    # # (note that there is no test to check whether these DISPLAYs are valid!)
    #             xpstart_remote_server[$num_xpstart]="sera:12"    ; num_xpstart=$(($num_xpstart + 1))
    #             xpstart_remote_server[$num_xpstart]="gandalf:19" ; num_xpstart=$(($num_xpstart + 1))   
}

############################################################################



    ## Wrapper
wrapper()
{
        cmd="${2}"
        [ "${cmd}" = "" ] && fatal_error "No command given."
        shift ; shift
        export XPSERVERLIST="$(do_get_xpserverlist)"
        [ "${XPSERVERLIST}" = "" ] && fatal_error "No Xprint servers found."
        exec "${cmd}" "$@"
}

## Wrapper for "xplsprinters"
lsprinters()
{
        [                  "${ETC_INITD_XPRINT_XPLSPRINTERS_PATH}" != "" ] && cmd="${ETC_INITD_XPRINT_XPLSPRINTERS_PATH}"
        [ "${cmd}" = "" -a "${XPCUSTOMGLUE}" = "GISWxprintglue"          ] && cmd="/opt/GISWxprintglue/bin/xplsprinters"
        [ "${cmd}" = "" -a "${XPCUSTOMGLUE}" = "GISWxprint"              ] && cmd="/opt/GISWxprint/bin/xplsprinters"
        [ "${cmd}" = "" -a "${ETC_INITD_XPRINT_XPLSPRINTERS_PATH}" != "" ] && cmd="${XPROJECTROOT}/bin/xplsprinters"
        [ "${cmd}" = ""                                                  ] && cmd="xplsprinters"

        shift
        export XPSERVERLIST="$(do_get_xpserverlist)"
        [ "${XPSERVERLIST}" = "" ] && fatal_error "No Xprint servers found."
        exec "${cmd}" "$@"
}


depend() 
{
    need net cupsd
}

checkconfig() 
{
    eerror "You need to setup /etc/socks/sockd.conf first"
    eerror "Examples are in /usr/share/doc/dante/example"
}

start() 
{
    ebegin "Starting ${SERVICENAME}"
    if [ -f "${XP_SERVERS}" ] ; 
    then
        eerror "Xprint servers are already running."
    else
        # Check if we can write the registry file
        touch "${XP_SERVERS}" 2>/dev/null
        if [ ! -f "${XP_SERVERS}" ] ; 
	then
            eerror "Cannot create \"${XP_SERVERS}\"."
            exit 1
        fi

        if ! setup_config ; 
	then
            eerror "setup_config failed."
            exit 1
        fi

        # Provide two paths here - one which simply starts the Xprt servers,
        # assuming that there is a print spooler already running (or that 
        # ${XPCONFIG}/C/print/Xprinters provides static print queue entries
        # (like for the PSspooldir print model)) and a 2nd path which
        # explicitly checks if the print queue daemons are running
        msg "Starting Xprint servers"
        
        if [ "${CURRLOGNAME}" = "root" -a -d /var/lock/subsys/ ] ; 
	then
            touch /var/lock/subsys/xprint
        fi
    fi
#    start-stop-daemon --start --quiet --exec ${CFEXECD}	
    eend $?
}

stop() 
{
    ebegin "Stopping ${SERVICENAME}"
    start-stop-daemon --stop --quiet --exec ${SERVICE}	
    # Remove the X sockets/pipes which are not in use anymore
    # (It would be better if the Xservers would cleanup this
    # automatically, but most Xservers do not do that... ;-(
    # Note that this will not work on Solaris where applications
    # must run with groupid="root" if they want to write into
    # /tmp/.X11-unix/ and/or /tmp/.X11-pipe/)
    if [ "${display_id}" != "" ] ; 
    then
        rm -f "/tmp/.X${display_id}-lock"     2>/dev/null
        rm -f "/tmp/.X11-unix/X${display_id}" 2>/dev/null
        rm -f "/tmp/.X11-pipe/X${display_id}" 2>/dev/null
    fi 
    if [ "${CURRLOGNAME}" = "root" -a -d /var/lock/subsys/ ] ; 
    then
        rm -f /var/lock/subsys/xprint
    fi
    eend $?
}

